<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>kizu.ru</title>
  <link href="http://kizu.ru/feed.xml" rel="self"/>
  <link href="http://kizu.ru/"/>
  <updated>2016-12-21T00:00:00+03:00</updated>
  <id>http://kizu.ru</id>
  <author>
    <name>Roman Komarov</name>
    <email>kizmarh@ya.ru</email>
  </author>
  <entry>
    <title>Только по-английски</title>
    <link href="http://kizu.ru/blog/just-en/"/>
    <updated>2016-12-21T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/just-en</id>
    <content type="html">&lt;h1 id=&quot;только-по-английски&quot;&gt;Только &lt;span class=&quot;nobr&quot;&gt;по-английски&lt;/span&gt;&lt;/h1&gt;
&lt;p&gt;Довольно долгое время я пытался сохранять свой сайт двуязычным&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;практически все новые тексты я выпускал одновременно на русском и английском. С момента написания этого поста как минимум все технические статьи я буду публиковать только на английском.&lt;/p&gt;
&lt;p&gt;Необходимость писать всё по два раза по два раза сильно ограничивала то, с какой скоростью у меня получалось выпускать новые статьи и эксперименты. Обычно мне проще сесть, и за один присест написать большую часть &lt;span class=&quot;nobr&quot;&gt;какого-то&lt;/span&gt; текста. Без необходимости «переводить» этот текст, я смогу выпустить его практически сразу же после написания. Не нужно будет переключать контекст на другой язык (и тратить больше чем в два раза времени в итоге), а впоследствии и обновлять оба документа если приходится обновить &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; в одном.&lt;/p&gt;
&lt;p&gt;В таком двуязычии были свои преимущества&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;приходилось перечитывать текст несколько раз, часто &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; добавлялось и обновлялось, сам текст получался лучше. Но&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это занимало слишком много времени. Как уже выше написал&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;изменение в одном тексте влекло необходимость пересмотреть другой, в котором, в свою очередь, могло возникнуть &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt;, что тоже хотелось поправить, и так далее. С одним текстом на одном языке сильно проще. И я лучше уделю время вычитке и доработке только одного текста, нежели двух (или не буду тратить на вычитку и потрачу его на проработку других новых текстов).&lt;/p&gt;
&lt;p&gt;Я не исключаю того, что у меня возникнет желание публиковать на моём сайте и что-либо &lt;span class=&quot;nobr&quot;&gt;по-русски&lt;/span&gt;. Но это будет либо &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; личное (если я таки решусь на то, чтобы вести тут «личный блог»), либо &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt;, что напрямую касается русскоязычного сообщества, вроде моего поста &lt;a href=&quot;/blog/be-global/&quot;&gt;«Будьте глобальными»&lt;/a&gt; (или вот этого самого поста, который вы сейчас читаете).&lt;/p&gt;
&lt;p&gt;Если вдруг у &lt;span class=&quot;nobr&quot;&gt;кого-то&lt;/span&gt; возникнет желание переводить мои англоязычные посты на русский&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;пожалуйста. Если переведёте текст, и перевод будет удовлетворительным, то я опубликую ссылку на него в соответствующем англоязычном тексте (там, где у меня обычно переключалка языка; я придумаю как это оформить, чтобы было понятно, что это ссылка на внешний ресурс).&lt;/p&gt;
&lt;p&gt;Такие дела. Надеюсь, возможность писать в два раза меньше текста для каждой статьи сподвигнет меня на более активное ведение сайта.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Условия для CSS-переменных</title>
    <link href="http://kizu.ru/fun/conditions-for-css-variables/"/>
    <updated>2016-10-21T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/conditions-for-css-variables</id>
    <content type="html">&lt;h1 id=&quot;условия-для-css-переменных&quot;&gt;Условия для &lt;abbr&gt;CSS&lt;/abbr&gt;-переменных&lt;/h1&gt;
&lt;p&gt;Я начну с того, что в спецификациях &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#not-those&quot; id=&quot;not-those&quot;&gt;нет ничего&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Хотя и есть модуль с названием “&lt;a href=&quot;https://www.w3.org/TR/css3-conditional/&quot;&gt;&lt;abbr&gt;CSS&lt;/abbr&gt; Conditional Rules&lt;/a&gt;”, не стоит ожидать, что он о &lt;abbr&gt;CSS&lt;/abbr&gt;-переменных&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в нём только всякое про at-rules. И, кстати, даже есть &lt;a href=&quot;https://tabatkins.github.io/specs/css-when-else/&quot;&gt;предложение&lt;/a&gt; о @-правилах &lt;code&gt;@when&lt;/code&gt;/&lt;code&gt;@else&lt;/code&gt;, которые, опять же, никакого отношения к переменным не имеют.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; про условия для &lt;a href=&quot;https://www.w3.org/TR/css-variables-1/&quot;&gt;&lt;abbr&gt;CSS&lt;/abbr&gt;-переменных&lt;/a&gt;. Я думаю, что это огромное упущение, так как, хотя переменные уже предоставляют кучу вещей, которые невозможно достичь иными средствами, отсутствие условий очень удручает, так как их очень много для чего можно было бы использовать.&lt;/p&gt;
&lt;p&gt;Но что, если бы нам захотелось использовать эти воображаемые несуществующие условные конструкции для переменных уже &lt;em&gt;сейчас&lt;/em&gt;? Как и со множеством других вещей в &lt;abbr&gt;CSS&lt;/abbr&gt;, в &lt;span class=&quot;nobr&quot;&gt;каких-то&lt;/span&gt; случаях мы можем обойтись и хаками.&lt;/p&gt;
&lt;h2 id=&quot;определение-проблемы&quot;&gt;Определение проблемы&lt;/h2&gt;
&lt;p&gt;Итак, что нам нужно: возможность при помощи единственной &lt;abbr&gt;CSS&lt;/abbr&gt;-переменной уметь задавать &lt;em&gt;разные&lt;/em&gt; значения для разных &lt;abbr&gt;CSS&lt;/abbr&gt;-свойств, при этом без того, чтобы эти значения были основаны на этой самой переменной (или другими словами&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;эти значения не должны &lt;em&gt;вычисляться&lt;/em&gt; из нашей переменной).&lt;/p&gt;
&lt;p&gt;Нам нужны &lt;strong&gt;условия&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&quot;использование-вычислений-для-бинарных-условий&quot;&gt;Использование вычислений для бинарных условий&lt;/h2&gt;
&lt;p&gt;Перейду сразу к делу и приведу сходу решение, которое уже позже объясню, можете сначала попробовать сами понять что тут как работает:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;:root {
    --is-big: 0;
}

.is-big {
    --is-big: 1;
}

.block {
    padding: calc(
        25px * var(--is-big) +
        10px * (1 - var(--is-big))
    );
    border-width: calc(
        3px * var(--is-big) +
        1px * (1 - var(--is-big))
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В этом примере мы заставляем все наши элементы с &lt;code&gt;.block&lt;/code&gt; получать паддинги равные &lt;code&gt;10px&lt;/code&gt; и ширины границ равные &lt;code&gt;1px&lt;/code&gt;, до тех пор, пока значение переменной &lt;code&gt;--is-big&lt;/code&gt; на этих элементах не станет равным &lt;code&gt;1&lt;/code&gt;, и в этом случае значения станут &lt;code&gt;25px&lt;/code&gt; и &lt;code&gt;3px&lt;/code&gt; соответственно.&lt;/p&gt;
&lt;p&gt;Механизм под всем этим довольно простой: мы используем оба возможных значения в едином вычислении, используя &lt;code&gt;calc()&lt;/code&gt;, где мы обнуляем одно значение и оставляем другое в зависимости от нашей переменной, которая может принимать одно из двух значений: &lt;code&gt;1&lt;/code&gt; или &lt;code&gt;0&lt;/code&gt;. Иными словами, у нас там будет &lt;code&gt;25px * 1 + 10px * 0&lt;/code&gt; в одном случае и &lt;code&gt;25px * 0 + 10px * 1&lt;/code&gt; в другом.&lt;/p&gt;
&lt;h2 id=&quot;более-сложные-условия&quot;&gt;Более сложные условия&lt;/h2&gt;
&lt;p&gt;Мы можем использовать этот метод не только для выбора из двух возможных значений, но и для трёх или более. Правда, для каждого нового значения сложность вычисления увеличивается. Так, для трёх возможных значений, вычисление станет уже таким:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.block {
    padding: calc(
        100px * (1 - var(--foo)) * (2 - var(--foo)) * 0.5 +
         20px * var(--foo) * (2 - var(--foo)) +
          3px * var(--foo) * (1 - var(--foo)) * -0.5
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут это вычисление принимает три возможных значения для переменной &lt;code&gt;--foo&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;1&lt;/code&gt; и &lt;code&gt;2&lt;/code&gt;, и вычисляет паддинг равный &lt;code&gt;100px&lt;/code&gt;, &lt;code&gt;20px&lt;/code&gt; или &lt;code&gt;3px&lt;/code&gt; соответственно.&lt;/p&gt;
&lt;p&gt;Общий принцип тот же: нам нужно каждый возможный результат умножить на выражение, дающее &lt;code&gt;1&lt;/code&gt; для нужного значения переменной и &lt;code&gt;0&lt;/code&gt; для остальных. И это выражение составляется так же просто: нам нужно обнулять каждое иное возможное значение переменной. После чего нам нужно подставить то значение, которое должно давать &lt;code&gt;1&lt;/code&gt; в получившееся выражение и добавить множитель для того, чтобы привести-таки результат к этой самой единице.&lt;/p&gt;
&lt;h3 id=&quot;возможная-ловушка-в-спецификациях&quot;&gt;Возможная ловушка в спецификациях&lt;/h3&gt;
&lt;p&gt;С увеличением сложности вычислений появляется шанс, что они перестанут работать. Почему? В &lt;a href=&quot;https://drafts.csswg.org/css-values-3/#calc-syntax&quot;&gt;спецификации&lt;/a&gt; есть такая вот заметка (в моём переводе):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Браузеры должны поддерживать &lt;code&gt;calc()&lt;/code&gt;-выражения, состоящие как минимум из 20 терминов, где каждое &lt;abbr&gt;ЧИСЛО&lt;/abbr&gt;, &lt;abbr&gt;РАЗМЕРНОСТЬ&lt;/abbr&gt; или &lt;abbr&gt;ПРОЦЕНТ&lt;/abbr&gt; является термином. Если &lt;code&gt;calc()&lt;/code&gt;- выражение содержит больше терминов, чем поддерживается, такое выражение должно считаться невалидным.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Конечно, я немного потестировал это дело и не смог найти подобных ограничений в существующих браузерах, но, так или иначе, есть шанс, что если вы напишете достаточно сложный код, то вы столкнётесь с этим ограничением, ну или &lt;span class=&quot;nobr&quot;&gt;какие-то&lt;/span&gt; браузеры вполне могут его в будущем добавить, так что будьте осторожны.&lt;/p&gt;
&lt;h2 id=&quot;условия-для-цветов&quot;&gt;Условия для цветов&lt;/h2&gt;
&lt;p&gt;Как можно увидеть, такие вычисления могут использоваться только для тех вещей, которые вы можете &lt;em&gt;вычислить&lt;/em&gt;, так что не получится использовать это дело для переключения значений свойств типа &lt;code&gt;display&lt;/code&gt; и аналогичных. Но что насчёт цветов? На самом деле, мы можем вычислять значения отдельных компонент цвета. К сожалению, сейчас это будет работать только в вебкитах и блинках, а вот Firefox &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=984021&quot; title=&quot;Bugzilla ticket&quot;&gt;пока не поддерживает&lt;/a&gt; &lt;code&gt;calc()&lt;/code&gt; внутри &lt;code&gt;rgba()&lt;/code&gt; или других цветовых функций.&lt;/p&gt;
&lt;p&gt;Но когда такая поддержка появится (ну или если вам захочется поэкспериментировать над этим делом там, где оно уже работает), мы можем делать вещи вроде этой:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;:root {
    --is-red: 0;
}

.block {
    background: rgba(
        calc(
            255*var(--is-red) +
            0*(1 - var(--is-red))
            ),
        calc(
            0*var(--is-red) +
            255*(1 - var(--is-red))
            ),
        0, 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут у нас будет по умолчанию зелёный цвет, и красный, если мы зададим &lt;code&gt;--is-red&lt;/code&gt; значение &lt;code&gt;1&lt;/code&gt; (стоит отметить, что если &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; компонент должен быть нулём, то мы, очевидно, можем просто все его множетели опустить для более компактной записи, но тут я их оставил для лучшего понимания алгоритма).&lt;/p&gt;
&lt;p&gt;И, так как мы можем вычислять любые компоненты цвета, мы можем создавать для них наши условные вычисления (и, возможно, сможем делать их даже для градиентов? Вам стоит это попробовать!).&lt;/p&gt;
&lt;h3 id=&quot;очередная-ловушка-в-спецификациях&quot;&gt;Очередная ловушка в спецификациях&lt;/h3&gt;
&lt;p&gt;Когда я тестировал как работают уловные вычисления для цветов, я наткнулся на очень, &lt;em&gt;очень&lt;/em&gt; &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#issue-resolved&quot; id=&quot;issue-resolved&quot;&gt;странное ограничение в спецификициях&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Таб Аткинс &lt;a href=&quot;https://github.com/kizu/kizu.github.com/issues/186&quot;&gt;рассказал&lt;/a&gt; о том, что эта проблема с компонентами цвета была поправлена в спецификациях (но исправление ещё не поддержано браузерами). Ура! Также он сказал, что есть ещё решение&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;использовать внутри &lt;code&gt;rgba&lt;/code&gt; проценты, а я совершенно о такой возможности забыл, хаха.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;. Ограничение под названием &lt;a href=&quot;https://twitter.com/kizmarh/status/788504161864261632&quot;&gt;«проверка типов»&lt;/a&gt;. Теперь я её официально ненавижу. Что это ограничение значит&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если ваше свойство принимает только значение с типом &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;, то если у вас внутри &lt;code&gt;calc()&lt;/code&gt; будут дробные числа или любое деление, то даже если в результате будет гарантировано целое число, то так называемый «resolved type» будет не &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;, а &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt;, что, в свою очередь, не даст этим свойствам принимать это значение как валидное. А так как, если посмотреть выше, в наших условных выражениях с более чем двумя значениями окажутся дробные модификаторы, то они сделают наши вычисления невалидными, как для компонент цвета, так и для других свойств, принимающих только &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt; (например, &lt;code&gt;z-index&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Вот такое выражение:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;calc(255 * (1 - var(--bar)) * (var(--bar) - 2) * -0.5)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Не будет валидным внутри &lt;code&gt;rgba()&lt;/code&gt;. Изначально я даже думал, что такое поведение&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;баг, особенно учитывая, что цветовые функции вообще хорошо переваривают всякие значения, выходящие за разумные границы (вы вполне можете написать &lt;code&gt;rgba(9001, +9001, -9001, 42)&lt;/code&gt; и это даст вам валидный жёлтый цвет), но вот эта вот типизация оказывается слишком сложно перевариваемой для браузеров.&lt;/p&gt;
&lt;h4 id=&quot;возможные-решения-&quot;&gt;Возможные решения?&lt;/h4&gt;
&lt;p&gt;Есть одно довольно далёкое от идеала решение. Так как в нашем случае мы знаем и желаемое значение, и проблемный модификатор с дробью, то мы можем предвычислить их вместе и округлить перед тем, как вставлять в &lt;code&gt;calc()&lt;/code&gt;. Да, во многих случаях получаемое значение будет чуть отличаться &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; потери в точности. Но это же лучше, чем ничего, ведь правда?&lt;/p&gt;
&lt;p&gt;Хотя есть ещё одно решение, но которое будет работать только с цветами&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;мы можем использовать &lt;code&gt;hsla&lt;/code&gt; вместо &lt;code&gt;rgba&lt;/code&gt;, так как в таком случае внутри будут не целые числа, а то, что таки нормально пережёвывает &lt;code&gt;calc()&lt;/code&gt;. Но да, для свойств вроде &lt;code&gt;z-index&lt;/code&gt; это не прокатит. И даже для цветов всё равно возможны небольшие потери в точности если переводить для этого &lt;code&gt;rgb&lt;/code&gt; в &lt;code&gt;hsl&lt;/code&gt;. Но эти потери должны быть меньше, чем в предыдущем решении.&lt;/p&gt;
&lt;h2 id=&quot;препроцессинг&quot;&gt;Препроцессинг&lt;/h2&gt;
&lt;p&gt;Тогда как для бинарных условий вполне реально писать вычисления вручную, для более сложных случаев, или в случае тех же цветов, нам бы пригодились инструменты, которые бы позволили делать это всё автоматически. К счастью, у нас есть для этого препроцессоры.&lt;/p&gt;
&lt;p&gt;Вот как я реализовал это быстренько на &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#pen&quot; id=&quot;pen&quot;&gt;Стайлусе&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Можно посмотреть на этот же код &lt;a href=&quot;http://codepen.io/kizu/pen/zKmyvG&quot;&gt;на CodePen&lt;/a&gt; in action.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;conditional($var, $values...)
  $result = &amp;#39;&amp;#39;

  // If there is only an array passed, use its contents
  if length($values) == 1
    $values = $values[0]

  // Validating the values and check if we need to do anything at all
  $type = null
  $equal = true

  for $value, $i in $values
    if $i &amp;gt; 0 and $value != $values[0]
      $equal = false

    $value_type = typeof($value)
    $type = $type || $value_type
    if !($type == &amp;#39;unit&amp;#39; or $type == &amp;#39;rgba&amp;#39;)
      error(&amp;#39;Conditional function can accept only numbers or colors&amp;#39;)

    if $type != $value_type
      error(&amp;#39;Conditional function can accept only same type values&amp;#39;)

  // If all the values are equal, just return one of them
  if $equal
    return $values[0]

  // Handling numbers
  if $type == &amp;#39;unit&amp;#39;
    $result = &amp;#39;calc(&amp;#39;
    $i_count = 0
    for $value, $i in $values
      $multiplier = &amp;#39;&amp;#39;
      $modifier = 1
      $j_count = 0
      for $j in 0..(length($values) - 1)
        if $j != $i
          $j_count = $j_count + 1
          // We could use just the general multiplier,
          // but for 0 and 1 we can simplify it a bit.
          if $j == 0
            $modifier = $modifier * $i
            $multiplier = $multiplier + $var
          else if $j == 1
            $modifier = $modifier * ($j - $i)
            $multiplier = $multiplier + &amp;#39;(1 - &amp;#39; + $var + &amp;#39;)&amp;#39;
          else
            $modifier = $modifier * ($i - $j)
            $multiplier = $multiplier + &amp;#39;(&amp;#39; + $var + &amp;#39; - &amp;#39; + $j + &amp;#39;)&amp;#39;

          if $j_count &amp;lt; length($values) - 1
            $multiplier = $multiplier + &amp;#39; * &amp;#39;

      // If value is zero, just don&amp;#39;t add it there lol
      if $value != 0
        if $modifier != 1
          $multiplier = $multiplier + &amp;#39; * &amp;#39; + (1 / $modifier)
        $result = $result + ($i_count &amp;gt; 0 ? &amp;#39; + &amp;#39; : &amp;#39;&amp;#39;) + $value + &amp;#39; * &amp;#39; + $multiplier
        $i_count = $i_count + 1

    $result = $result + &amp;#39;)&amp;#39;

  // Handling colors
  if $type == &amp;#39;rgba&amp;#39;
    $hues = ()
    $saturations = ()
    $lightnesses = ()
    $alphas = ()

    for $value in $values
      push($hues, unit(hue($value), &amp;#39;&amp;#39;))
      push($saturations, saturation($value))
      push($lightnesses, lightness($value))
      push($alphas, alpha($value))

    $result = &amp;#39;hsla(&amp;#39; + conditional($var, $hues) + &amp;#39;, &amp;#39; + conditional($var, $saturations) + &amp;#39;, &amp;#39; + conditional($var, $lightnesses) + &amp;#39;, &amp;#39; + conditional($var, $alphas) +  &amp;#39;)&amp;#39;

  return unquote($result)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Да, кода довольно много, но этот миксин способен генерировать условия как для чисел, так и для цветов, и не только для бинарных условий, но и для любого числа возможных значений в них.&lt;/p&gt;
&lt;p&gt;Использование миксина очень простое:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;border-width: conditional(var(--foo), 10px, 20px)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Первый аргумент&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;наша переменная, вторым аргументом будет то значение, которое должно применяться когда переменная будет равна &lt;code&gt;0&lt;/code&gt;, третий аргумент&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;1&lt;/code&gt;, и т.д.&lt;/p&gt;
&lt;p&gt;Вызов миксина выше сгенерит вот такое условное выражение:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;border-width: calc(10px * (1 - var(--foo)) + 20px * var(--foo));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;А вот более сложный пример с цветами:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;color: conditional(var(--bar), red, lime, rebeccapurple, orange)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Он сгенерит то, что вы точно не захотите писать вручную:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;color: hsla(calc(120 * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 270 * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 38.82352941176471 * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), calc(100% * (1 - var(--bar)) * (var(--bar) - 2) * (var(--bar) - 3) * 0.16666666666666666 + 100% * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 49.99999999999999% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 100% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), calc(50% * (1 - var(--bar)) * (var(--bar) - 2) * (var(--bar) - 3) * 0.16666666666666666 + 50% * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 40% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 50% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), 1);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Стоит отметить, что у меня в миксине нет поддержки тех мест, где принимаются только &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;, так что он может не работать для &lt;code&gt;z-index&lt;/code&gt; и прочих. Но он уже конвертирует цвета в &lt;code&gt;hsla()&lt;/code&gt;, чтобы с ними справляться (хотя и это можно доделать так, чтобы это происходило только тогда когда нужно, а не всегда). Другая вещь, которую я не реализовал (пока?) в этом миксине&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;возможность прокидывать в качестве значений другие &lt;abbr&gt;CSS&lt;/abbr&gt;-переменные. Это вполне возможно для тех свойств, что принимают не &lt;code&gt;&amp;lt;integer&amp;gt;&lt;/code&gt;, так как их можно будет просто подставлять в наши условные вычисления. Возможно, когда-нибудь я и найду время чтобы это доделать. А пока можно для простых случаев писать эти выражения вручную следуя алгоритму, описанному в этой статье.&lt;/p&gt;
&lt;h2 id=&quot;фолбеки&quot;&gt;Фолбеки&lt;/h2&gt;
&lt;p&gt;Конечно, если вы действительно собираетесь всё это дело использовать, вам понадобится возможность использовать фолбеки. Для браузеров, не поддерживающих переменные, это просто&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;можно определять декларацию с фолбеком заранее:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.block {
    padding: 100px; /* fallback */
    padding: calc(
        100px * ((1 - var(--foo)) * (2 - var(--foo)) / 2) +
         20px * (var(--foo) * (2 - var(--foo))) +
          3px * (var(--foo) * (1 - var(--foo)) / -2)
    );
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Но вот когда дело доходит до цветов, то появляется проблема: как только появляются переменные, то по факту (и это очередное очень странное место в спецификациях), &lt;em&gt;тупо любая&lt;/em&gt; декларация, в которой есть &lt;abbr&gt;CSS&lt;/abbr&gt;-переменные, оказывается валидной. А это значит, что не получится использовать фолбек для чего-либо, где есть &lt;abbr&gt;CSS&lt;/abbr&gt;-переменные:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;background: blue;
background: I 💩 CSS VAR(--I)ABLES;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вот это вот&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;валидно согласно спецификациям, фон будет принимать своё &lt;code&gt;initial&lt;/code&gt; значение, а фолбек применяться не будет (даже если ну совершенно очевидно, что остальные части значения ну уж точно некорректны).&lt;/p&gt;
&lt;p&gt;Так что, для того, чтобы предоставлять фолбеки в подобных случаях, нам надо будет воспользоваться обёрткой с &lt;code&gt;@supports&lt;/code&gt;, в которой мы будем проверять поддержку всего &lt;strong&gt;кроме&lt;/strong&gt; переменных.&lt;/p&gt;
&lt;p&gt;В нашем случае нам надо добавить такую обёртку для Firefox:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.block {
    color: #f00;
}
@supports (color: rgb(0, calc(0), 0)) {
    .block {
        color: rgba(calc(255 * (1 - var(--foo))), calc(255 * var(--foo)), 0, 1);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут мы тестируем поддержку вычислений внутри цветовых функций, после чего применяем условное вычисление для цвета внутри этой проверки.&lt;/p&gt;
&lt;p&gt;В принципе, вполне возможно создавать такие фолбеки автоматически, но я бы не рекомендовал использовать для этого препроцессоры&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сложность того, что для этого нужно будет делать уже превышает возможности препроцессоров.&lt;/p&gt;
&lt;h2 id=&quot;сценарии-использования&quot;&gt;Сценарии использования&lt;/h2&gt;
&lt;p&gt;Я, правда, не люблю расписывать сценарии использования для вещей, необходимость в которых очевидна. Так что я буду краток. И да, я опишу сценарии использования условий не только для переменных, но и для вычислений с помощью &lt;code&gt;calc()&lt;/code&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Условия для &lt;abbr&gt;CSS&lt;/abbr&gt;-переменных могут быть идеальны для тематизации блоков. С их помощью можно иметь набор пронумерованных тем и потом применять их к блокам (и даже ко вложенным!) используя только одну &lt;abbr&gt;CSS&lt;/abbr&gt;-переменную типа &lt;code&gt;--block-variant: 1&lt;/code&gt;. Это то, что невозможно сделать &lt;span class=&quot;nobr&quot;&gt;чем-то&lt;/span&gt; кроме как переменными, а если появится необходимость задавать для темы разные значения для разных свойств, то без условий пришлось бы задавать целый набор разных переменных каждый раз когда хочется применить тему.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Типографика. Если бы была возможность использовать сравнения с &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt; и &lt;code&gt;&amp;gt;=&lt;/code&gt;, то можно было бы создать набор «правил» для разных размеров шрифта, чтобы автоматически подбирать высоту строки, жирность и другие свойства шрифта в зависимости от исходного размера. Это и сейчас возможно, конечно, но не тогда, когда нужно иметь «шаги» для размеров, а не просто значения вычисленные из &lt;code&gt;em&lt;/code&gt;-ов.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Адаптивный дизайн. Ну, если бы были полноценные условия для вычислений, то это было бы почти что теми самыми «element queries»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;можно было бы смотреть на &lt;code&gt;vw&lt;/code&gt; или ширину родителей и решать какие значения применять в каком случае.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Наверняка есть и другие сценарии использования для условий, расскажите если придумаете! Я сам, уверен, натыкался на множество из них, но, так как у меня очень плохая память, то я не запоминаю всё-всё, что я хочу делать с &lt;abbr&gt;CSS&lt;/abbr&gt;. Потому что я хочу делать &lt;em&gt;всё&lt;/em&gt;.&lt;/p&gt;
&lt;h2 id=&quot;будущее&quot;&gt;Будущее&lt;/h2&gt;
&lt;p&gt;Я бы очень хотел увидеть условия для &lt;abbr&gt;CSS&lt;/abbr&gt;-переменных в спецификициях &lt;abbr&gt;CSS&lt;/abbr&gt;, так чтобы нам не приходилось прибегать к хакам и мы могли бы использовать условия и для невычисляемых значений. Ну и даже с хаками пока невозможно использовать условия кроме как строгого равенства, так что никаких нам «если переменная больше, чем X» и подобных вещей. Я не вижу причин почему в &lt;abbr&gt;CSS&lt;/abbr&gt; нельзя добавить полноценные условия, так что если вы знакомы с &lt;span class=&quot;nobr&quot;&gt;кем-то&lt;/span&gt;, кто разрабатывает спецификации &lt;abbr&gt;CSS&lt;/abbr&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вы им намекните там. Я только надеюсь, что нам не ответят &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; вроде «просто используйте JS» и не станут делать предположения о том, почему это в принципе невозможно. Да вот же, оно уже возможно, пускай и с хаками. Не может быть никаких оправданий.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Оформление строчных блоков кода</title>
    <link href="http://kizu.ru/blog/styling-inline-code/"/>
    <updated>2016-09-08T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/styling-inline-code</id>
    <content type="html">&lt;h1 id=&quot;оформление-строчных-блоков-кода&quot;&gt;Оформление строчных блоков кода&lt;/h1&gt;
&lt;p&gt;Когда я работал над &lt;a href=&quot;/blog/the-new-version-of-this-site/&quot;&gt;новой версией моего сайта&lt;/a&gt;, я пытался побольше думать о том, как всё будет выглядеть и читаться с точки зрения типографики. Одной из вещей, с которыми у меня всегда были проблемы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;как оформлять строчные блоки кода. Чаще всего, на их месте мы видим маленькие разноцветные прямоугольники. И чем больше ими набиваешь текст, тем хуже становится его читабельность.&lt;/p&gt;
&lt;figure class=&quot;Sidenote-Wrapper&quot;&gt;&lt;figcaption class=&quot;Sidenote&quot;&gt;Пример взят из &lt;a href=&quot;https://en.wikipedia.org/wiki/Cascading_Style_Sheets#Selector&quot;&gt;статьи в Википедии о &lt;abbr&gt;CSS&lt;/abbr&gt;&lt;/a&gt;. Поглядите на все эти разноцветные прямоугольники. Кроме того, заметьте, что в тексте есть несколько мест, которые можно было бы разметить строчными блоками кода. Возможно, это не было сделано как раз &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; того, что текст стал бы ещё сильнее захламлён.&lt;/figcaption&gt;&lt;img class=&quot;Sidenote-Context&quot; src=&quot;http://kizu.ru/blog/styling-inline-code/example.png&quot; title=&quot;&quot; alt=&quot;Скриншот из Википедии&quot;&gt;&lt;/figure&gt;
&lt;p&gt;Что, если это слишком часто используемое оформление строчных блоков кода&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;излишне?&lt;/p&gt;
&lt;p&gt;Практически всё, что мы видим, приходит от полноценных многострочных блоков кода. Но точно ли нам нужны все эти стили в строчном контексте?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Нужен ли нам моноширинный шрифт?&lt;/strong&gt; Неа. Моноширинность полезна тогда, когда у нас есть несколько строк, внутри которых нам нужно выравнивать символы друг относительно друга определённым образом. Но вот внутри обычного текста? Нам это не нужно. Уходи, моноширинный шрифт.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Нужны ли нам &lt;span class=&quot;nobr&quot;&gt;какие-то&lt;/span&gt; бордеры или цвет фона?&lt;/strong&gt; Вряд ли. На больших блоках кода они выглядят нормально, но в строчном контексте подобное оформление очень сильно выпячивает наши строчные блоки, делая их слишком &lt;strong&gt;жирными&lt;/strong&gt;. А это, в свою очередь, ухудшает читаемость текста, так как глаз начинает спотыкаться, обращать внимание на эти яркие пятна ещё до того, как мы дочитаем до нужно места.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Нужна ли нам подсветка синтаксиса?&lt;/strong&gt; Сомневаюсь. Она полезна тогда, когда у нас есть много кода, и нам нужно отделить одни конструкции в нём от других. А вот в строчном контексте, когда в блоках кода оказываются лишь одно-два слова, подсветка становится излишней и ничего нам не даёт кроме ненужного привлечения внимания.&lt;/p&gt;
&lt;h2 id=&quot;мо-решение&quot;&gt;Моё решение&lt;/h2&gt;
&lt;p&gt;Итак, если все эти стили лишние, а то и вредные для нашего текста, что нам использовать вместо них? После обдумывания всех этих моментов, я решил вспомнить о том, как же оформляют похожие сущности в обычных книгах. И, оказывается, что когда доходит дело до ненавязчивого выделения небольших фрагментов текста, решение очевидно. &lt;em&gt;Курсив&lt;/em&gt;. И если он подходит для большинства обычных текстов, то почему бы не использовать курсив и для оформления строчных блоков кода?&lt;/p&gt;
&lt;figure class=&quot;Sidenote-Wrapper&quot;&gt;&lt;figcaption class=&quot;Sidenote&quot;&gt;Моя версия примера выше, теперь хоть читается как текст. Нижние строчные блоки кода, с полными &lt;abbr&gt;CSS&lt;/abbr&gt;-правилами, в принципе, в &lt;span class=&quot;nobr&quot;&gt;чём-то&lt;/span&gt; выигрывали от подсветки, так что, возможно, стоит в таких местах её возвращать, но уж точно не такую яркую, какой она была до этого.&lt;/figcaption&gt;&lt;img class=&quot;Sidenote-Context&quot; src=&quot;http://kizu.ru/blog/styling-inline-code/solution.png&quot; title=&quot;&quot; alt=&quot;Исправленный скриншот из Википедии&quot;&gt;&lt;/figure&gt;
&lt;p&gt;Собственно, можно посмотреть на строчный блок кода &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#semantics&quot; id=&quot;semantics&quot;&gt;прямо в этом тексте&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Прямо тут я использовал &lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;, так как этот текст может оказаться, например, в &lt;abbr&gt;RSS&lt;/abbr&gt;-читалке, то есть там, где вы, скорее всего, не увидите стилей, специфичных для моего блога.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;: &lt;em&gt;font-style: italic&lt;/em&gt;. На мой взгляд, выглядит вполне неплохо&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;ненавязчиво, но явно отделено от основного текста.&lt;/p&gt;
&lt;p&gt;Курсив достаточно отделяет код от остального текста, в большинстве случаев можно вообще больше ничего не добавлять. Самый простой способ сделать такие блоки кода курсивными следующий:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;:not(pre) &amp;gt; code {
    font: inherit;
    font-style: italic;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Этим мы сделаем наши стандартные моноширинные блоки кода стандартным курсовом. Обратите внимание на &lt;code&gt;:not(pre)&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если размечать полноценные блоки кода с помощью &lt;code&gt;&amp;lt;pre&amp;gt;&amp;lt;code&amp;gt;&lt;/code&gt;, этот селектор к ним не применится. Конечно, если мы используем &lt;span class=&quot;nobr&quot;&gt;какую-то&lt;/span&gt; подсветку синтаксиса, нам надо будет её отключить для строчных блоков кода (или переопределить её стили). В некоторых случаях, когда вы используете отдельный шрифт для курсивного начертания, а в нашем веб-шрифте его нет, нам надо будет не забыть указать отдельны веб-шрифт и для наших блоков кода, иначе мы получим псевдокурсив.&lt;/p&gt;
&lt;h2 id=&quot;да-это-вс-субъективно&quot;&gt;Да, это всё субъективно&lt;/h2&gt;
&lt;p&gt;Курсив для строчных блоков текста, конечно, может быть непривычен. Я и не говорю, что это единственный правильный вариант. Можно сказать, что это дело стиля&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;как вы будете оформлять строчные блоки кода. Иногда вы можете и захотеть, чтобы они выпячивались и привлекали внимание. Но, если вам захочется добавить читаемости вашим испещрённым строчными блоками кода текстам,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;курсив вам в этом поможет.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Новая версия этого сайта</title>
    <link href="http://kizu.ru/blog/the-new-version-of-this-site/"/>
    <updated>2016-08-13T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/the-new-version-of-this-site</id>
    <content type="html">&lt;h1 id=&quot;новая-версия-этого-сайта&quot;&gt;Новая версия этого сайта&lt;/h1&gt;
&lt;p&gt;Примерно полтора месяца назад, &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#yep&quot; id=&quot;yep&quot;&gt;23 июня&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Да, с момента перезапуска до публикации этого поста прошло больше месяца&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;хотелось посмотреть как сайт будет себя вести и поправить ещё несколько моментов.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, я в очередной раз перезапустил свой сайт. Сложно вспомнить которая это уже версия. Но если считать с самого начала, с тех времён, когда я ещё не умел верстать, то это, получается, уже тринадцатая мажорная версия. Или около того. Конечно, если не учитывать незаконченные и выкинутые в корзину варианты.&lt;/p&gt;
&lt;h2 id=&quot;немного-истории&quot;&gt;Немного истории&lt;/h2&gt;
&lt;p&gt;Cамый первый мой сайт появился в интернетах четвёртого ноября 2001 года. Тогда я ещё не знал что такое &lt;abbr&gt;CSS&lt;/abbr&gt;. Не знал совсем: даже не представлял, что такая вещь как &lt;abbr&gt;CSS&lt;/abbr&gt; существует&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сайт был сделан на фреймах и таблицах. На сайте располагалось, в основном, моё всяческое творчество. Например, карты для игры Heroes of Might and Magic &lt;abbr&gt;III&lt;/abbr&gt;, дурацкая поэзия, а также всякая прочая ерунда. Поначалу сайт хостился на бесплатном bk.ru, потом&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;долгое время на «народе», где претерпел кучу изменений и ещё целых восемь версий не имел ничего общего с тем, что сейчас можно на нём обнаружить.&lt;/p&gt;
&lt;p&gt;В декабре 2006 года я впервые прочитал спецификации &lt;abbr&gt;CSS&lt;/abbr&gt;, и, чуть больше года спустя, в феврале 2008 года, запустил девятую версию сайта, уже на своём домене&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;kizu.ru. К тому моменту я уже &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; понимал в вёрстке&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в те годы я очень активно пилил стили для ЖЖ, начиная с вёрстки только &lt;abbr&gt;CSS&lt;/abbr&gt;-переопределениями, и заканчивая полностью кастомными раскладками. Потому новый сайт стал посвящён только вёрстке, а всё творчество осталось разве что у меня в архивах, да в том самом подзамочном ЖЖ.&lt;/p&gt;
&lt;p&gt;В самом начале в качестве движка для kizu.ru я взял &lt;a href=&quot;https://movabletype.org/&quot;&gt;Movable Type&lt;/a&gt;. Потом, в августе 2009 года, когда я ещё глубже погрузился в вёрстку и научился делать совсем всё с ноля, я превратил сайт в набор обычных статичных html-файлов. А к февралю 2011 года мне уже немного надоело поддерживать сайт вручную (точнее, при помощи регулярных выражений и глобального поиска и замены в редакторе), так что я опять заморочился на &lt;span class=&quot;nobr&quot;&gt;какую-то&lt;/span&gt; автоматизацию и реализовал всё то, что на тот момент было готово в статике, но уже на генераторе статики &lt;a href=&quot;http://nanoc.ws/&quot;&gt;nanoc&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;И ещё два года спустя, 17 января 2013 года, я &lt;a href=&quot;/issues/restart/&quot;&gt;перезапустил сайт&lt;/a&gt; на &lt;a href=&quot;https://jekyllrb.com/&quot;&gt;Jekyll&lt;/a&gt;, с хостингом на &lt;a href=&quot;https://pages.github.com/&quot;&gt;GitHub Pages&lt;/a&gt;. Но на этот раз я полностью переосмыслил дизайн и всерьёз заморочился типографикой. Это была предыдущая, двенадцатая версия сайта, с которой я прожил больше трёх с половиной лет.&lt;/p&gt;
&lt;h2 id=&quot;тринадцатая-версия&quot;&gt;Тринадцатая версия&lt;/h2&gt;
&lt;h3 id=&quot;движок&quot;&gt;Движок&lt;/h3&gt;
&lt;p&gt;На этот раз я снова всё переписал с ноля. Дважды! Так, мною хвалимый поначалу Jekyll начал мне жать. Из коробки (то бишь, в той версии, что поставляется с GitHub Pages), он умеет не так много. А всяких продвинутых возможностей (в основном, для заморочек с типографикой) в нём можно было достичь только либо очень адским кодом на встроенном шаблонизаторе Liquid, либо написанием сторонних плагинов на ruby. В Liquid я быстро упёрся в потолок его возможностей (хотя и натворив там того, что вряд ли &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; на нём до этого делал), а плагины на ruby не поддерживались на GitHub Pages. А если же билдить сайт локально из исходников и потом пушить только статику, то мне показалось более разумной идеей взять какое-нибудь аналогичное решение, но только на JS, который я знаю и понимаю гораздо лучше, чем ruby.&lt;/p&gt;
&lt;p&gt;Выбор пал на &lt;a href=&quot;http://docpad.org/&quot;&gt;Docpad&lt;/a&gt;, на котором я практически полностью переделал сайт. Однако, чем дальше я заморачивался с плагинами для него, тем больше он начинал тормозить. В &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; момент, когда сборка стала занимать уже больше 90 секунд, я решил остановиться и посмотреть на свой сайт свежим взглядом. После продолжительных раздумий и чтения документации других генераторов статики, я пришёл к выводу, что мне ничего из имеющегося не подходит. Везде мне пришлось бы лезть глубоко в ядро генераторов, писать кучу своего кода и не полагаться на сторонние плагины. А это бы значило, что мне пришлось бы бороться с тем, как работают сами генераторы, от чего я уже устал, работая с Джекиллом и Докпадом.&lt;/p&gt;
&lt;p&gt;В итоге, я написал практически всё сам, взяв за основу gulp и тот свой JS, что я уже до этого написал для выкинутой версии на Докпаде. Сразу хочу сказать, что на исходники пока лучше не смотреть. Всё. Очень. Плохо. Я изучал gulp на лету, прототипировал, экспериментировал. Но даже текущий далеко не оптимальный код собирается на порядок быстрее, чем то, что было в Докпаде. Около 8-9 секунд, при большей функциональности и сложности. А с вотчерами отдельные части пересобираются и того быстрее. В планах есть добавить пересборку только контента конкретных изменившихся постов, тогда всё станет вообще молниеносно. А новые фичи, даже в текущий ужасный код, добавлять уже очень просто.&lt;/p&gt;
&lt;p&gt;В итоге, я всячески рад тому, что ушёл от готовых решений для генерации статики и изучил основы gulp. Возможно, когда-нибудь &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; из того, что я понаписал для своего сайта, получится отделить и превратить во &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt;, что и вы сможете использовать. Но ничего не обещаю. Ну и, конечно, наверняка в &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; момент я опять всё пересмотрю и переделаю всё, в который уже раз, на каком-нибудь модном на тот момент реакте-вебпаке, кто знает! Но вот прямо сейчас меня практически всё устраивает.&lt;/p&gt;
&lt;h3 id=&quot;в-рстка-дизайн-и-типографика&quot;&gt;Вёрстка, дизайн и типографика&lt;/h3&gt;
&lt;p&gt;На исходный код стилей аналогично не рекомендую смотреть. Большая часть стилей осталась от предыдущей версии сайта, возможно, &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; чуть-чуть причесалось, но… Я бы всё взял и переписал. Нет, большинство решений именно в вёрстке мне до сих пор нравится, но исходники&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;грязные, очень плохо структурированные, не смотрите на них. Самое вкусное я всё равно опишу в &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#i-swear&quot; id=&quot;i-swear&quot;&gt;грядущих постах&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;&lt;span class=&quot;nobr&quot;&gt;Да-да&lt;/span&gt;, я постоянно обещаю всё новые и новые посты, но &lt;em&gt;на &lt;span class=&quot;nobr&quot;&gt;этот-то&lt;/span&gt; раз&lt;/em&gt; я их напишу! Честно-честно! :)&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Дизайн, на первый взгляд, остался почти таким же. Но очень многое поменялось в мелочах и, особенно, в типографике. Я всё ещё использую шрифт &lt;a href=&quot;http://www.myfonts.com/fonts/letterheadrussia/21-cent/&quot;&gt;21 Cent&lt;/a&gt; от &lt;a href=&quot;http://www.letterhead.ru/&quot;&gt;Letterhead&lt;/a&gt;, но докупил ещё одно начертание для заголовков. Стал использовать больше фичей &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#overused&quot; id=&quot;overused&quot;&gt;опентайпа&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Возможно, &lt;span class=&quot;nobr&quot;&gt;где-то&lt;/span&gt; мог и переборщить, только ради демонстрации возможностей.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, добавил переносы слов и&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;какой кошмар!&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;стал выравнивать текст по ширине. Это даже не так страшно выглядит&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всё благодаря переносам и чуть увеличившейся ширине колонки текста. В рамках типографики я, в итоге, применяю очень много экспериментального и спорного. Наверняка &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; ещё поменяется, &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; добавится, а &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; не выдержит проверки временем.&lt;/p&gt;
&lt;h3 id=&quot;содержимое&quot;&gt;Содержимое&lt;/h3&gt;
&lt;p&gt;У меня есть очень много планов и идей о том, что должно появиться на этом сайте. Пока что тут все те же статьи, что были до этого, но я начал избавляться от совершенно ненужного разделения на категории вида «блог/заметки/эксперименты» (оно останется, скорее, как внутренняя систематизация, доступная для фильтрации), и добавил, наконец, один полный &lt;a href=&quot;/everything/&quot;&gt;список всего, что пока тут есть&lt;/a&gt;. Я планирую со временем пополнять его не только новыми текстами и экспериментами, но и разным старым контентом, который я, по &lt;span class=&quot;nobr&quot;&gt;каким-то&lt;/span&gt; причинам, до сих пор не выкладывал на сайт.&lt;/p&gt;
&lt;p&gt;Кроме регулярно (я надеюсь!) появляющегося контента, будет обновляться и базовая структура сайта. Скажем, может появиться стандартный раздел «обо мне», что-нибудь более похожее на резюме, а также какие-нибудь другие интересные страницы. Чтобы не быть голословным, вот пример: новая страница со &lt;a href=&quot;/talks/&quot;&gt;списком всех моих докладов&lt;/a&gt;. Хотя я в последнее время практически не выступаю на конференциях, надежды на то, что этот раздел будет пополняться всё же есть.&lt;/p&gt;
&lt;h2 id=&quot;добро-пожаловать-&quot;&gt;Добро пожаловать!&lt;/h2&gt;
&lt;p&gt;Спасибо, если дочитали этот пост до конца! Я планировал сделать просто короткую отписку о том, что вот она&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;новая версия сайта. Но сначала углубился в историю и &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#old-versions&quot; id=&quot;old-versions&quot;&gt;версионирование&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Возможно, когда-нибудь я расскажу обо всех старых версиях подробнее, когда буду готов.&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, потом в историю с переписыванием сначала на докпад, а позже&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на gulp; в общем, коротко не получилось, уж извините :)&lt;/p&gt;
&lt;p&gt;Как обычно, если вы найдёте &lt;span class=&quot;nobr&quot;&gt;какие-то&lt;/span&gt; ошибки в текстах или баги вёрстки&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;пишите либо &lt;a href=&quot;mailto:kizmarh@ya.ru&quot;&gt;на почту&lt;/a&gt;, либо в &lt;a href=&quot;https://github.com/kizu/kizu.github.com/issues&quot;&gt;ишьюс на Гитхабе&lt;/a&gt;, либо в &lt;a href=&quot;https://twitter.com/ki_zu&quot;&gt;твиттер&lt;/a&gt;, либо куда захотите. Буду рад и скажу спасибо. Если повнимательнее рассмотрите дизайн и типографику, и если у вас после этого возникнут по ним вопросы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;также задавайте! Хотя у меня и есть идеи о будущих постах, интерес к &lt;span class=&quot;nobr&quot;&gt;чему-то&lt;/span&gt; конкретному будет хорошим мотиватором к тому, чтобы сесть и написать именно об этом.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Вложенные ссылки</title>
    <link href="http://kizu.ru/fun/nested-links/"/>
    <updated>2015-02-10T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/nested-links</id>
    <content type="html">&lt;h1 id=&quot;вложенные-ссылки&quot;&gt;Вложенные ссылки&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/fun/nested-links/nested-links.jpg&quot; width=&quot;640&quot; height=&quot;480&quot; alt=&quot;Котики играют во вложенные ссылки&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;проблема&quot;&gt;Проблема&lt;/h2&gt;
&lt;p&gt;В спецификации &lt;abbr&gt;HTML&lt;/abbr&gt; есть множество разнообразных запретов. Обоснованность многих из них очень хочется оспорить. Один из примеров, с которым мне приходится сталкиваться чаще всего,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вложенные ссылки.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/html5/text-level-semantics.html#the-a-element&quot;&gt;Спецификация&lt;/a&gt; прямо запрещает вкладывать одну ссылку в другую:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;strong&gt;a&lt;/strong&gt; element&lt;/p&gt;
&lt;p&gt;[…]&lt;/p&gt;
&lt;p&gt;Content model: transparent, but there must be no &lt;a href=&quot;http://www.w3.org/TR/html5/dom.html#interactive-content-0&quot;&gt;interactive&lt;/a&gt; content descendant.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Если так сделать, то парсер браузера вас не поймёт и, как только встретит открывающий тег вложенной ссылки, закроет родительскую ссылку перед собой:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&amp;quot;#Foo&amp;quot;&amp;gt;
    Foo
    &amp;lt;a href=&amp;quot;#Bar&amp;quot;&amp;gt;
        Bar
    &amp;lt;/a&amp;gt;
    Baz
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;в глазах браузера станет &lt;span class=&quot;nobr&quot;&gt;чем-то&lt;/span&gt; таким —&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&amp;quot;#Foo&amp;quot;&amp;gt;
    Foo
    &amp;lt;/a&amp;gt;&amp;lt;a href=&amp;quot;#Bar&amp;quot;&amp;gt;
        Bar
    &amp;lt;/a&amp;gt;
    Baz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Живой пример:&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/nested-links/#Demo_nested-links-broken&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Однако, существуют сценарии, в которых захочется положить одну ссылку в другую, не обращая внимание на запреты.&lt;/p&gt;
&lt;p&gt;Вот и в очередной раз, в рамках рабочей задачи, я оказался в такой ситуации. Раньше я встречал и использовал множество вариантов того, как можно его обойти. Это и эмуляция внутренних ссылок на JS (например, через банальный &lt;code&gt;onclick&lt;/code&gt;), и позиционирование одной из ссылок вокруг родительского контейнера (см, например, &lt;a href=&quot;http://jsfiddle.net/csswizardry/rxsna/&quot;&gt;соответствующее решение&lt;/a&gt; Гарри Робертса), но все эти варианты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;явные костыли. Используя их, мы либо теряем всю нативность обычных ссылок, либо получаем ограниченное число сценариев, в которых такие обходные пути сработают.&lt;/p&gt;
&lt;p&gt;Перепробовав в голове все варианты, я понял, что для моей задачи может подойти только полная эмуляция на JS&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;средствами чистого &lt;abbr&gt;CSS&lt;/abbr&gt; достичь того, что мне требовалось, оказалось невозможно. Но все мы знаем, что эмулировать нативные элементы на JS&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;одно из самых неблагодарных дел. И я решил поэкспериментировать ещё.&lt;/p&gt;
&lt;p&gt;И&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;нашёл решение. При этом, чисто &lt;abbr&gt;HTML&lt;/abbr&gt;-решение, дающее возможность вкладывать любое количество нативных ссылок друг в друга.&lt;/p&gt;
&lt;h2 id=&quot;решение&quot;&gt;Решение&lt;/h2&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/nested-links/#Demo_nested-links-simple&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&amp;quot;#a&amp;quot;&amp;gt;
    Foo
    &amp;lt;object type=&amp;quot;lol/wut&amp;quot;&amp;gt;
        &amp;lt;a href=&amp;quot;#b&amp;quot;&amp;gt;
            Bar
        &amp;lt;/a&amp;gt;
    &amp;lt;/object&amp;gt;
    Baz
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё, что мы, в итоге, делаем&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;прокладываем между внутренней и внешней ссылкой объект. Внезапно, это работает: все парсеры современных браузеров перестают взрывать разметку и начинают воспринимать вложенность тегов так, как нам этого хочется. Ура.&lt;/p&gt;
&lt;h2 id=&quot;почему-это-работает&quot;&gt;Почему это работает&lt;/h2&gt;
&lt;p&gt;Что такое, в теории, объекты? Это некие внешние сущности, тип которых задаётся атрибутом &lt;code&gt;type&lt;/code&gt;, а содержимое/ссылка на объект задаётся атрибутом &lt;code&gt;data&lt;/code&gt;. Содержимое же между открывающим и закрывающим тегом &lt;code&gt;object&lt;/code&gt; на самом деле является фолбеком, и должно отображаться в том случае, если браузер не способен по какой-либо причине отобразить соответствующее содержимое. Например, если в браузере не установлен определённый плагин.&lt;/p&gt;
&lt;p&gt;Если прописать в атрибут &lt;code&gt;type&lt;/code&gt; неизвестный природе &lt;abbr&gt;MIME&lt;/abbr&gt;-тип, то браузер сразу же перейдёт к отображению фолбека. Но он &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#update&quot; id=&quot;update&quot;&gt;это сделает&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;На самом деле, см. &lt;a href=&quot;#update-from-2015-03-05&quot;&gt;дополнение к статье&lt;/a&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; и в том случае, если мы вообще не зададим ни один из «обязательных» атрибутов.&lt;/p&gt;
&lt;p&gt;Таким образом, обрамляя любой &lt;abbr&gt;HTML&lt;/abbr&gt; в такой безатрибутный &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;, мы получаем просто элемент-враппер с содержимым. Но враппер с очень необычным свойством: любое его содержимое будет верно распознано парсером вне зависимости от того, какой у объекта был контекст. Используя это свойство, мы можем, наконец, вложить ссылку в другую ссылку.&lt;/p&gt;
&lt;p&gt;Предполагаю, что такое поведение объектов обусловлено тем, что эти фолбеки используются чаще всего для того, чтобы показать ссылку вида «у вас не установлен наш замечательный плагин, скачайте же его!» для всяких объектов (например, флеш-роликов). При этом многие разработчики наверняка хотели использовать объект как обычный контент, то есть вкладывать его в ссылку, в параграф, в заголовок&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;да куда угодно. И тут браузерам пришлось перестраховаться и разрешить вкладывать в объект всё что угодно, чтобы при копипасте кода объекта откуда-либо и вставке его в содержимое страницы у авторов ничего не сломалось.&lt;/p&gt;
&lt;h2 id=&quot;поддержка-браузерами&quot;&gt;Поддержка браузерами&lt;/h2&gt;
&lt;p&gt;В некоторых браузерах такое поведение появилось не сразу.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Internet Explorer поддерживает вложенные объекты только с девятой версии.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Firefox&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;с четвёртой.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Opera&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;с как минимум девятой (может, и с более ранней&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я не стал углубляться ещё дальше).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Вебкиты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;все, что проверял, Сафари&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;точно с 5.1, Хром&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;с 14, дальше не пошёл.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Очевидно, что в большинстве случаев нам может потребоваться лишь поддержка старых IE, все остальные браузеры достаточно хорошо обновляются для того, чтобы те версии, в которых были проблемы с этим трюком, ушли из всех списков совместимости.&lt;/p&gt;
&lt;h3 id=&quot;фолбек-для-ie&quot;&gt;Фолбек для IE&lt;/h3&gt;
&lt;p&gt;К сожалению, я не знаю простого способа обойти эту проблему в старых IE. Как минимум, можно попробовать поправить ситуацию так, чтобы ничего не взрывалось&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;например, обернуть теги внутренней ссылки в условные комментарии:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;a href=&amp;quot;…&amp;quot;&amp;gt;
    текст основной ссылки…
    &amp;lt;object&amp;gt;
        &amp;lt;!--[if gte IE 9]&amp;gt;&amp;lt;!--&amp;gt;&amp;lt;a href=&amp;quot;…&amp;quot;&amp;gt;&amp;lt;!--&amp;lt;![endif]--&amp;gt;
            content of the nested link…
        &amp;lt;!--[if gte IE 9]&amp;gt;&amp;lt;!--&amp;gt;&amp;lt;/a&amp;gt;&amp;lt;!--&amp;lt;![endif]--&amp;gt;
    &amp;lt;/object&amp;gt;
&amp;lt;/a&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если подобная потеря функциональности вас устроит&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;отлично, &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#try-expressions&quot; id=&quot;try-expressions&quot;&gt;иначе&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Самые любопытные могут попробовать подумать: можно ли соорудить какой-нибудь фолбек, используя экспрешны?&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; же придётся использовать в условных комментариях иные фолбеки для этой проблемы.&lt;/p&gt;
&lt;h2 id=&quot;это-валидно-&quot;&gt;Это валидно?&lt;/h2&gt;
&lt;p&gt;Нет, ни разу. Это не валидно, потому что у объекта нет ни одного из требуемых спецификацией атрибутов. Можно было бы указать какой-либо &lt;a href=&quot;http://www.w3.org/TR/html5/infrastructure.html#valid-mime-type&quot;&gt;валидный mime-тип&lt;/a&gt; вроде &lt;code&gt;type=&amp;quot;lol/wut&amp;quot;&lt;/code&gt;, и сам по себе такой объект стал бы валидным, но, как только мы вложим в него ссылку, валидатор начнёт на эту вложенность ругаться.&lt;/p&gt;
&lt;p&gt;Очевидно, что валидатор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;давно не показатель чего-либо, кроме формального соответствия кода спецификациям. В данном случае само подобное использование ссылки внутри объекта внутри ссылки может быть совершенно оправданным (примеры типа «скачать плагин»), поэтому он не должен вызывать ошибку валидации.&lt;/p&gt;
&lt;p&gt;Более того, я не вижу ни одной причины, почему нельзя было бы разрешить вкладывать ссылки внутрь других ссылок по умолчанию. Нет ни-&lt;span class=&quot;nobr&quot;&gt;ка-ких&lt;/span&gt; причин для этого. Но существует очень много сценариев, в которых подобное поведение совершенно необходимо.&lt;/p&gt;
&lt;h2 id=&quot;примеры-использования&quot;&gt;Примеры использования&lt;/h2&gt;
&lt;p&gt;Сначала я хотел подробно описать все возможные сценарии, в которых можно и нужно использовать вложенные ссылки, с живыми примерами и всем таким. Но потом понял, что эти примеры никого не убедят: тем, кому нужна эта возможность, будет достаточно первого работающего примера выше, остальных ничего, кроме их собственного опыта, не убедит. А ещё это очень затратно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;верстать столько примеров. Так что я сухо перечислю их:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Выдержки из статей, когда в сниппете, содержащем первые несколько предложений, могут оказаться ссылки, которые не захочется вырезать при создании сниппета.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Сноски и вложенные термины, которые могут оказаться внутри ссылок.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Любой сложный интерфейс со вложенными сущностями, которые можно представить в виде ссылок. Это и твиты в любом интерфейсе твиттера, сами по себе ведущие на расширенную страницу твита, и при этом содержащие другие ссылки внутри: на пользователей и внешние страницы. Это и почтовые интерфейсы, где в сниппете письма, являющимся ссылкой на письмо, могут оказаться другие ссылки&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на тред, на вложения, на метки и т.д.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;-&quot;&gt;&lt;em&gt; &lt;/em&gt; *&lt;/h2&gt;
&lt;p&gt;В завершение стоит сказать, что этот трюк можно провернуть с любым содержимым страницы, которое хочется использовать там, где спецификация явно запрещает это делать.&lt;/p&gt;
&lt;p&gt;Например, не так давно появилась возможность использовать элементы &lt;code&gt;details&lt;/code&gt; и &lt;code&gt;figure&lt;/code&gt;. Но, только подумайте: по спецификации они могут находиться только в блочном контексте. У вас не может быть иллюстрации с подписью, привязанной к определённому слову в абзаце, а также не может быть расширенного описания какого-либо слова или предложения (скажем, для сносок; какие бы вы выбрали теги для сносок внутри абзацев?)&lt;/p&gt;
&lt;p&gt;Трюк с &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt; решает все эти проблемы. Вопрос только в том, будет ли его использование оправданным. Лично я считаю, что многие запреты в спецификациях бессмысленны, и возможность обойти их при разумной аргументации бесценна.&lt;/p&gt;
&lt;h2 id=&quot;update-from-2015-03-05&quot;&gt;Update from 2015-03-05&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/VovanR&quot;&gt;Владимир Родкин&lt;/a&gt; &lt;a href=&quot;https://github.com/kizu/kizu.github.com/issues/178&quot;&gt;обнаружил&lt;/a&gt;, что плагин Flashblock для Firefox убирает со страниц «сломанные объекты», и он считает таковыми безатрибутные &lt;code&gt;&amp;lt;object&amp;gt;&lt;/code&gt;. Добавление неизвестного природе mime-типа вроде &lt;code&gt;type=&amp;quot;lol/wut&amp;quot;&lt;/code&gt; решает эту проблему и ФФ начинает правильно воспринимать объект.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Будьте глобальными</title>
    <link href="http://kizu.ru/blog/be-global/"/>
    <updated>2014-04-08T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/be-global</id>
    <content type="html">&lt;h1 id=&quot;будьте-глобальными&quot;&gt;Будьте глобальными&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/be-global/be-global.jpg&quot; width=&quot;756&quot; height=&quot;423&quot; alt=&quot;Котики мыслят глобально&quot;&gt;&lt;/p&gt;
&lt;p&gt;Я часто вижу отличные статьи и эксперименты на русском, и мне досадно, что я не могу поделиться ими с международным сообществом.&lt;/p&gt;
&lt;p&gt;Я считаю, что русскоязычным фронтендерам нужно писать больше на английском: у нас достаточно сильных и талантливых людей, чьи знания достойны более широкого внимания.&lt;/p&gt;
&lt;p&gt;Не стоит ограничивать себя рамками одного русского языка, нужно начать, наконец, экспортировать наши знания наружу, давать понять, что и мы &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; значим на мировом уровне.&lt;/p&gt;
&lt;p&gt;Конечно же, я не призываю отказаться от русского языка. Начинающим разработчикам проще читать переводные статьи и русскоязычные оригиналы. Но нужно стремиться набираться всё больше и больше опыта, а для этого нам нужно учиться читать и писать не только на русском.&lt;/p&gt;
&lt;h2 id=&quot;what-to-write&quot;&gt;О чём писать&lt;/h2&gt;
&lt;p&gt;Международное сообщество очень тесное. В него довольно просто влиться: достаточно просто начать делиться своими знаниями или &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; делать. Не стоит думать, что «все всё уже знают»: в сообщество приходят новые люди, постоянно появляются новые технологии, о которых можно написать, всегда можно начать исследовать &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; вглубь, или подробно описывать то, что вы узнаёте за день. В конце концов, можно работать «фильтром» и, читая статьи, делиться ссылками на наиболее понравившиеся, снабжая их небольшими своими комментариями&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это довольно хороший формат для начала.&lt;/p&gt;
&lt;p&gt;А потом можно и отдавать оригинальный контент. Очень многие зарубежные разработчики стали известными просто потому, что они делились тем, что делали для себя, своими экспериментами. И делали это на английском языке.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/thebabydino&quot;&gt;Ана Тюдор&lt;/a&gt; из Румынии, &lt;a href=&quot;https://twitter.com/mathias&quot;&gt;Мэтиас Байненс&lt;/a&gt; из Бельгии, &lt;a href=&quot;https://twitter.com/leaverou&quot;&gt;Лия Веру&lt;/a&gt; из Греции, &lt;a href=&quot;https://twitter.com/SaraSoueidan&quot;&gt;Сара Суэйдан&lt;/a&gt; из Ливана, &lt;a href=&quot;https://twitter.com/HugoGiraudel&quot;&gt;Гюго Жиродель&lt;/a&gt; из Франции, и многие другие фронтендеры&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;все они стали известны и смогли внести свой вклад в общее дело только благодаря тому, что писали и продолжают писать на английском.&lt;/p&gt;
&lt;h2 id=&quot;where-to-start&quot;&gt;С чего начать&lt;/h2&gt;
&lt;p&gt;Если у вас уже возникло желание представить себя международному сообществу, я могу предложить примерно такие шаги:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Заведите второй аккаунт в твиттере для твитов только на английском: так и вам будет проще общаться с международным сообществом, и международному сообществу будет проще на вас подписаться (мало кто хочет проматывать в своей ленте твиты на непонятных языках, что происходит в случае с одним аккаунтом для всего).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Перенесите всех, кого вы уже читаете на английском, из русскоязычного аккаунта в англоязычный. Так вы разделите свою ленту на две, и вам проще будет сконцентрироваться на английском языке. Кроме того, вам будет проще отвечать на английском разным зарубежным авторам, которые, в свою очередь, с большей вероятностью обратят на вас внимание в случае, если ваш твиттер будет на английском и будет содержать только англоязычные дискуссии.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Начинайте писать оригинальный контент на английском, делиться ссылками, снабжая их англоязычными комментариями, дублировать свои русскоязычные твиты, переводя самые интересные.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Если у вас уже есть &lt;span class=&quot;nobr&quot;&gt;какие-то&lt;/span&gt; опенсорсные проекты, статьи на русском языке, эксперименты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;можете начать переводить их на английский и делиться ими с международным сообществом. Только не стоит вываливать всё сразу&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;так вы сможете первое время держать аккаунт довольно активным, а потом, наверняка, привыкните, и сможете писать новый контент сразу на английском.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Поменяйте ссылку на твиттер во всех международных социальных сетях и ресурсах на ваш англоязычный аккаунт (на Гитхабе, Стековерфлоу и т.д.)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это даст возможность связаться с вами тем, кому интересна ваша деятельность на этих ресурсах.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Участвуйте в опросах на английском, в различных опенсорсных проектах, форкайте и улучшайте чужие эксперименты, в общем, ведите активную социальную жизнь фронтендера, не стоит ограничиваться только чтением, наверняка вы можете &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; показать миру!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;do-not-be-afraid&quot;&gt;Не стоит бояться&lt;/h2&gt;
&lt;p&gt;Не стоит бояться своего плохого английского&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;никто не будет ожидать от вас иного. Достаточно выражаться так, чтобы вас хоть немного понимали, ведь за вас больше скажет ваш код и те решения, что вы предлагаете. И, конечно, всегда можно подсматривать неизвестные слова в словарях, а также просить кого-нибудь, кто хорошо знает английский, проверять ваши тексты перед отправкой.&lt;/p&gt;
&lt;p&gt;Вообще, международное сообщество очень приветливое: если вы будете вежливы и не будете занудно троллить, то вас легко примут в свой круг, будут помогать, отвечать, вычитывать ваши посты, а потом поздороваются, когда встретят вас на зарубежной конференции.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;&lt;em&gt; &lt;/em&gt; *&lt;/h2&gt;
&lt;p&gt;В завершение: я создал в твиттере &lt;a href=&quot;https://twitter.com/ki_zu/lists/runglish-webdev&quot;&gt;список&lt;/a&gt; со всеми англоязычными аккаунтами русскоязычных фронтендеров, которые я смог вспомнить. Если вы хотите завести новый аккаунт&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;посмотрите как это делают уже многие фронтендеры и возьмите с них пример.&lt;/p&gt;
&lt;p&gt;Не так давно я поделился этим списком в твиттере и призвал завести англоязычные аккаунты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;с того момента это сделали уже &lt;a href=&quot;https://twitter.com/yoksel_en&quot;&gt;Юля Бухвалова&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/mistadikay_en&quot;&gt;Денис Кольцов&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/pepelsbey_&quot;&gt;Вадим Макеев&lt;/a&gt;, &lt;a href=&quot;https://twitter.com/artpolikarpoff&quot;&gt;Артём Поликарпов&lt;/a&gt; и &lt;a href=&quot;https://twitter.com/andreysitnik&quot;&gt;Андрей Ситник&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Присоединяйтесь и вы, давайте уже откроем двери в мир, хватит сидеть взаперти!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Битва за базовую линию</title>
    <link href="http://kizu.ru/blog/flex-baseline/"/>
    <updated>2014-02-10T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/flex-baseline</id>
    <content type="html">&lt;h1 id=&quot;битва-за-базовую-линию&quot;&gt;Битва за базовую линию&lt;/h1&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/flex-baseline.jpg&quot; width=&quot;756&quot; height=&quot;478&quot; alt=&quot;Котики&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;Когда-то&lt;/span&gt; наилучшим решением для инлайновых блоков были, ну, инлайн-блоки. Мне они очень нравятся за то, что с их помощью можно решить множество задач. Но и они не всемогущи. Они не умеют правильно работать с вертикальным выравниванием текста по базовой линии шрифта. Причём проблема следует уже из &lt;a href=&quot;http://www.w3.org/TR/CSS2/visudet.html#propdef-vertical-align&quot;&gt;спецификации&lt;/a&gt; (см. последний абзац):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Для многострочных инлайн-блоков &lt;em&gt;базовой линией&lt;/em&gt; является базовая линия &lt;strong&gt;последнего&lt;/strong&gt; строчного бокса в обычном потоке.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Если внутри инлайн-блока нет боксов обычного потока, или же у инлайн-блока стоит &lt;code&gt;overflow&lt;/code&gt; отличный от &lt;code&gt;visible&lt;/code&gt;, то &lt;em&gt;базовой линией&lt;/em&gt; становится нижняя граница блока.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;Из-за&lt;/span&gt; этих проблем получится выровнять по базовой линии только однострочные блоки без заданного &lt;code&gt;overflow&lt;/code&gt;, тогда как в любых более сложных случаях получится совсем не то, что может быть нужно.&lt;/p&gt;
&lt;p&gt;Вот пример: все три блока имеют &lt;code&gt;display: inline-block&lt;/code&gt;. Первый&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;обычный однострочный и с большим паддингом, второй&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;многострочный, но с меньшим размером шрифта, третий&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;однострочный, но с &lt;code&gt;overflow: auto&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline1.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline1&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;На этом примере &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#safari&quot; id=&quot;safari&quot;&gt;хорошо видно&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Кстати, в последних Сафари, внезапно, блок с overflow ведёт себя не по спецификации&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, где у какого блока находится базовая линия.&lt;/p&gt;
&lt;h2 id=&quot;inline-table&quot;&gt;inline-table&lt;/h2&gt;
&lt;p&gt;В &lt;abbr&gt;CSS&lt;/abbr&gt; было одно место, где вертикальное выравнивание работало &lt;em&gt;правильно&lt;/em&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;display: inline-table&lt;/code&gt;. Заменяем инлайн-блоки на него и получаем, казалось бы, то, что нужно:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline2.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline2&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Но тут сразу видно: не работает overflow: auto. К тому же такому блоку нужно задавать &lt;code&gt;table-layout: fixed&lt;/code&gt;. Получается идеально, если не нужен &lt;code&gt;overflow: auto&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;trying-flex&quot;&gt;Пробуем флексбоксы&lt;/h2&gt;
&lt;p&gt;Можно ли сделать блок со скроллбаром, который будет правильно выравниваться? Тут на помощь спешат флексбоксы, точнее, &lt;code&gt;display: inline-flex&lt;/code&gt;. В &lt;a href=&quot;http://www.w3.org/TR/css3-flexbox/#flex-baselines&quot;&gt;теории&lt;/a&gt; они также имеют правильное положение базовой линии, но что мы получаем на практике?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline3.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline3&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Если вы посмотрите на этот пример в любом браузере кроме Firefox (да, даже в IE 10 и 12-й Опере), то вы видите идельно выровненные блоки.&lt;/p&gt;
&lt;p&gt;Но в Fx блок с &lt;code&gt;overflow: auto&lt;/code&gt;, внезапно, работает аналогично инлайн-блоку: теряет базовую линию. Грусть, печаль, разочарование, ждём исправления &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=969874&quot;&gt;свежезарепорченного бага&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;another-way&quot;&gt;А если иначе?&lt;/h2&gt;
&lt;p&gt;Очень здорово, что &lt;code&gt;inline-flex&lt;/code&gt; сам по себе правильно выравнивается относительно остальных блоков, и, если бы не баг Fx, всё было бы совсем замечательно. Но что если мы попробуем выравнивать не разные &lt;code&gt;inline-flex&lt;/code&gt; относительно друг друга, а элементы внутри флексбокса?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline4.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline4&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Оп! Всё работает! Вот только… Если отдельные блоки с &lt;code&gt;inline-flex&lt;/code&gt; сами по себе переносятся на новую строку, то для элементов внутри флексбокса нам надо было бы применять &lt;code&gt;flex-wrap&lt;/code&gt;. Но Firefox его не поддерживал до версии 28.0.&lt;/p&gt;
&lt;h2 id=&quot;combined&quot;&gt;Всё вместе&lt;/h2&gt;
&lt;p&gt;Так! Но ведь если &lt;code&gt;inline-flex&lt;/code&gt; прокидывает свою базовую линию наверх, а внутренний блок с &lt;code&gt;overflow: auto&lt;/code&gt; также имеет правильное выравнивание даже в Firefox, то можно же совместить! Добавим в каждый блок по дополнительному элементу, да будем задавать паддинги и overflow уже на них:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline5.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline5&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;В нормальных браузерах ничего не поменялось, теперь посмотрим на Firefox… Так, блок уже выравнивается не по нижней границе, но и не по базовой линии. Хотя, измерим разницу: 10 пикселей. Это же наш паддинг! Убираем паддинги по очереди&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всё выравнивается правильно, когда верхний паддинг становится равен нулю. Ага, значит Fx в этом случае всё делает почти верно, вот только всплыл новый баг. Пока мы ждём &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=969880&quot;&gt;его исправления&lt;/a&gt;, &lt;span class=&quot;nobr&quot;&gt;избавимся-ка&lt;/span&gt; от паддинга, заменив его на псевдо-элемент:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline6.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline6&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Идеально!&lt;/p&gt;
&lt;h2 id=&quot;finishing-strokes&quot;&gt;Последние штрихи&lt;/h2&gt;
&lt;p&gt;Ну ладно, не идеально. Остаётся пара мелочей, которые могут проявиться в десятом IE и в двенадцатой Опере.&lt;/p&gt;
&lt;p&gt;В IE при заданной ширине флексбокса текст внутри него не будет врапаться, даже если не будет стоять &lt;code&gt;white-space: nowrap&lt;/code&gt;. Довольно странный баг, обходится либо добавлением внутреннему блоку явной ширины в 100%, либо, что правильнее, &lt;code&gt;-ms-flex-negative: 1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;В Опере очень похожий баг&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;внутренний блок не реагирует на заданную ширину, &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; чего в блоке нет переносов. Единственный способ это исправить, который я нашёл: добавить родителю &lt;code&gt;flex-direction: column&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;так как у нас всегда только один внутренний элемент, это ни на что не повлияет.&lt;/p&gt;
&lt;p&gt;Теперь &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#without-fallbacks&quot; id=&quot;without-fallbacks&quot;&gt;идеально&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Разве что можно ещё добавить фолбеки для старых браузеров, но это уже выходит за рамки этой статьи&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;. Вот последний пример с разными вариантами, которые переносятся со строчки на строчку:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/blog/flex-baseline/examples/flex-baseline7.png&quot; alt=&quot;Screenshot&quot; title=&quot;Screenshot&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;small&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/blog/flex-baseline/#Demo_flex-baseline7&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Код получается таким:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.flex {
    display: -ms-inline-flexbox;
    display: -webkit-inline-flex;
    display: inline-flex;

    /* Fixing Opera issue */
    flex-direction: column;

    vertical-align: baseline;
    }

.flex-content {
    padding: 0 10px 10px;
    border: 1px solid lime;

    /* Fixing IE issue */
    -ms-flex-negative: 1;
    }

/* Fixing Fx issue */
.flex-content:before {
    content: &amp;quot;&amp;quot;;
    display: block;
    padding-top: 10px;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;resume&quot;&gt;Итого&lt;/h2&gt;
&lt;p&gt;Ох уж этот Firefox! Если бы не его баги (и один баг десятого IE), то мы могли бы обойтись одним элементом для каждого инлайнового блока, который мы хотим выровнять по базовой линии. А если вам не нужен &lt;code&gt;overflow&lt;/code&gt; отличный от &lt;code&gt;visible&lt;/code&gt;, и вы не боитесь таблиц, то можно попробовать использовать &lt;code&gt;display: inline-table&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Так, или иначе, мы победили. Теперь можно выравнивать блоки по их базовым линиям вне зависимости от их сложности, ура! Если вы хотите применять эту технику без лишних блоков, настоятельно советую пойти и проголосовать за исправление &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=969874&quot;&gt;соответствующих&lt;/a&gt; &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=969880&quot;&gt;багов&lt;/a&gt; в багзилле.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Новые фичи в Стайлусе</title>
    <link href="http://kizu.ru/issues/new-stylus-features/"/>
    <updated>2013-12-05T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/new-stylus-features</id>
    <content type="html">&lt;h1 id=&quot;новые-фичи-в-стайлусе&quot;&gt;Новые фичи в Стайлусе&lt;/h1&gt;
&lt;p&gt;Полгода назад я &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#maintaining&quot; id=&quot;maintaining&quot;&gt;стал мейнтейнером&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;О том, как это произошло и чем именно я там занимаюсь, я напишу как-нибудь в другой раз, тут стоит заметить только то, что я являюсь именно &lt;em&gt;мейнтейнером&lt;/em&gt;, а основным &lt;em&gt;разработчиком&lt;/em&gt; сейчас является мой коллега &lt;a href=&quot;@panyakor&quot;&gt;Миша Корепанов&lt;/a&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; &lt;a href=&quot;https://github.com/LearnBoost/stylus&quot;&gt;Стайлуса&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;отличного препроцессора для &lt;abbr&gt;CSS&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;На прошлой неделе мы зарелизили новую версию&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;https://github.com/LearnBoost/stylus/blob/master/History.md#0410--2013-11-30&quot;&gt;0.41.0&lt;/a&gt;, в которой добавили пару важных фич. А в двух релизах до этого мы добавили поддержку хешей и отполировали её, в результате этих трёх последних релизов теперь можно делать много всего интересного. В этой заметке я опишу &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#example-sidenote&quot; id=&quot;example-sidenote&quot;&gt;один подход&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Можете сразу промотать до &lt;a href=&quot;#example&quot;&gt;его пошагового описания&lt;/a&gt;, либо до &lt;a href=&quot;#result&quot;&gt;результирующего кода&lt;/a&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, который теперь можно применять в Стайлусе, но для начала я напишу немного про новые фичи.&lt;/p&gt;
&lt;h2 id=&quot;block-mixins&quot;&gt;Блочные миксины&lt;/h2&gt;
&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;Наконец-то&lt;/span&gt;! То, чего так давно не хватало в Стайлусе (и что уже давно есть в Sass)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;возможность передавать в миксин блок кода.&lt;/p&gt;
&lt;p&gt;Синтаксис передачи блока довольно простой: вызываем миксин, используя префикс «+», после чего передаём соответствующий блок либо в фигурных скобках, либо через блок с новым отступом (как всё обычно делается в Стайлусе):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;+foo()
  // Блок, который мы хотим передать
  width: 10px
  height: 10px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После того как мы передали блок в миксин, этот блок стал доступен внутри миксина как именованный аргумент&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;block&lt;/code&gt;. После чего &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#pass&quot; id=&quot;pass&quot;&gt;его можно вывести&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Также мы можем передать эту переменную в другой миксин, или воспользоваться ей &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; иначе, пример в конце статьи завязан именно на этом&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; через &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#block-call&quot; id=&quot;block-call&quot;&gt;интерполяцию&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;В будущем, возможно, добавится возможность использовать его без интерполяции&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;foo()
  width: 20px
  .foo
    {block}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Если вызвать этот миксин, например, так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;.bar
  +foo()
    padding: 0
    .baz
      height: 20px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы получим следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.bar {
  width: 20px;
}
.bar .foo {
  padding: 0;
}
.bar .foo .baz {
  height: 20px;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы получили возможность обрамлять блоки с помощью миксинов во что угодно (а в будущем, возможно, добавим и возможность &lt;em&gt;изменять&lt;/em&gt; переданные блоки). Обычно это используют для работы с медиакверями,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;мой пример, который будет ниже в статье, как раз из той же области.&lt;/p&gt;
&lt;h2 id=&quot;hashes&quot;&gt;Хеши&lt;/h2&gt;
&lt;p&gt;Хеши&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;объекты вида «свойство-значение». Выглядят они довольно просто:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;foo = {
  bar: 10px,
  raz: #fff,
  baz: {
    blah: blah
    &amp;#39;10%&amp;#39;: yeah
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как видно из примера, синтаксис похож на обычные яваскриптовые объекты: ключом может быть или идентификатор, или строка, а значением может быть почти что угодно, в том числе и вложенный хеш. Из важного: в отличие от обычных блоков Стайлуса, фигурные скобки для хешей обязательны, но вот запятые&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#codestyle&quot; id=&quot;codestyle&quot;&gt;нет&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Как и остальные опциональные фичи синтаксиса, если не придерживаться &lt;span class=&quot;nobr&quot;&gt;какого-то&lt;/span&gt; конкретного код-стайла, то код будет нечитабельным, так что решите как вы будете писать хеши и блоки, и придерживайтесь этого решения&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;После того, как вы объявили хеш, можно в него добавить новые свойства или перезаписать старые либо через точку, либо через квадратные скобки:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;foo.bar = 20px
foo[&amp;#39;whatever&amp;#39;] = &amp;#39;hello&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отличия довольно простые: через точку можно писать только идентификаторы, тогда как в квадратных скобках можно использовать любые строки, либо передавать переменные. В общем, с квадратными скобками получается более гибко, а через точку&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;короче.&lt;/p&gt;
&lt;p&gt;Получать свойства можно аналогично&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;либо через точку, либо через квадратные скобки.&lt;/p&gt;
&lt;p&gt;Не буду описывать остальные возможности хешей&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;их &lt;a href=&quot;http://learnboost.github.io/stylus/docs/hashes.html&quot;&gt;довольно много&lt;/a&gt;, отмечу, что с ними нормально работает встроенная функция Стайлуса &lt;code&gt;length()&lt;/code&gt;, по ним можно итерироваться, можно проверять наличие ключей в условиях (&lt;code&gt;if baz in foo&lt;/code&gt;), а также есть несколько встроенных функций для работы с хешами (&lt;code&gt;keys()&lt;/code&gt;, &lt;code&gt;values()&lt;/code&gt;, &lt;code&gt;merge()&lt;/code&gt;) и интерполяция хешей в &lt;abbr&gt;CSS&lt;/abbr&gt;-код.&lt;/p&gt;
&lt;h2 id=&quot;selector&quot;&gt;Функция &lt;code&gt;selector()&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;В новом Стайлусе появилась небольшая, но важная фича&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;функция &lt;code&gt;selector()&lt;/code&gt;. До неё в Стайлусе не было возможности &lt;strong&gt;получить&lt;/strong&gt; текущий селектор: его можно было составлять из вложенных блоков, интерполировать в него, но узнать какой же в итоге получается селектор было нельзя.&lt;/p&gt;
&lt;p&gt;Теперь же есть функция &lt;code&gt;selector()&lt;/code&gt;, которая возвращает текущий скомпилированный селектор. Его можно использовать либо для различных проверок, либо для каких-либо иных целей. Уже сейчас эта функция будет очень полезна в разных ситуациях, а в будущих релизах она станет ещё мощнее.&lt;/p&gt;
&lt;p&gt;В качестве примера я приведу вот такой небольшой кусок кода:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;if match(&amp;#39;:(before|after)&amp;#39;, selector())
  content: &amp;#39;&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Здесь мы проверяем есть ли в селекторе указание на псевдоэлемент, и если так&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;выводим &lt;code&gt;content&lt;/code&gt;. Это может пригодиться, если у вас есть миксин, целиком отвечающий за &lt;span class=&quot;nobr&quot;&gt;какое-то&lt;/span&gt; поведение, и который можно применить как к обычному элементу, так и к псевдо-элементу.&lt;/p&gt;
&lt;h2 id=&quot;example&quot;&gt;Пример с кешируемыми медиакверями&lt;/h2&gt;
&lt;p&gt;В качестве примера использования новых фич я приведу решение одной из проблем модного нынче отзывчивого дизайна: огромного количества переопределений, которые нужно расставлять для разных вьюпортов. Проблема заключается в том, что синтаксис вызова медиакверей довольно развесистый, поэтому приходится либо не обращать на это внимание и использовать &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#bubbling&quot; id=&quot;bubbling&quot;&gt;«всплытие медиакверей»&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;В препроцессорах, если использовать медиаквери внутри других блоков, они всплывают наверх, сохраняя текущий селектор&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, либо, в погоне за оптимизацией, писать все переопределения рядом, что во многих ситуациях будет менее удобно.&lt;/p&gt;
&lt;p&gt;Однако, с блочными миксинами, хешами и функцией &lt;code&gt;selector()&lt;/code&gt; в Стайлусе теперь можно обойти эти проблемы (и попутно решить ещё пару других).&lt;/p&gt;
&lt;p&gt;Если кратко описать решение: мы создадим миксин, заменяющий вызовы медиакверей и кеширующий их, объединяя по условиям, после чего даём возможность вывести весь закешированный таким образом код.&lt;/p&gt;
&lt;p&gt;Единственным недостатком такого подхода будет то, что если несколько условий медиакверей будут пересекаться, то, &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; группировки всех правил по объединённым медиакверям, порядок применения этих правил может поменяться.&lt;/p&gt;
&lt;p&gt;Для начала нам понадобится объект, в который мы будем сохранять вызванный в будущем код:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;$media_cache = {}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;После этого нам будет нужен миксин, который мы и будем использовать вместо медиакверей, в первом приближении он будет выглядеть &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;media($condition)
  unless $media_cache[$condition]
    $media_cache[$condition] = ()
  push($media_cache[$condition], block)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Миксин довольно простой: если у нас ещё нет в кеше списка по переданному в миксин ключу, мы инициируем этот список, после чего пушим в него переданный в миксин блок&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это будет наш кеш.&lt;/p&gt;
&lt;p&gt;На самом деле нам этого не будет достаточно: такой миксин можно будет использовать только вот так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;+media(&amp;#39;(max-width:640px)&amp;#39;)
  .foo
    display: block;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Мы сможем прокидывать внутрь только полноценные блоки, у нас не получится использовать всплытие:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;.foo
  +media(&amp;#39;(max-width:640px)&amp;#39;)
    display: block;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; того, что миксин пока ничего не знает о своём контексте&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;он знает только о блоке, который в него передали. &lt;span class=&quot;nobr&quot;&gt;Тут-то&lt;/span&gt; нам и поможет функция &lt;code&gt;selector()&lt;/code&gt;, да ещё один миксин-помощник&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вместе с ними наш миксин будет выглядеть так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;media($condition)
  helper($condition)
    unless $media_cache[$condition]
      $media_cache[$condition] = ()
    push($media_cache[$condition], block)

  +helper($condition)
    {selector()}
      {block}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для того, чтобы сохранять контекст, мы выносим изначальный код, помещающий переданный блок в кеш, в миксин &lt;code&gt;helper&lt;/code&gt;, который тут же и вызываем, обрамляя переданный блок в текущий селектор.&lt;/p&gt;
&lt;p&gt;Так как теперь при вызове нашего миксина всё будет помещаться в кеш, оно не будет выводиться само по себе. Значит, нам нужна функция, которая возьмёт содержимое кеша и выплеснет его там, где мы эту функцию применим (логично будет вызывать её в конце файла):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;apply_media_cache()
  for $media, $blocks in $media_cache
    @media $media
      for $block in $blocks
        {$block}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Всё довольно просто: сначала итерируемся по кешу, получая по очереди условия (&lt;code&gt;$media&lt;/code&gt;) и список вызванных с таким условием блоков (&lt;code&gt;$blocks&lt;/code&gt;), после чего создаём соответствующую медиаквери, внутри которой уже итерируемся по всем блокам, выводя их один за другим.&lt;/p&gt;
&lt;p&gt;Теперь, если мы в конце документа вызовем эту функцию:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;apply_media_cache()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;мы получим то, ради чего всё затевали.&lt;/p&gt;
&lt;p&gt;Однако, и эту функцию можно улучшить: ведь мы не хотим каждый раз писать при вызове скобочки, да и, на самом деле, хорошо бы всегда иметь в условиях &lt;code&gt;only screen and&lt;/code&gt;. Кроме того, мы и вовсе можем захотеть использовать вместо конкретных значений ключевые слова, типа &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#keywords&quot; id=&quot;keywords&quot;&gt;&lt;code&gt;palm&lt;/code&gt;, &lt;code&gt;portable&lt;/code&gt;, &lt;code&gt;desk&lt;/code&gt;&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Для примера я выбрал градации из фреймворка &lt;a href=&quot;@csswizardry&quot;&gt;Гарри Робертса&lt;/a&gt; &lt;a href=&quot;http://inuitcss.com/&quot;&gt;inuit.css&lt;/a&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt; и т.п. Вместе с дополнениями и всеми предыдущими шагами мы получаем вот такой код:&lt;/p&gt;
&lt;h3 id=&quot;result&quot;&gt;Итоговый код&lt;/h3&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;// Определяем объект кеша и объект с алиасами
$media_cache = {}
$media_aliases = {
  palm:       &amp;#39;(max-width: 480px)&amp;#39;
  lap:        &amp;#39;(min-width: 481px) and (max-width: 1023px)&amp;#39;
  lap-and-up: &amp;#39;(min-width: 481px)&amp;#39;
  portable:   &amp;#39;(max-width: 1023px)&amp;#39;
  desk:       &amp;#39;(min-width: 1024px)&amp;#39;
  desk-wide:  &amp;#39;(min-width: 1200px)&amp;#39;
}

// Миксин, кеширующий медиаквери
media($condition)
  helper($condition)
    unless $media_cache[$condition]
      $media_cache[$condition] = ()
    push($media_cache[$condition], block)

  +helper($condition)
    {selector() + &amp;#39;&amp;#39;}
      {block}

// Функция, вызывающая закешированные медиаквери
apply_media_cache()
  for $media, $blocks in $media_cache
    $media = unquote($media_aliases[$media] || $media)
    $media = &amp;#39;(%s)&amp;#39; % $media unless match(&amp;#39;\(&amp;#39;, $media)
    $media = &amp;#39;only screen and %s&amp;#39; % $media
    @media $media
      for $block in $blocks
        {$block}

// Здесь будет основной код с вызовами миксина
// …

// Вызываем все закешированные медиаквери
apply_media_cache()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Теперь мы можем писать код примерно так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-styl&quot;&gt;.foo
  width: 10px

  +media(&amp;#39;lap&amp;#39;)
    width: 20px

  +media(&amp;#39;desk&amp;#39;)
    width: 30px

  +media(&amp;#39;min-width: 200px&amp;#39;)
    width: 60px

.bar
  height: 10px

  +media(&amp;#39;lap&amp;#39;)
    height: 20px

  +media(&amp;#39;desk&amp;#39;)
    height: 30px

  +media(&amp;#39;min-width: 200px&amp;#39;)
    height: 50px

  +media(&amp;#39;(min-width: 500px) and (max-width: 700px)&amp;#39;)
    height: 50px
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;И в результате получим следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.foo {
  width: 10px;
}
.bar {
  height: 10px;
}
@media only screen and (min-width: 481px) and (max-width: 1023px) {
  .foo {
    width: 20px;
  }
  .bar {
    height: 20px;
  }
}
@media only screen and (min-width: 1024px) {
  .foo {
    width: 30px;
  }
  .bar {
    height: 30px;
  }
}
@media only screen and (min-width: 200px) {
  .foo {
    width: 60px;
  }
  .bar {
    height: 50px;
  }
}
@media only screen and (min-width: 500px) and (max-width: 700px) {
  .bar {
    height: 50px;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В последнем варианте функции &lt;code&gt;apply_media_cache&lt;/code&gt; можно увидеть, что мы добавили объект с алиасами. Кроме того, мы теперь можем вызывать миксин как в сокращённом варианте, без скобок, так и со скобками&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;все варианты будут работать.&lt;/p&gt;
&lt;p&gt;В итоге, благодаря новым возможностям, появившимся в последних версиях Стайлуса, мы получили возможность быстро и удобно использовать всплывающие медиаквери в коде, с алиасами на ключевые слова и с группировкой результирующего кода по медиакверям.&lt;/p&gt;
&lt;p&gt;Наверняка этот код не идеален, его можно улучшать и улучшать, но моей целью было показать новые фичи, а получившияся функция&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;лишь результат.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>iOS 7</title>
    <link href="http://kizu.ru/blog/ios7/"/>
    <updated>2013-09-19T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/ios7</id>
    <content type="html">&lt;h1 id=&quot;ios-7&quot;&gt;iOS 7&lt;/h1&gt;
&lt;p&gt;Вышла седьмая версия iOS. Обновление очень большое, почти всё переделано, в итоге многое стало сильно лучше, а многое&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сильно хуже.&lt;/p&gt;
&lt;p&gt;В этой заметке я попробую перечислить те изменения, что я заметил и посчитал интересными. В основном я буду касаться самой iOS и нативных приложений (за исключением &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#safari&quot; id=&quot;safari&quot;&gt;Сафари&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Про Сафари появилась отличная &lt;a href=&quot;http://www.mobilexweb.com/blog/safari-ios7-html5-problems-apis-review&quot;&gt;статья&lt;/a&gt;, описывающая все изменения. В целом&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всё плохо&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;). Порядок произвольный, если увижу ещё &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; достойное упоминания, пост будет обновлён.&lt;/p&gt;
&lt;h2 id=&quot;иконки-приложений&quot;&gt;Иконки приложений&lt;/h2&gt;
&lt;p&gt;Иконки приложений теперь скругляются сильнее и более &lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#border-radius&quot; id=&quot;border-radius&quot;&gt;&lt;em&gt;правильно&lt;/em&gt;&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;См., например, &lt;a href=&quot;http://ilyabirman.ru/meanwhile/all/metro-line-curves/&quot;&gt;статью про изгибы линий&lt;/a&gt; Ильи Бирмана, или &lt;a href=&quot;http://blog.mikeswanson.com/post/61651302736/photoshop-script-for-ios-7-rounded-rectangles&quot;&gt;заметку про скрипт для Фотошопа&lt;/a&gt;, умеющий делать подобные скругления от Майка Свонсона&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;. Это значит, что многие иконки, в графике которых делался упор на соответствие старым радиусам скругления, стали выглядеть сильно хуже&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если большинство обычных «не плоских» иконок выглядят терпимо, то различные заигрывания с формой, особенно когда у иконки есть видимая граница шириной в несколько пикселей, сразу теряют весь шарм.&lt;/p&gt;
&lt;h2 id=&quot;заметки&quot;&gt;Заметки&lt;/h2&gt;
&lt;p&gt;Новые стандартные заметки мне не понравились. Хорошего: сделали нормальный шрифт. Плохого: кнопка создания новой заметки ушла вниз&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;до этого она была в том же углу, что и кнопка сохранения заметки, так было удобнее создавать несколько разных заметок подряд. Ещё теперь нельзя листать заметки влево-вправо, приходится каждый раз переходить в список и обратно. Из забавного: при всём минимализме новой iOS, в «заметках» оставили текстуру бумаги.&lt;/p&gt;
&lt;p&gt;В итоге, я теперь жду обновления iA Writer: в последнем обновлении они уже починили почти всё, к чему у меня были претензии, и если с обновлением под новую iOS ничего важного не сломают, перейду на него со стандартных заметок.&lt;/p&gt;
&lt;h2 id=&quot;напоминания&quot;&gt;Напоминания&lt;/h2&gt;
&lt;p&gt;А вот стандарные напоминания стали гораздо лучше, чем в предыдущей итерации. Навигация между листами стала удобнее, но, самое главное,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;теперь напоминания гораздо проще редактировать. Раньше для этого приходилось совершать очень, очень много действий, сейчас же редактирование доступно по одному тапу на заметке. Ура.&lt;/p&gt;
&lt;h2 id=&quot;папки&quot;&gt;Папки&lt;/h2&gt;
&lt;p&gt;К новым папкам у меня двоякие чувства. Плохого: на одном «экране» папки теперь помещается только 9 приложений. Но это обосновано тем, что теперь в папке может быть больше одного экрана. И там, где мне раньше приходилось создавать две-три папки для однотипных приложений, теперь всё можно запихнуть в одну папку. Только вот найти &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; за пределами первого экрана станет сильно сложнее (и, да, Newsstand теперь тоже можно положить в папку!)&lt;/p&gt;
&lt;p&gt;Ещё изменилась анимация перехода к папке и обратно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;теперь она приближена к идеям Раскина о масштабируемом интерфейсе, да и в целом весь интерфейс iOS (переходы между приложениями и разные иные места) всё больше этим идеям соответствует.&lt;/p&gt;
&lt;h2 id=&quot;фотографии&quot;&gt;Фотографии&lt;/h2&gt;
&lt;p&gt;Очень много улучшений. Я пока увидел только положительные, например, очень понравились списки моментов/коллекций/лет&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;масштабируемый интерфейс в том виде, в каком он должен быть.&lt;/p&gt;
&lt;h2 id=&quot;камера&quot;&gt;Камера&lt;/h2&gt;
&lt;p&gt;Тоже много изменений. Из того, что стоит отметить&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;режим квадратной съёмки. И это не просто квадратный кроп из коробки&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в этом режиме угол съёмки более широкий, что иногда может быть полезно.&lt;/p&gt;
&lt;h2 id=&quot;экран-блокировки&quot;&gt;Экран блокировки&lt;/h2&gt;
&lt;p&gt;Понравилось, что Slide to unlock теперь делается почти из любой точки экрана блокировки.&lt;/p&gt;
&lt;p&gt;Не понравилось, что когда играет музыка, на экране блокировки время и дата показываются очень маленькими, большими их можно сделать только вторым нажатием на кнопку home. Кажется, можно было пожертвовать контролами и названием проигрываемой композиции, так как к ним теперь есть простой доступ из панели управления, которая доступна и на экране блокировки.&lt;/p&gt;
&lt;h2 id=&quot;поиск-по-умолчанию&quot;&gt;Поиск по умолчанию&lt;/h2&gt;
&lt;p&gt;Теперь поиском по умолчанию &lt;a href=&quot;http://instagram.com/p/eba5_KmTgh/&quot;&gt;можно поставить Яндекс&lt;/a&gt;, ура. Жаль только, браузер по умолчанию нельзя сменить, ведь &lt;a href=&quot;#safari&quot;&gt;теперь в этом больше смысла&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Ещё обидно, что, добавив возможность сменить поиск по умолчанию, они убрали возможность поискать в вебе из стандартного поиска. Очень странное решение.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;&lt;em&gt; &lt;/em&gt; *&lt;/h2&gt;
&lt;p&gt;Очень хочется верить, что имеющиеся недостатки (особенно в Сафари) будут исправлены, но, в целом, мне всё нравится, желания откатиться назад не возникает.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Думать перед чтением</title>
    <link href="http://kizu.ru/blog/think-before-read/"/>
    <updated>2013-08-06T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/think-before-read</id>
    <content type="html">&lt;h1 id=&quot;думать-перед-чтением&quot;&gt;Думать перед чтением&lt;/h1&gt;
&lt;p&gt;Люблю это чувство: читаешь заголовок и первые строки статьи, и уже в этот момент, ещё до прочтения статьи целиком, понимаешь, о чём будет речь, как будет решена та или иная проблема, или же и вовсе вспоминаешь или придумываешь лучшее решение поставленной задачи.&lt;/p&gt;
&lt;p&gt;Кстати, почти об этом же я рассказывал в рамках доклада &lt;a href=&quot;http://vimeo.com/34190518&quot;&gt;«Бесчеловечные эксперименты над &lt;abbr&gt;CSS&lt;/abbr&gt;»&lt;/a&gt;: о том, что хороший способ &lt;span class=&quot;nobr&quot;&gt;чему-то&lt;/span&gt; научиться&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;перед заглядыванием в код того или иного примера попробовать сделать его с нуля.&lt;/p&gt;
&lt;p&gt;К написанию этой заметки меня сподвиг &lt;a href=&quot;http://www.shiningrocksoftware.com/?p=1303&quot;&gt;пост&lt;/a&gt; про разработку главного меню игры
&lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#banished&quot; id=&quot;banished&quot;&gt;Banished&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Ещё не вышла, разрабатывается одним человеком; советую полистать и подписаться на &lt;a href=&quot;http://www.shiningrocksoftware.com/&quot;&gt;блог&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;автор описывает различные аспекты разработки игры&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;. Вполне логично, что надо как можно раньше показывать главное меню и сразу же в фоне грузить последнее сохранение. Отличным решением стало сразу же, как в фоне загрузится последнее сохранение, показывать на заднем плане сцену из него, так что продолжение игры просто плавно сменит интерфейс главного меню на игровое меню.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Вики Гитхаба — не для документации</title>
    <link href="http://kizu.ru/blog/docs-not-at-wiki/"/>
    <updated>2013-08-01T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/docs-not-at-wiki</id>
    <content type="html">&lt;h1 id=&quot;вики-гитхаба-не-для-документации&quot;&gt;Вики Гитхаба&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не для документации&lt;/h1&gt;
&lt;p&gt;Давно хотел поделиться небольшим наблюдением: я часто вижу, что люди хранят документацию в вики Гитхаба. Я считаю, что так делать нельзя. Ни в коем случае. Лучшее место для документации&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сам репозиторий проекта. Аргументы:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;В вики нет синхронизации версии кода с версией документации. В вики текст всегда отображается самый актуальный, он не зависит от того, на какой коммит смотрят пользователи через веб-интерфейс. Поэтому, если возникает необходимость узнать какой был &lt;abbr&gt;API&lt;/abbr&gt; у конкретной версии кода, придётся вручную пытаться найти в истории вики момент, когда её содержимое совпадало с нужной действительностью. Эта проблема не возникнет если документацию хранить в репозитории проекта: если взять нужный коммит (нужную ветку, нужный тег), то документация будет видна в том виде, в каком она была на тот момент.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;В вики сложнее поддерживать документацию в актуальном состоянии. Гораздо проще одновременно с написанием кода писать и тесты, и документацию, чем потом отдельно к ним возвращаться и &lt;span class=&quot;nobr&quot;&gt;где-то&lt;/span&gt; в отдельном месте их править. Если с самого начала проекта поддерживать в порядке тесты с документацией, то и проблем в дальнейшей работе с ними не возникнет, но если забросить это дело (что очень просто сделать, когда код отделён от остальных сущностей), то вступает в действие энтропия. И уменьшение количества действий, нужных для обновления документации, делает проще её поддержку. Когда не нужен лишний шаг&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;его не нужно делать и сложнее оступиться.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Изменения в основном репозитории проще отслеживать, чем следить за вики. Если открыть вики на всех, можно случайно не отследить добавление кем-нибудь ошибочной информации; тогда как стандартный путь внесения изменений через пулл-реквесты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;удобный и надёжный. И, наоборот, на коммиты проще подписаться, чем отслеживать происходящее в вики.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;В итоге, я не вижу причин использовать вики для документации. Если &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; сможет привести аргументы в пользу подобного положения дел&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;буду им рад. И если появится смысл использовать вики, я бы хотел предложить попробовать сделать это не совсем обычным образом. Вики в Гитхабе, в принципе, тоже отдельный репозиторий, а это значит, что его можно подцеплять сабмодулем к другому репозиторию. Соответственно, можно попробовать сделать вики сабмодулем к основному репозиторию с кодом&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в этом случае мы решаем почти все проблемы, но получаем в нагрузку необходимость следить за сабмодулем. Но, возможно, оно того будет стоить.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Обновлённый Jekyll</title>
    <link href="http://kizu.ru/blog/updated-jekyll/"/>
    <updated>2013-06-05T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/updated-jekyll</id>
    <content type="html">&lt;h1 id=&quot;обновл-нный-jekyll&quot;&gt;Обновлённый Jekyll&lt;/h1&gt;
&lt;p&gt;Недавно Jekyll стал совсем большим&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;https://github.com/blog/1502-jekyll-turns-1-0&quot;&gt;была выпущена&lt;/a&gt; версия «1.0».&lt;/p&gt;
&lt;p&gt;В &lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/History.markdown#100—2013-05-06&quot;&gt;ченджлоге&lt;/a&gt; довольно много изменений: есть как новые фичи, так и всяческие исправления. О том, что критично знать про это обновление, можно прочитать в &lt;a href=&quot;http://jekyllrb.com/docs/upgrading/&quot;&gt;этой статье&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Я перевёл свой сайт на эту версию. Ну, как перевёл,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всё и так работало, но зато появилась возможность многое сделать оптимальнее. Напишу немного о том, что же лично для меня интересного появилось в Jekyll 1.0.&lt;/p&gt;
&lt;h2 id=&quot;page-path&quot;&gt;&lt;code&gt;page.path&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Это одна из тех вещей, которых я ждал от новой версии Джекила,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я даже в своё время &lt;a href=&quot;https://github.com/mojombo/jekyll/issues/633#issuecomment-11678912&quot;&gt;попинал&lt;/a&gt; лишний раз разработчиков комментариями к соответствующему ишью.&lt;/p&gt;
&lt;p&gt;У старой версии Джекила была одна проблема&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в информации о постах и страницах отсутствовала переменная с путём к исходнику. Почему это важно: для блога или сайта, выложенного на Гитхаб, очень полезным может быть предоставление быстрой возможности &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; поправить (форкнуть). Для этого можно на странице разместить ссылку либо напрямую на Гитхаб, либо, например, на prose.io или другой подобный сервис. В этой ссылке прописывается путь к исходнику страницы, которую нужно отредактировать; раньше в отсутствие соответствующей переменной приходилось &lt;span class=&quot;nobr&quot;&gt;такими-то&lt;/span&gt; хаками этот урл собирать вручную.&lt;/p&gt;
&lt;p&gt;Теперь же всё просто: в данных страниц и постов стала доступна переменная &lt;code&gt;path&lt;/code&gt;, в которую кладётся относительный путь к исходнику. Ура :)&lt;/p&gt;
&lt;h2 id=&quot;абсолютные-пермалинки&quot;&gt;Абсолютные пермалинки&lt;/h2&gt;
&lt;p&gt;Пермалинки, задаваемые постам в &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовках, раньше были относительными. При этом не было возможности указать пермалинк уровнем выше&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;нельзя было использовать &lt;code&gt;../&lt;/code&gt; (ну, или я так и не смог найти способ, как это можно было сделать). В новой версии Джекила теперь можно использовать и абсолютные урлы. Точнее, в 1.0 абсолютные урлы надо специально включать в конфиге директивой &lt;code&gt;relative_permalinks: false&lt;/code&gt;, а с 1.1 это будет работать по умолчанию. Это значит, что, если сейчас вы используете относительные урлы (и не собираетесь их переделывать на абсолютные), надо явно указать &lt;code&gt;relative_permalinks: true&lt;/code&gt;, чтобы в 1.1 ничего не сломалось.&lt;/p&gt;
&lt;p&gt;Абсолютные урлы позволили мне чуть упростить файловую структуру репозитория&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вынести все индексные страницы в отдельную папку, например.&lt;/p&gt;
&lt;h2 id=&quot;изменившийся-синтаксис-cli&quot;&gt;Изменившийся синтаксис &lt;abbr&gt;CLI&lt;/abbr&gt;&lt;/h2&gt;
&lt;p&gt;В новом Джекиле изменился и формат вызова из командной строки, в том числе появилась возможность использовать дополнительные конфиги.&lt;/p&gt;
&lt;p&gt;Например, теперь, чтобы запустить сервер Джекила, используя и дефолтный конфиг &lt;code&gt;_config.yml&lt;/code&gt;, и дополнительный, скажем, &lt;code&gt;_config-dev.yml&lt;/code&gt;, нужно запускать его так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;jekyll serve --config _config.yml,_config-dev.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Таким образом, можно довольно просто настроить разработческое окружение, в котором, например, менять абсолютные урлы на локальные, включать отображение черновиков и вообще изменять что угодно независимо от продакшн-версии.&lt;/p&gt;
&lt;p&gt;Стоит заметить, что в Jekyll 1.0 был объявлен ещё один ключ запуска: &lt;code&gt;--baseurl&lt;/code&gt;, с помощью которого можно было бы менять переменную &lt;code&gt;baseurl&lt;/code&gt;, но, &lt;span class=&quot;nobr&quot;&gt;во-первых&lt;/span&gt;, у меня не получилось ей воспользоваться: Джекилл вообще отказывался что-либо генерить с этой изменённой переменной, &lt;span class=&quot;nobr&quot;&gt;во-вторых&lt;/span&gt;, всё то же самое можно сделать, используя дополнительный конфиг, так что я пока не вижу смысла в ключе &lt;code&gt;--baseurl&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;черновики&quot;&gt;Черновики&lt;/h2&gt;
&lt;p&gt;В новом Джекиле появилась возможность использовать черновики. Если создать папку &lt;code&gt;_drafts&lt;/code&gt;, то по умолчанию её содержимое будет игнорироваться, но, если запустить Джекил с ключом &lt;code&gt;--drafts&lt;/code&gt;, содержимое этой папки будет распознано почти аналогично содержимому &lt;code&gt;_posts&lt;/code&gt;. Полезное исключение: в таких постах не нужно указывать дату, таким образом для публикации нужно будет всего лишь переместить и переименовать файл со статьёй.&lt;/p&gt;
&lt;p&gt;Я сам пока &lt;em&gt;такие&lt;/em&gt; черновики не использую, но, возможно, начну.&lt;/p&gt;
&lt;h2 id=&quot;остальное&quot;&gt;Остальное&lt;/h2&gt;
&lt;p&gt;В ченджлоге можно &lt;a href=&quot;https://github.com/mojombo/jekyll/blob/master/History.markdown#minor-enhancements-3&quot;&gt;прочитать&lt;/a&gt; обо всём, что ещё поменялось, там довольно много всего, но больше ничего особо критичного.&lt;/p&gt;
&lt;p&gt;В общем, я перешёл на новый Джекил, всё работает, всем рекомендую.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Шорткаты приложений</title>
    <link href="http://kizu.ru/blog/application-shortcuts/"/>
    <updated>2013-06-03T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/application-shortcuts</id>
    <content type="html">&lt;h1 id=&quot;шорткаты-приложений&quot;&gt;Шорткаты приложений&lt;/h1&gt;
&lt;p&gt;Давно хотел рассказать про этот подход к работе (workflow)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;использование шорткатов для переключения между приложениями.&lt;/p&gt;
&lt;p&gt;Речь не о системных шорткатах вида &lt;code&gt;cmd+tab&lt;/code&gt;/&lt;code&gt;alt+tab&lt;/code&gt;. Такие шорткаты, на самом деле, ужасны, так как модальны. В каждый момент времени результат применения такого шортката может быть совершенно любым: «альт-таб» переключает фокус между последними открытыми приложениями, поэтому нужно помнить, что же у тебя было открыто раньше и в каком порядке. &lt;/p&gt;
&lt;p&gt;Решение проблемы с переключениями между несколькими приложениями показал мне в декабре 2009 года Виталий Харисов: достаточно назначить на каждое часто используемое приложение свой шорткат.&lt;/p&gt;
&lt;p&gt;В 2009 году для этого можно было использовать Spaces в Mac OS&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в каждый спейс, кроме дефолтного, шло по одному приложению; в глобальных настройках клавиатуры на эти спейсы вешались сочетания клавиш вроде &lt;code&gt;option+A&lt;/code&gt;, &lt;code&gt;option+S&lt;/code&gt;, &lt;code&gt;option+D&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;эти клавиши всегда лежат под рукой, а сочетания с &lt;code&gt;option&lt;/code&gt; во всех приложениях вставляют какой-нибудь не особо нужный символ, так что ими вполне можно пожертвовать.&lt;/p&gt;
&lt;p&gt;Виталя тогда предложил примерно такую раскладку: в среднем ряду букв шли браузеры&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;так как при проверке вёрстки и всего такого между ними надо было много переключаться (за давностью лет я мог &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; перепутать, но общий принцип таков, и большинством из этих сочетаний я пользуюсь и по сей день):&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;option+A&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Opera, как основной браузер, поэтому буква «A»;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option+S&lt;/code&gt; —&lt;strong&gt;S&lt;/strong&gt;afari;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option+D&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;IE, &lt;code&gt;D&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;т.к. он &lt;strong&gt;D&lt;/strong&gt;урацкий;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option+F&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;strong&gt;F&lt;/strong&gt;irefox.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Остальные приложения были раскиданы рядом:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;option+Q&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;терминал, &lt;code&gt;Q&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;так как близко к остальным шорткатам;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option+W&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Finder, по тем же причинам;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;option+E&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Основной редактор кода&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;strong&gt;E&lt;/strong&gt;ditor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ещё я часто добавлял &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; на сочетания с шифтом, мнемоника простая&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;option+shift+E&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;второстепенный редактор кода, &lt;code&gt;option+shift+A&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Opera Next, то есть разработческая версия оперы, остальное аналогично и для других сочетаний.&lt;/p&gt;
&lt;p&gt;Сейчас у меня назначены сочетания и на Джаббер, Почту, Фотошоп, редактор текста (iA Writer) и многое другое.&lt;/p&gt;
&lt;p&gt;С &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; из версий Mac OS спейсы стали не такими удобными, и я купил &lt;a href=&quot;http://www.alfredapp.com&quot;&gt;Alfred Powerpack&lt;/a&gt;, в котором оказалась очень полезная возможность вешать любые приложения или файлы на сочетания клавиш. Я тут же отказался от спейсов и перебиндил всё на Альфред (упростив настройку этих сочетаний и включив синхронизацию всего этого дела сначала через Дропбокс, потом через Яндекс.Диск, да и само переключение стало быстрее, чем с использованием спейсов). Насколько я знаю, под мак существует ещё ряд приложений, в том числе и бесплатных (&lt;a href=&quot;http://qsapp.com/&quot;&gt;QuickSilver&lt;/a&gt;, &lt;a href=&quot;http://www.boastr.de/&quot;&gt;BetterTouchTool&lt;/a&gt;), делающих то же самое. Наверняка подобные приложения существуют и под другие ОС, если &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; знает&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;напишите мне, я добавлю это в пост.&lt;/p&gt;
&lt;p&gt;В общем, я всем рекомендую тем или иным способом назначать шорткаты отдельным приложениям, это значительно ускоряет и упрощает работу:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Если тебе нужно переключиться на &lt;span class=&quot;nobr&quot;&gt;какое-то&lt;/span&gt; приложение, ты всегда нажимаешь одно простое сочетание клавиш, не нужно знать, в каком порядке ты использовал другие приложения, и сколько раз нужно альттабнуться, чтобы переключиться на нужное; ровно как и не нужно знать, запущено ли нужное приложение в принципе,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Альфред, например, сам запустит его, если нужно.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Это легче и быстрее, чем переключение на приложение с использованием мыши/тачпада, или же ввода имени или первых букв приложения в Спотлайте, Квиксильвере или Альфреде.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Если вы в команде договоритесь об одинаковых шорткатах, то это очень сильно упростит взаимодействие в случаях, когда надо подойти и на чужом компьютере &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; показать. В незнакомой системе док может находиться не там, где у тебя; могут быть запущены разные приложения, разные редакторы, разное их количество. Если же договориться о шорткатах, то ты всегда сможешь переключаться между браузером, редактором и терминалом на компьютере коллеги.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;

    </content>
  </entry>
  <entry>
    <title>Текстовый курсор</title>
    <link href="http://kizu.ru/blog/cursor-text/"/>
    <updated>2013-05-17T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/cursor-text</id>
    <content type="html">&lt;h1 id=&quot;текстовый-курсор&quot;&gt;Текстовый курсор&lt;/h1&gt;
&lt;p&gt;Я уже &lt;a href=&quot;/issues/cursor-pointer/&quot;&gt;писал&lt;/a&gt; о том, что на все активные элементы нужно вешать &lt;code&gt;cursor:pointer&lt;/code&gt;. Если кратко, то смена курсора должна означать, что с элементом под ним можно &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; сделать, а не то, что элемент под курсором несёт &lt;span class=&quot;nobr&quot;&gt;какую-то&lt;/span&gt; семантику (скажем, является &lt;em&gt;ссылкой&lt;/em&gt;, а не &lt;em&gt;кнопкой&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;Основная причина для этого&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;единообразие. Пользователи должны знать, что если курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;рука, значит, можно на этот элемент нажать, чтобы &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; произошло. А уж о том &lt;em&gt;что именно&lt;/em&gt; произойдёт должен уже говорить сам элемент.&lt;/p&gt;
&lt;p&gt;И тут я натыкаюсь на такую вещь, как &lt;code&gt;cursor:text&lt;/code&gt;. И вижу отсутствие единообразия.&lt;/p&gt;
&lt;p&gt;Дело в том, что этот курсор появляется как над обычным текстом, так и над текстовыми инпутами и текстариями.&lt;/p&gt;
&lt;p&gt;Зачем нужен этот курсор-каретка над текстом? Чтобы дать понять, что его можно выделить. Тонкий курсор-каретка облегчает эту задачу: он почти незаметен между буквами, с помощью него легко выделять ровно те буквы и слова, что нужно.&lt;/p&gt;
&lt;p&gt;Но как только мы смотрим на неактивное поле ввода, мы всё равно видим там этот текстовый курсор (даже когда поле пустое).&lt;/p&gt;
&lt;p&gt;У меня возникло несколько вопросов: как часто, когда мы видим форму, мы хотим &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; выделить в её текстовых полях? А как часто мы хотим &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; там написать, &lt;em&gt;активировав&lt;/em&gt; поле, то есть, переместив в него фокус? Является ли перенос фокуса действием? Не стоит ли, ради единообразия, делать для текстовых полей ввода вот так?&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;input[type=text], input[type=password], textarea {
    cursor: pointer;
}
input[type=text]:focus, input[type=password]:focus, textarea:focus {
    cursor: text;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;small&gt;Понятное дело, что вместо &lt;code&gt;input[type=text]&lt;/code&gt; будет или класс, или перечисление всех возможных текстовых полей.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Здесь &lt;code&gt;cursor:pointer&lt;/code&gt; получат только неактивные поля ввода, но, как только &lt;span class=&quot;nobr&quot;&gt;где-то&lt;/span&gt; появляется фокус, элемент перестаёт быть &lt;em&gt;активируемым&lt;/em&gt;, и мы уже ожидаем, что пользователи могут там выделять текст. Кроме того, текстовый курсор гораздо менее заметен, чем рука: он тонкий, и им сложнее попасть по полю ввода, когда это нужно.&lt;/p&gt;
&lt;p&gt;Конечно, это очень спорное место, подобное изменение рушит пользовательские привычки, но не будет ли подобное поведение, в итоге, лучше? Ведь так мы получим достаточно чёткую логику: если есть курсор-поинтер, значит, мы можем &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; с этим элементом сделать; если есть курсор-текст&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;мы можем в этом элементе выделить текст; если дефолтный курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;клик на это место ничего не даст.&lt;/p&gt;
&lt;p&gt;Это, в том числе, ложится и в концепцию остальных курсоров, таких как &lt;code&gt;resize&lt;/code&gt; и &lt;code&gt;drag&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;они говорят именно о том, что можно сделать с элементом, а не о том, чем этот элемент является.&lt;/p&gt;
&lt;p&gt;Конечно же, я не рекомендую прямо сейчас идти и делать именно так, но если &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; попробует провести A/B-тестирование и сказать, изменится ли кликабельность/заполняемость полей,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;будет круто. Любые замечания и мысли по этому поводу я также приветствую&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;пишите!&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>«Блог»</title>
    <link href="http://kizu.ru/blog/hello-blog/"/>
    <updated>2013-05-07T00:00:00+03:00</updated>
    <id>http://kizu.ru/blog/hello-blog</id>
    <content type="html">&lt;h1 id=&quot;-блог-&quot;&gt;«Блог»&lt;/h1&gt;
&lt;p&gt;Привет! В &lt;a href=&quot;/issues/restart/&quot;&gt;посте про перезапуск сайта&lt;/a&gt; я написал, что основной задачей новой версии было упрощение добавления новых записей. Однако, за технической стороной дела я совсем забыл о том, &lt;em&gt;что же именно&lt;/em&gt; я хотел так легко и просто писать.&lt;/p&gt;
&lt;p&gt;Всё, что я публиковал на своём сайте, делилось на две части: &lt;a href=&quot;/issues/&quot;&gt;«заметки»&lt;/a&gt; и &lt;a href=&quot;/fun/&quot;&gt;«эксперименты»&lt;/a&gt;. В «заметках» я старался публиковать в основном объективные, аргументированные, «выстраданные» вещи. Можно было назвать это «статьями», но мне это слово не нравится. В «эксперименты» шли решения, не претендующие на то, чтобы где-либо серьёзно применяться, прототипы каких-либо интересно свёрстанных штук, почти без сопроводительных текстов. Правда, сейчас я вижу, что иногда имеет смысл чуть подробнее описывать те или иные эксперименты (как я недавно расписал &lt;a href=&quot;:rotated-text&quot;&gt;повёрнутый текст&lt;/a&gt;), но я &lt;span class=&quot;nobr&quot;&gt;по-прежнему&lt;/span&gt; против детально разжёванных пошаговых руководств, потому и «статьями» то, что есть и будет публиковаться в «экспериментах», назвать нельзя.&lt;/p&gt;
&lt;p&gt;Так зачем же я облегчил себе написание постов в новой версии сайта? Затем, что мне давно хотелось писать &lt;em&gt;чаще&lt;/em&gt;. Не размещать только статьи или эксперименты, а вести &lt;em&gt;блог&lt;/em&gt;. То есть не писать объективные и продуманные вещи, не публиковать заковыристые и сложные эксперименты, а иметь площадку, на которой я смог бы делиться &lt;span class=&quot;nobr&quot;&gt;чем-то&lt;/span&gt; повседневным: простыми идеями, впечатлениями, критикой всего того, что сейчас происходит во фронтенде.&lt;/p&gt;
&lt;p&gt;Пока процесс публикации статей на сайте был сложным, я об этом не задумывался, потом&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;задумался, переделал сайт, но в процессе переделки забыл о том, что всё это замышлялось именно ради простых и коротких постов. В итоге, я не &lt;span class=&quot;nobr&quot;&gt;так-то&lt;/span&gt; много и написал после перезапуска сайта, но вот незаконченных набросков и черновиков накопилось очень много. Я забыл про то, что можно публиковать не только отшлифованные до зеркального блеска вещи, но и короткие, незаконченные посты (ну а все имеющиеся наброски я когда-нибудь доделаю, никуда не торопясь и не стремясь «выдержать ритм» публикации).&lt;/p&gt;
&lt;p&gt;И вот теперь я об этом вспомнил, и вот он, новый раздел у меня на сайте&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;/blog/&quot;&gt;блог&lt;/a&gt;. На самом деле «раздел»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;громко сказано, скорее это просто способ заставить себя писать более коротко. Эти записи будут всё так же попадать в &lt;a href=&quot;http://feeds.feedburner.com/kizu&quot; title=&quot;На самом деле там Atom, конечно, но какой другой термин тут использовать?&quot;&gt;&lt;abbr&gt;RSS&lt;/abbr&gt;-потоки&lt;/a&gt;, я всё так же буду делиться ссылками на эти новые посты в твиттере, в общем, для читателей ничего не изменится (кроме того, что контента станет больше).&lt;/p&gt;
&lt;p&gt;В общем, ура, вот он блог. Постараюсь писать в него всякую фигню почаще :)&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Повёрнутый текст</title>
    <link href="http://kizu.ru/fun/rotated-text/"/>
    <updated>2013-04-30T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/rotated-text</id>
    <content type="html">&lt;h1 id=&quot;пов-рнутый-текст&quot;&gt;Повёрнутый текст&lt;/h1&gt;
&lt;p&gt;Некоторое время назад я уже делился этим решением в твиттере, но на этот раз хочу написать о нём немного подробнее.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача&lt;/strong&gt;: получить повёрнутый на 90 градусов текст.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Проблема&lt;/strong&gt;: широко известно, что при использовании &lt;code&gt;transform&lt;/code&gt;, блок ведёт себя аналогично сдвигу через &lt;code&gt;position:relative&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;продолжает занимать место в потоке по состоянию до трансформации, так что, по факту, изменение происходит только визуальное.&lt;/p&gt;
&lt;p&gt;Однако, довольно часто можно захотеть повернуть блок так, чтобы этот поворот влиял и на поток. Например, если мы захотим выстроить несколько вертикальных блоков в ряд, подобно книгам на полке, или если мы захотим использовать повёрнутый текст в качестве заголовков таблицы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в этих случаях нам нужно будет гарантировать, что высота станет равна ширине блока, в то время как ширина&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;высоте.&lt;/p&gt;
&lt;p&gt;У меня получилось решить эту задачу с одним допущением: нужно знать высоту поворачиваемого элемента. В этом случае реализация становится очень простой:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Нам понадобится дополнительный элемент. &lt;abbr&gt;HTML&lt;/abbr&gt; каждого блока будет примерно таким:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt; &amp;lt;span class=&amp;quot;rotated-text&amp;quot;&amp;gt;
     &amp;lt;span class=&amp;quot;rotated-text__inner&amp;quot;&amp;gt;
         Rotated foo
     &amp;lt;/span&amp;gt;
 &amp;lt;/span&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Врапперу мы задаём вот такие стили: &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt; .rotated-text {
     display: inline-block;
     overflow: hidden;

     width: 1.5em;
     line-height: 1.5;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; Здесь мы делаем элемент инлайн-блочным (это не критично, сработало бы и блочное отображение, но инлайн-блок чаще бывает нужен), затем обрезаем все выступающие части (пригодится позже), далее задаём ширину, равную текущей высоте блока,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;то самое допущение (&lt;code&gt;line-height&lt;/code&gt; тут приведён в качестве примера того, что сейчас определяет высоту блока, а так как все элементы, используемые в примере, однострочные, то это и будет его высотой).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Внутренний элемент делаем инлайн-блочным, чтобы его ширина схлопнулась по контенту. После чего задаём &lt;code&gt;white-space:nowrap&lt;/code&gt; для того, чтобы ничего никуда не переносилось (ведь выше мы ограничили ширину), ну и поворачиваем блок, считая верхний левый угол точкой отсчёта (для читаемости свойства приведены без префиксов):&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt; .rotated-text__inner {
     display: inline-block;
     white-space: nowrap;

     transform: translate(0,100%) rotate(-90deg);
     transform-origin: 0 0;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;А теперь самое главное: нам нужно сделать этот внутренний элемент «квадратным»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это сделает высоту конечного элемента равной ширине, ну а ширина у нас обрезается враппером. Для того, чтобы сделать наш элемент квадратным, я применяю вот такой вот трюк:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt; .rotated-text__inner:after {
     content: &amp;quot;&amp;quot;;
     float: left;
     margin-top: 100%;
 }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; Вроде всё довольно просто, но немногие знают о том, что вертикальные маджины и паддинги, заданные в процентах, исчисляются не от высоты блока, а от его ширины. Это поведение редко используется на практике, но у нас как раз тот случай, когда оно пригодилось.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;В итоге мы получаем квадратный элемент, обрезаемый враппером до ширины своей прошлой высоты, такой элемент можно использовать в любом контексте, для него будут работать разные свойства вроде &lt;code&gt;text-align&lt;/code&gt; или &lt;code&gt;vertical-align&lt;/code&gt;, так что можно сказать, мы получили «честный» повёрнутый блок.&lt;/p&gt;
&lt;p&gt;Ну и несколько живых примеров:&lt;/p&gt;
&lt;h2 id=&quot;заголовки-таблиц&quot;&gt;Заголовки таблиц&lt;/h2&gt;
&lt;p&gt;Очевидный пример&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;компактные по ширине заголовки таблиц.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/rotated-text/#Demo_rotated-text&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;-книжная-полка-&quot;&gt;«Книжная полка»&lt;/h2&gt;
&lt;p&gt;Так как повёрнутые блоки получаются «честными», то, если выстроить их в ряд, высота ряда будет равна высоте самого большего из них:&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/rotated-text/#Demo_rotated-text_books&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;nobr&quot;&gt;Как-то&lt;/span&gt; так.&lt;/p&gt;
&lt;p&gt;Ещё раз: мы должны знать высоту блока, так что, если понадобится поворачивать таким образом многострочные блоки, нужно будет соответствующим образом изменять ширину их врапперов.&lt;/p&gt;
&lt;p&gt;Кроме того, возможно, этот метод можно заставить работать и в IE&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;применив матричный фильтр для поворота и добавив элемент в замену псевдоэлементу. Мне лень всё это делать, но если &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; это сделает, я буду рад пулл-реквестам к &lt;a href=&quot;https://github.com/kizu/kizu.github.com/blob/master/demos/rotated-text.html&quot;&gt;этим&lt;/a&gt; &lt;a href=&quot;https://github.com/kizu/kizu.github.com/blob/master/demos/rotated-text_books.html&quot;&gt;примерам&lt;/a&gt; :)&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Маркдауним YAML для Jekyll</title>
    <link href="http://kizu.ru/issues/markdowning-yaml/"/>
    <updated>2013-04-21T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/markdowning-yaml</id>
    <content type="html">&lt;h1 id=&quot;маркдауним-yaml-для-jekyll&quot;&gt;Маркдауним &lt;abbr&gt;YAML&lt;/abbr&gt; для Jekyll&lt;/h1&gt;
&lt;p&gt;Пока я всё никак не допишу какой-либо из длинных постов, попробую выложить несколько мелких заметок. Начну с небольшого трюка для Jekyll.&lt;/p&gt;
&lt;p&gt;Для настройки метаданных (заголовок, лейаут, дата, всё такое) в Jekyll используется «&lt;abbr&gt;YAML&lt;/abbr&gt; front matter»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;описание всех этих данных в специально оформленном коде, который обязательно должен идти в начале файла. Jekyll в принципе «видит» только те страницы, у которых этот заголовок есть, поэтому &lt;abbr&gt;YAML&lt;/abbr&gt; front matter&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;довольно важная часть.&lt;/p&gt;
&lt;p&gt;Обычно такой заголовок выглядит примерно так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;---
layout: docs
title: Resources
prev_section: sites
---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Казалось бы, всё ок. Но! Раз я использую Jekyll на Гитхабе, мой перфекционизм требует, чтобы исходник страницы с таким заголовком выглядел идеально. А Гитхаб по умолчанию показывает не исходный код &lt;code&gt;.md&lt;/code&gt;-файлов, а сразу рендерит их. Вот, например, как выглядит код выше, отрендеренный в маркдауне:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img-fotki.yandex.ru/get/6430/1076905.1/0_9789a_239b2fc2_orig.png&quot; alt=&quot;Плохой код&quot;&gt;&lt;/p&gt;
&lt;p&gt;Не очень читаемо, правда? И последняя строчка, внезапно, становится заголовком (если знать синтаксис маркдауна, то, конечно, не внезапно)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это вряд ли то, чего мы хотели.&lt;/p&gt;
&lt;p&gt;Всё это дело легко исправить: достаточно изменить стиль написания &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовков. Нужно просто добавить воды, то есть пустых строк. Вот так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-yaml&quot;&gt;---

layout: docs

title: Resources

prev_section: sites

---
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Такой &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовок будет уже выглядеть приемлемо:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://img-fotki.yandex.ru/get/5625/1076905.1/0_97899_16bfcbbf_orig.png&quot; alt=&quot;Хороший код&quot;&gt;&lt;/p&gt;
&lt;p&gt;Вместо заголовка мы получаем хорошо отделённый от основного контента поста &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовок, каждая строка которого превращается в параграф.&lt;/p&gt;
&lt;p&gt;Так как в постах чаще всего бывает не так много метаданных, лишние строки не особо раздувают код. На мой взгляд, подобный стиль написания &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовков гораздо читабельнее, так что я не вижу причин почему бы не использовать его постоянно.&lt;/p&gt;
&lt;p&gt;Я лишь жалею, что синтаксис &lt;abbr&gt;YAML&lt;/abbr&gt; слишком строг, и нельзя добавить в начало каждой строки или отступов, чтобы весь этот блок выглядел как кусок кода, или дефисов, чтобы он выглядел как список. И, если кто придумает как ещё можно улучшить читаемость кода &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовков, не стесняйтесь, пишите issues.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Jekyll</title>
    <link href="http://kizu.ru/issues/going-jekyll/"/>
    <updated>2013-01-30T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/going-jekyll</id>
    <content type="html">&lt;h1 id=&quot;jekyll&quot;&gt;Jekyll&lt;/h1&gt;
&lt;p&gt;В &lt;a href=&quot;/issues/restart/&quot;&gt;посте про перезапуск&lt;/a&gt; я пообещал написать серию статей про Jekyll. Это&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;первая, вводная, заметка из серии.&lt;/p&gt;
&lt;p&gt;Я не буду подробно описывать что же такое &lt;a href=&quot;https://github.com/mojombo/jekyll&quot;&gt;Jekyll&lt;/a&gt;, как его установить, какая у него файловая структура и так далее&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;про это уже написано довольно много статей (см. ниже в &lt;a href=&quot;#links&quot;&gt;«ссылках»&lt;/a&gt;). Если кратко, то это статический генератор сайтов с прицелом на блоги.&lt;/p&gt;
&lt;h2 id=&quot;github-pages&quot;&gt;GitHub Pages&lt;/h2&gt;
&lt;p&gt;Начну с главного: эту и последующие статьи я буду писать в контексте сервиса &lt;a href=&quot;http://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;. Дело в том, что Гитхаб, помимо обычного хостинга статики, предоставляет также и возможность хостить сайты на Jekyll. Таким образом, Jekyll&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;единственный способ &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; генерить прямо на Гитхабе (ещё можно попробовать исхитриться и либо использовать сторонний сервис, в который будут уходить хуки и который будет &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; на каждый пуш билдить и коммитить, либо обрабатывать и собирать всё на клиенте, сделав весь сайт одностраничным веб-приложением; но оба этих решения я рассматривать пока не буду).&lt;/p&gt;
&lt;p&gt;С Jekyll же достаточно создать файл в формате markdown, добавить в начало &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовок&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и можно писать текст. После пуша этого файла в репозиторий Гитхаб перегенерирует весь сайт, и соответствующий пост появится как в виде страницы на сайте, так и во всех списках и сайдбарах на других страницах. При этом пушить файл или изменения можно откуда угодно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;хоть со своей машины, хоть через веб-интерфейс Гитхаба, хоть с помощью любого стороннего приложения, использующего &lt;abbr&gt;API&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;Сразу замечу, что многие вещи, о которых я буду писать в последующих статьях, можно &lt;em&gt;намного&lt;/em&gt; проще реализовать в виде плагинов. Но я не пойду «простым» (для разработчика, но не для пользователя) путём&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;мне интересны решения, которые будут работать где угодно, в том числе и на Гитхабе, где нельзя использовать сторонние плагины.&lt;/p&gt;
&lt;h2 id=&quot;-hello-world-&quot;&gt;«Hello world»&lt;/h2&gt;
&lt;p&gt;Минимальный документ, который нужно написать, чтобы файл сбилдился с помощью Jekyll, должен содержать &lt;a href=&quot;http://ru.wikipedia.org/wiki/YAML&quot;&gt;&lt;abbr&gt;YAML&lt;/abbr&gt;&lt;/a&gt;-заголовок с хотя бы одним полем&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;code&gt;layout&lt;/code&gt; (на самом деле можно и без него, но тогда у вас будет страница без заголовков и всего прочего&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вряд ли вам это нужно). Так что минимально адекватный &lt;code&gt;hello-world.md&lt;/code&gt; для Jekyll мог бы выглядеть так:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;---
layout: default
---

Hello world!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В реальном мире к посту захочется добавить и заголовок записи, и ещё всяких данных, но для простых случаев хватит и такого минимального &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовка.&lt;/p&gt;
&lt;h2 id=&quot;дата&quot;&gt;Дата&lt;/h2&gt;
&lt;p&gt;Одна из фишек, которая мне понравилась в Jekyll&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;файлы постов в блоге нужно называть в формате &lt;code&gt;YYYY-MM-DD-title&lt;/code&gt;. &lt;span class=&quot;nobr&quot;&gt;Во-первых&lt;/span&gt;, это заставляет поддерживать в порядке файловую структуру&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;посты в папках автоматически сортируются по дате, &lt;span class=&quot;nobr&quot;&gt;во-вторых&lt;/span&gt;, это избавляет от необходимости прописывать дату в самом файле. В некоторых генераторах статики, которые я использовал раньше, эту информацию приходилось дублировать, прописывая в &lt;abbr&gt;YAML&lt;/abbr&gt; поля типа &lt;code&gt;published&lt;/code&gt;. В Jekyll тоже можно их использовать, если, скажем, хочется уточнить время, но можно жить и без этого&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;дата из имени файла попадёт в данные, доступные шаблонам.&lt;/p&gt;
&lt;p&gt;В Jekyll остальные аспекты сделаны так же минималистично. Для создания нового поста не нужно помнить, что же там обязательно прописывать в &lt;abbr&gt;YAML&lt;/abbr&gt;, можно просто создать текстовый документ, заполнить его и получить готовый пост на сайте после пуша.&lt;/p&gt;
&lt;h2 id=&quot;prose-io&quot;&gt;Prose.io&lt;/h2&gt;
&lt;p&gt;Если не хочется вручную каждый раз заполнять &lt;abbr&gt;YAML&lt;/abbr&gt;-заголовки, то можно воспользоваться или каким-нибудь скриптом, как это сделано в Jekyll Bootstrap, или использовать сервис &lt;a href=&quot;http://prose.io&quot;&gt;Prose.io&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;он &lt;a href=&quot;http://prose.io/help/handbook.html#metadata_defaults&quot;&gt;позволяет&lt;/a&gt; описать в конфиге, какие данные использовать по умолчанию при создании нового файла. Таким образом, если новые посты писать через веб, используя Prose, то не нужно будет заботиться о заполнении метаданных (на самом деле на них нужно будет всё равно разок взглянуть, но об этом я напишу в другой раз).&lt;/p&gt;
&lt;h2 id=&quot;links&quot;&gt;Ссылки&lt;/h2&gt;
&lt;p&gt;В сети про Jekyll уже есть очень много полезной информации. В этом разделе я попробую постепенно собирать и то, что может понадобиться для начала работы с Jekyll, и то, что нужно использовать постоянно. Итак:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllrb.com&quot;&gt;официальный сайт Jekyll&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://prose.io/help/handbook.html&quot;&gt;настройки конфига для Prose.io&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;У проекта &lt;a href=&quot;http://jekyllbootstrap.com&quot;&gt;Jekyll Bootstrap&lt;/a&gt; есть отличная серия статей про Jekyll, например:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllbootstrap.com/lessons/jekyll-introduction.html&quot;&gt;введение в Jekyll&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://jekyllbootstrap.com/api/template-data-api.html&quot;&gt;описание форматов внутренних данных&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Вся логика в Jekyll работает на шаблонизаторе &lt;a href=&quot;http://www.liquidmarkup.org&quot;&gt;Liquid&lt;/a&gt;. Недавно Гитхаб обновил версию Jekyll (вместе с Liquid, естественно), так что сейчас можно использовать все теги из документации:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/shopify/liquid/wiki/liquid-for-designers&quot;&gt;список стандартных тегов liquid&lt;/a&gt;;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mojombo/jekyll/wiki/liquid-extensions&quot;&gt;дополнительные теги liquid в Jekyll&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;До этого обновления, скажем, нельзя было использовать &lt;code&gt;split&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;а в отсутствие нормального поиска и замены с регулярными выражениями это почти единственный способ сделать &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; сложное. Я уже почти разобрался как с ним работать, так что ждите статей про это.&lt;/p&gt;
&lt;p&gt;Для написания постов я советую использовать Маркдаун. Хотя Jekyll позволяет создавать новые посты как на чистом &lt;abbr&gt;HTML&lt;/abbr&gt;, так и используя другой формат&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;Textile, для большинства задач Маркдаун будет лучше.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;В качестве движка для маркдауна я советую использовать &lt;a href=&quot;http://kramdown.rubyforge.org&quot;&gt;kramdown&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сейчас это оптимальный вариант. Возможно, я как-нибудь напишу небольшую заметку, в которой расскажу, почему остальные движки маркдауна, доступные Jekyll, хуже крамдауна.&lt;/li&gt;
&lt;li&gt;Для конфигурации как сайта целиком, так и отдельных постов используется формат &lt;a href=&quot;http://ru.wikipedia.org/wiki/YAML&quot;&gt;&lt;abbr&gt;YAML&lt;/abbr&gt;&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;имеет смысл изучить его синтаксис.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Вообще, я очень доволен, что для своего сайта выбрал Jekyll&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;хотя для тонкой настройки приходится очень сильно ломать голову над Liquid, в конечном счёте это того стоит.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Правильный курсор на активных элементах</title>
    <link href="http://kizu.ru/issues/cursor-pointer/"/>
    <updated>2013-01-22T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/cursor-pointer</id>
    <content type="html">&lt;h1 id=&quot;правильный-курсор-на-активных-элементах&quot;&gt;Правильный курсор на активных элементах&lt;/h1&gt;
&lt;p&gt;На всех активных элементах по наведению должен меняться курсор. В большинстве случаев это будет &lt;code&gt;cursor: pointer&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Под активными элементами подразумеваются ссылки, кнопки, селекты, лейблы вместе с чекбоксами или радиокнопками и другие аналогичные элементы.&lt;/p&gt;
&lt;p&gt;«Активными» такие элементы должны называться, когда нажатие на подобный элемент вызывает какое-либо действие. Таким образом, ведущий на текущую страницу пункт меню, выбранная радиокнопка или задизейбленные кнопки и ссылки&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не активные элементы, и по наведению на них ничего не должно меняться.&lt;/p&gt;
&lt;p&gt;Мне казалось, что это правило очевидно, однако, оказалось, что очень многие разработчики считают иначе. Внимательно прочитав все точки зрения, я так и не нашёл ни одного серьёзного аргумента против добавления смены курсора по ховеру всем активным элементам.&lt;/p&gt;
&lt;p&gt;В этой статье я сначала распишу свои аргументы за, после чего пройдусь по аргументам против, объясняя, почему же этих аргументов оказалось недостаточно чтобы меня переубедить.&lt;/p&gt;
&lt;h2 id=&quot;преимущества-использования-cursor-pointer&quot;&gt;Преимущества использования &lt;code&gt;cursor:pointer&lt;/code&gt;&lt;/h2&gt;
&lt;h3 id=&quot;обратная-связь&quot;&gt;Обратная связь&lt;/h3&gt;
&lt;p&gt;Лично для меня основная польза от смены курсора&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;обратная связь. В идеале у кастомных элементов должно быть прописано состояние при наведении. Скажем, подсветка фона или смена цвета текста. Но в реальной жизни подобное изменение может или вовсе отсутствовать (дизайнер не нарисовал, а верстальщик не подумал), или быть не особо заметным, не привычным или срабатывать не моментально. Таким образом, обратной связи может или не быть, или она будет не совсем очевидна.&lt;/p&gt;
&lt;p&gt;Изменение же курсора&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всегда моментально и одинаково. Клик, следующий за наведением, будет &lt;em&gt;интуитивным&lt;/em&gt;, тогда как в противном случае мозгу придётся либо сопоставить положение курсора с элементом, либо распознать изменение и трактовать его как наведение на активную область нужного элемента.&lt;/p&gt;
&lt;p&gt;Изменение курсора&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;самая естественная, заметная и понятная обратная связь, которая может быть в интерфейсе.&lt;/p&gt;
&lt;h3 id=&quot;определение-границ-активной-области&quot;&gt;Определение границ активной области&lt;/h3&gt;
&lt;p&gt;Во многих случаях имеет смысл подсказывать пользователям о том, что «вот уже сейчас можно нажать». Часто можно захотеть увеличить кликабельную область для тех или иных элементов, например для какой-нибудь небольшой иконки или пунктов меню, находящимся по краям экрана. В этом случае добавление меняющегося курсора расскажет пользователям о том, когда уже можно нажать на тот или иной элемент.&lt;/p&gt;
&lt;p&gt;В некоторых случаях, когда несколько элементов будут находиться рядом, одной смены курсора не будет достаточно для того, чтобы сказать над каким элементом находится курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в этом случае нужно менять ещё и визуальное отображение соответствующего элемента: менять ему фон, цвет текста или &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; ещё. Но это полезно делать в любом случае.&lt;/p&gt;
&lt;p&gt;Так или иначе, если подсказать пользователям о том, когда можно использовать тот или иной активный элемент, пользователи привыкнут к этому, и в следующий раз при использовании интерфейса им придётся меньше целиться&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;они будет примерно представлять, где находятся границы области, в которую им нужно кликнуть. Ведя в сторону элемента курсор, пользователям достаточно будет кликнуть тогда, когда курсор окажется около элемента. В противном случае, для клика, например, по маленькой иконке или чекбоксу, пользователям придётся каждый раз целиться в меньшую область.&lt;/p&gt;
&lt;p&gt;Кстати, &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; может утверждать то, что область клика должна проходить по визуальным границам элемента, но я могу с этим поспорить, хотя это уже тема для отдельной статьи.&lt;/p&gt;
&lt;h2 id=&quot;аргументы-против-смены-курсора&quot;&gt;Аргументы против смены курсора&lt;/h2&gt;
&lt;p&gt;Как бы я ни искал, я не смог найти достойных аргументов против смены курсора над активными элементами. Большая часть найденных контраргументов можно описать фразой «не нужно ломать пользовательские привычки».&lt;/p&gt;
&lt;p&gt;Начну с того, что рассматривать привычки в качестве аргумента&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;нельзя. Привычка&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это всего лишь знак того, что какой-либо из вариантов был &lt;span class=&quot;nobr&quot;&gt;когда-то&lt;/span&gt;, по &lt;span class=&quot;nobr&quot;&gt;каким-то&lt;/span&gt; причинам, выбран и использовался определённой группой пользователей чаще других. Привычка может быть важна только в контексте того, &lt;em&gt;что&lt;/em&gt; повлечёт её нарушение, будет ли оно деструктивным или всего лишь вызовет небольшой дискомфорт на время отвыкания от неё.&lt;/p&gt;
&lt;p&gt;Дальше надо сразу отметить, что не все привычки полезные. Если идти на поводу у пользователей и давать им только то, к чему они привыкли, то прогресс остановится. Часто у пользователей формируются привычки, которые им только мешают. В качестве довольно яркого примера подобной привычки можно взять подписи к чекбоксам или радиокнопкам. Ленивые разработчики годами забывали связывать текст и соответствующие контролы, &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; чего пользователи обычно даже и не пытаются кликать на текст, тратя своё время и усилия на попытки попасть по маленьким областям контролов. Это отличный пример почему имеет смысл не просто связать контрол с лейблом, но и всеми доступными способами рассказать об этом пользователю.&lt;/p&gt;
&lt;p&gt;Аргументы «по привычке» можно разделить на несколько категорий. Я попробую ответить на наиболее часто используемые аргументы против смены курсора над активными областями.&lt;/p&gt;
&lt;h3 id=&quot;-в-ос-используется-обычный-курсор-&quot;&gt;«В ОС используется обычный курсор»&lt;/h3&gt;
&lt;p&gt;В операционных системах преобладающий курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;обычная стрелка. Курсор над кнопками или другими элементами форм обычно не меняется при наведении. Однако, тут стоит задаться вопросом: а хорошо ли это? Привычно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;да. Но удобно ли? Я бы не отказался от более явной обратной связи во многих десктопных приложениях&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;очень часто разработчики совсем забывают про ховер и приходится догадываться о кликабельной области наугад.&lt;/p&gt;
&lt;p&gt;Кстати, если говорить про десктоп, то стоит упомянуть и такой частую разновидность приложений как игры. В играх курсор почти всегда кастомный, и очень часто именно он меняется при наведении на различные активные области. Можно провести параллели между играми и веб-приложениями&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и, действительно, в веб-приложениях всё чаще можно встретить использование различных специальных курсоров&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;для изменения размеров элементов или для их перетаскивания. Так почему же в этом случае другие активные элементы должны иметь стандартный курсор? Раз специального курсора для «кнопок», «селектов» или «чекбоксов» нет, то к кнопкам подойдёт &lt;code&gt;cursor: pointer&lt;/code&gt;, ранее использовавшийся только для ссылок. Правда, случай с чекбоксами и радиокнопками немного особый: если вокруг них, с подписью, по ховеру меняется фон, то курсор-руку можно и не добавлять. Однако, надо не забыть сменить курсор для сопроводительного текста на &lt;code&gt;default&lt;/code&gt;, ведь курсор-стрелка как раз чаще всего используется для &lt;em&gt;выбора&lt;/em&gt; элементов. Но вот если выбор чекбокса или радиокнопки вызовет &lt;span class=&quot;nobr&quot;&gt;какие-то&lt;/span&gt; изменения на странице (скажем, раскрытие части аккордеона), можно добавить и курсор-руку для того, чтобы сказать пользователям о том, что «сейчас &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; произойдёт».&lt;/p&gt;
&lt;h3 id=&quot;-я-вижу-курсор-считаю-это-ссылкой-&quot;&gt;«Я вижу курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;считаю это ссылкой»&lt;/h3&gt;
&lt;p&gt;Этот аргумент также встречается довольно часто. Раньше, когда веб-приложений ещё не было, все сайты были всего лишь связанные ссылками документы. В приложениях подобных связей почти не было, но в &lt;abbr&gt;HTML&lt;/abbr&gt; соответствующий элемент пришлось добавить, и про него надо было &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; рассказать пользователям. Это сделали добавлением подчёркивания, синего цвета и курсора. При этом, для кнопок и прочих элементов использовались системные контролы, и никакого дополнительного поведения для них не добавили.&lt;/p&gt;
&lt;p&gt;Шли годы, сайты становились всё насыщеннее, на страницах появлялись разные кастомные элементы, в том числе и ссылки, стилизованные под кнопки. И, в большинстве случаев, никто не убирал ссылочное поведение&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и на таких кнопках смена курсора оставалась. Если сейчас посмотреть на большинство подобных кастомных кнопок, сделанных ссылками, на них всех осталось поведение ссылок.&lt;/p&gt;
&lt;h3 id=&quot;-ссылку-можно-открыть-в-новом-окне-и-вызвать-для-не-контекстное-меню-&quot;&gt;«Ссылку можно открыть в новом окне и вызвать для неё контекстное меню»&lt;/h3&gt;
&lt;p&gt;Ну да&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;ссылка это не кнопка, а кнопка&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не ссылка. Но из этого не следует, что поведение кнопок и ссылок по наведению должно отличаться.&lt;/p&gt;
&lt;p&gt;Никто не будет ожидать у кнопок возможностей открыть в новом окне или скопировать адрес. В каждом случае и кнопка, и ссылка будут иметь свой контекст, в котором пользователи могут или ожидать поведения ссылки, или же этого не ожидать. Неважно какой будет в этом случае курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если пользователи увидят курсор в контексте ссылки (а многие дизайнеры сейчас чуть ли не всё рисуют в виде кнопок), они будет обращаться с ней как с ссылкой не задумываясь. И, наоборот, если там будет кнопка, а пользователи не будет ожидать ссылки, всё будет в порядке. Если они захотят прикрепить файл&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;их не смутит, что там, внезапно, курсор-рука. Если они захотят найти &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; через поисковую форму, их не смутит, что там на кнопке изменился курсор. Они просто на неё нажмут. Пользователи могут возмутиться разве что в случаях когда кнопка будет замаскирована под ссылку, не находясь при этом в контексте формы.&lt;/p&gt;
&lt;p&gt;Дальше&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;больше. Очень часто можно встретить ссылки, которые не являются ссылками&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я &lt;span class=&quot;nobr&quot;&gt;почему-то&lt;/span&gt; не слышал возмущений насчёт того, что у подобных псевдо-ссылок меняется по наведению курсор. Различные выпадушки, фильтры, раскрывашки катов, закрывающие крестики, ссылки «отмена»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на многих сайтах можно найти огромное число элементов с изменённым поведением, но везде на подобных элементах остаётся смена курсора по наведению. Почему бы в этом случае не добавить курсор к кнопке или селекту, чем они будет отличаться от всех этих элементов?&lt;/p&gt;
&lt;p&gt;Кстати, вот отличный пример передового сервиса г+:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/issues/cursor-pointer/cursor-pointer.png&quot; alt=&quot;Иллюстрация с различными кликабельными областями&quot;&gt;&lt;/p&gt;
&lt;p&gt;Если хотите, можете попробовать догадаться, какие из отмеченных цифрами элементов изначально являются ссылками, какие нет; у каких есть курсор-поинтер, а у каких&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;нет. И что вообще произойдёт если на тот или иной элемент навести курсор, а потом и нажать. Чуть позже я дам ответ, а пока продолжу.&lt;/p&gt;
&lt;p&gt;Если прямолинейно говорить, что «всё, у чего есть &lt;code&gt;href&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;должно иметь курсор-поинтер, а то, у чего нет&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не должно», то могут возникнуть некрасивые противоречивые случаи: в разных местах визуально кнопкой может быть сделана и ссылка. Если у таких элементов будет различаться поведение по ховеру, то это будет смущать пользователей больше, чем если бы у них было любое, но одинаковое поведение. Другой случай&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;когда рядом находятся и кнопка (&lt;code&gt;button&lt;/code&gt; или &lt;code&gt;input&lt;/code&gt;), и псевдо-ссылка. Например, часто делают попапы с кнопкой «Ок» и ссылкой «отмена». Тут получается так, что у кнопки курсора нет, а у ссылки (которая ссылкой только притворяется)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;курсор есть. Я считаю, что подобные неоднородности только мешают. Но из двух вариантов приведения к общему знаменателю кто выберет отсутствие курсора по ховеру у ссылки?&lt;/p&gt;
&lt;p&gt;Теперь рассмотрим ситуацию с отключённым состоянием. Что, если мы задизейблим &lt;span class=&quot;nobr&quot;&gt;какую-то&lt;/span&gt; кнопку? Она перестанет нажиматься. А если задизейблим ссылку? &lt;span class=&quot;nobr&quot;&gt;По-хорошему&lt;/span&gt;, мы должны будем убрать и курсор. Представим: сначала пользователи сталкиваются с задизейбленной ссылкой без курсора, потом &lt;span class=&quot;nobr&quot;&gt;каким-то&lt;/span&gt; действием её раздизейбливают и видят сменившийся курсор. Потом &lt;span class=&quot;nobr&quot;&gt;где-то&lt;/span&gt; в интерфейсе пользователи видят кастомную серую кнопку без курсора&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;как в этом случае пользователям понять, что она не задизейбленна?&lt;/p&gt;
&lt;p&gt;В итоге можно собрать множество примеров конфликтов кнопок, ссылок, их состояний и поведения. Подобные разногласия будут возникать только в случаях когда курсор меняется строго у элементов-ссылок, если же приравнять смену курсора к любой смене состояния (когда логично было бы менять фон/цвет/&lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; ещё), то этих проблем не будет.&lt;/p&gt;
&lt;p&gt;Вернёмся к иллюстрации из г+:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://kizu.ru/issues/cursor-pointer/cursor-pointer.png&quot; alt=&quot;Иллюстрация с различными кликабельными областями&quot;&gt;&lt;/p&gt;
&lt;p&gt;Итак, список с разъяснениями где какой элемент:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Пермалинк поста, ок. Ссылка есть, по наведению появляются подчёркивание и курсор.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Это вовсе не ссылка, просто текст :)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Это псевдоссылка, ссылки нет, по ховеру&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и подчёркивание и курсор. По клику появится дропдаун.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Аналогично&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;просто контрол, без ссылки, по ховеру меняются цвет и курсор.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Опять не ссылка. В этом сниппете ссылкой являются только заголовок и картинка.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Тут и юзерпик, и имя&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;ссылки. Две, не связанные, но ведущие в одно место, на обеих меняется курсор по ховеру, у текста появляется подчёркивание.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Псевдоссылка&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;без хрефа. Как положено, появляется подчёркивание и меняется курсор.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Казалось бы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;кнопка. По ховеру курсор не меняется, но&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;внезапно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;появляется выпадушка. По ховеру.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ок, допустим, «системный» элемент (хоть и кастомный)&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;кнопка&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не имеет курсора. Но последним элементом тут обозначен чекбокс (который тоже, по той же логике, «системный») с подписью. Но тут, внезапно, хоть &lt;span class=&quot;nobr&quot;&gt;ссылки-то&lt;/span&gt; и нет, курсор по ховеру меняется. Плюс еле заметно подсвечивается чекбокс.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Что тут можно сказать? Никакой последовательности, куча интерфейсных ошибок и отсутствие курсора на кнопке. Выводы можете сделать сами.&lt;/p&gt;
&lt;p&gt;Вообще, очень интересно ходить по разным сервисам различных компаний и подмечать подобные моменты&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;никто не безгрешен и всегда можно найти к чему придраться, но, в конечном счёте, если всё внимательно анализировать, то становится ясно какой элемент для чего предназначен и нужно ли &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; с ним делать по ховеру.&lt;/p&gt;
&lt;h3 id=&quot;-в-спецификации-написано-&quot;&gt;«В спецификации написано…»&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://twitter.com/SelenIT2&quot;&gt;SelenIT&lt;/a&gt; приводит &lt;a href=&quot;http://habrahabr.ru/qa/19097/&quot;&gt;такой аргумент&lt;/a&gt;, что в спецификациях &lt;a href=&quot;http://www.w3.org/TR/CSS21/ui.html#propdef-cursor&quot;&gt;&lt;abbr&gt;CSS&lt;/abbr&gt;2.1&lt;/a&gt; и &lt;a href=&quot;http://www.w3.org/TR/css3-ui/#links-and-status-cursors&quot;&gt;&lt;abbr&gt;CSS&lt;/abbr&gt;3 Basic UI&lt;/a&gt; сказано: «The cursor is a pointer that indicates a link». Кроме того, он ссылается на &lt;a href=&quot;http://lists.w3.org/Archives/Public/public-css-testsuite/2010Jul/0024.html&quot;&gt;сообщение Жерара Тальбо&lt;/a&gt;, в котором он отказывает в изменении одного из тестов к &lt;abbr&gt;CSS&lt;/abbr&gt; 2.1. Однако, вряд ли подобное сообщение можно как-либо трактовать в пользу отсутствия курсора у кнопок. Контекст сообщения&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;strong&gt;тесты к спецификациям&lt;/strong&gt;, и если в спецификации написано о том, что «курсор-поинтер указывает на ссылку», то это должно и &lt;strong&gt;в тестах&lt;/strong&gt; значить только это.&lt;/p&gt;
&lt;p&gt;В спецификации не сказано, что этот курсор &lt;em&gt;не может&lt;/em&gt; использоваться для чего-либо ещё. Указано, скорее, его применение по умолчанию. На месте разработчиков спецификаций я бы изменил этот момент на «The cursor is a pointer that indicates an element that can be clicked» (по аналогии с тем, что предлагалось в тесте) или аналогичное, более общее, высказывание.&lt;/p&gt;
&lt;p&gt;Это место в спецификации так и тянется &lt;a href=&quot;http://www.w3.org/TR/WD-CSS2-971104/ui.html#propdef-cursor&quot;&gt;как минимум с 1997 года&lt;/a&gt;, но веб с того времени сильно изменился и уже нельзя говорить о том, что «курсор-указатель указывает на ссылку», фактически его уже очень часто используют и для многих других элементов.&lt;/p&gt;
&lt;h3 id=&quot;-мерцание-&quot;&gt;«Мерцание»&lt;/h3&gt;
&lt;p&gt;Мне тут подсказали ещё один аргумент: если на странице много активных элементов, то при перемещении курсор будет постоянно «мерцать», меняя состояние с обычного на поинтер.&lt;/p&gt;
&lt;p&gt;Но такой аргумент&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не проблема курсора на активных элементах. «Мерцание» курсора будет всего лишь симптомом, а проблемы могут быть следующими:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Активные элементы могут быть расположены не вплотную друг к другу. В этом случае, &lt;span class=&quot;nobr&quot;&gt;во-первых&lt;/span&gt;, пользователям будет сложнее попасть по нужному элементу, &lt;span class=&quot;nobr&quot;&gt;во-вторых&lt;/span&gt;, «мерцание», скорее всего, будет проявляться не только в смене курсора, но и в смене фона, текста, или &lt;span class=&quot;nobr&quot;&gt;чего-то&lt;/span&gt; ещё. &lt;span class=&quot;nobr&quot;&gt;По-хорошему&lt;/span&gt;, все однородные активные области элементов должны находиться как можно ближе друг к другу.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Другая, более редкая, проблема&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;захламлённость интерфейса. Если у вас вся страница утыкана всевозможными активными элементами, то это значит, что пора задуматься все ли они тут нужны прямо сейчас, и не стоит ли &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; упростить или упорядочить.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;итого&quot;&gt;Итого&lt;/h2&gt;
&lt;p&gt;Если рассматривать идеальную ситуацию, то каждый элемент должен &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; меняться по ховеру, подсказывая, что с ним можно взаимодействовать. Но даже в этом случае нужно менять по ховеру и курсор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;иначе иногда могут возникнуть неоднозначности в интерфейсе. Смены курсора, при этом, часто будет достаточно для того, чтобы хоть немного, но улучшить интерфейс&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если дизайнер нарисовал &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; контрол, который выглядит не особо кликабельным, то добавление смены курсора немного этот момент исправит (но лучше после этого всё равно написать об этой проблеме дизайнерам, чтобы они нарисовал более понятное состояние).&lt;/p&gt;
&lt;p&gt;Ну а &lt;span class=&quot;nobr&quot;&gt;каких-то&lt;/span&gt; критичных недостатков у добавления курсора по ховеру просто нет&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;даже если &lt;span class=&quot;nobr&quot;&gt;каких-то&lt;/span&gt; пользователей это может немного смущать&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;бóльшему числу пользователей это облегчит жизнь.&lt;/p&gt;
&lt;p&gt;Да, конечно, если у &lt;span class=&quot;nobr&quot;&gt;кого-то&lt;/span&gt; есть чем дополнить или опровергнуть часть высказанных мной утверждений&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;конкретные цифры, замеры и аргументы приветствуются. Все места, где я пишу о том, что «&lt;span class=&quot;nobr&quot;&gt;кому-то&lt;/span&gt; это облегчит жизнь»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;чисто умозрительные и не подтвеждённые цифрами. Но всё говорит за то, что так оно и есть&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;так что спорить с этим можно только после A/B-тестирования и сравнения его результатов.&lt;/p&gt;
&lt;h2 id=&quot;ссылки&quot;&gt;Ссылки&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://css-tricks.com/snippets/css/give-clickable-elements-a-pointer-cursor/&quot;&gt;Заметка Криса Койера о том, как добавить ссылки кликабельным элементам.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; В комментариях приводятся всё те же доводы про привычки и операционные системы, плюс консервативные, не подкреплённые аргументами взгляды на то, что только ссылки должны иметь курсор-поинтер.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://www.usabilitypost.com/2009/10/26/mouse-cursor-affordance/&quot;&gt;Заметка Дмитрия Фадеева про соответствие курсора&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; В этой заметке Дмитрий приходит к заключению «Если тип курсора неверный, то нужно задавать его, используя &lt;abbr&gt;CSS&lt;/abbr&gt;-свойства &lt;code&gt;cursor&lt;/code&gt;», приводя в пример кастомные кнопки и плейсхолдеры для инпутов.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;http://pepelsbey.net/pres/push-it/&quot;&gt;Слайды доклада Вадима Макеева «Жми сюда!»&lt;/a&gt;&lt;/p&gt;
&lt;p&gt; Доклад больше о том, что функциональность элемента должна отражаться в используемых html-тегах, но в одном месте Вадим &lt;a href=&quot;http://pepelsbey.net/pres/push-it/?full#ButtonDesc&quot;&gt;пишет&lt;/a&gt; про кнопку: «Делать лапу &lt;code&gt;cursor:pointer&lt;/code&gt; совсем не нужно» и не приводит никаких аргументов в пользу этого утверждения. Надеюсь, прочитав эту статью, Вадим или изменит свой взгляд по этому вопросу, или напишет аргументы в пользу своего высказывания.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;

    </content>
  </entry>
  <entry>
    <title>Перезапуск kizu.ru</title>
    <link href="http://kizu.ru/issues/restart/"/>
    <updated>2013-01-17T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/restart</id>
    <content type="html">&lt;h1 id=&quot;перезапуск-kizu-ru&quot;&gt;Перезапуск kizu.ru&lt;/h1&gt;
&lt;p&gt;Привет! Я очень долго шёл к этому, и вот оно случилось&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я перезапускаю свой сайт. Мне сложно сосчитать, какая по счёту это версия&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;кажется, что их было уже около десяти.&lt;/p&gt;
&lt;p&gt;Каково главное отличие этой версии? Она сырая! Она дичайше, ужасающе непроработанная, корявая, сломанная. Не смотрите в исходники, правда. И это не терновый куст&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;там сейчас взаправду всё плохо. Почему? Потому что я решил бороться с перфекционизмом. Раньше я вылизывал, вытачивал и отшлифовывал свой сайт и его код; предъявлял сайт миру только когда меня всё устраивало. Сейчас же меня почти ничего не устраивает. И это отлично!&lt;/p&gt;
&lt;h2 id=&quot;задача&quot;&gt;Задача&lt;/h2&gt;
&lt;p&gt;Итак. Почему же я вообще переделал сайт, почему считаю, что даже в текущем недоделанном виде он всё равно лучше старой версии?&lt;/p&gt;
&lt;p&gt;Ответ прост. Я поставил перед собой задачу сделать сайт таким, чтобы &lt;strong&gt;мне было просто его обновлять&lt;/strong&gt;. Предыдущие версии сайта, какой бы движок под ними не лежал, не были для меня удобны, и это стало для меня непреодолимым барьером. Мне было лень делать кучу лишних действий для того, чтобы добавить новую страницу на сайт или хотя бы &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; обновить. Хотя хотелось писать, много писать. У меня огромное число идей для постов, для проектов, и для всего остального, что я хотел бы опубликовать.&lt;/p&gt;
&lt;p&gt;К счастью, путём проб и ошибок, прототипов и переделок с нуля, я нашёл решение, которое позволит мне заниматься сайтом в удовольствие. Вот оно:&lt;/p&gt;
&lt;h2 id=&quot;github-amp-jekyll&quot;&gt;GitHub &amp;amp; Jekyll&lt;/h2&gt;
&lt;p&gt;Я могу сложить оду Гитхабу&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;восхваления тому, что делают эти ребята достойны отдельной серии статей. Но я сейчас остановлюсь на главном.&lt;/p&gt;
&lt;p&gt;Гитхаб предосталяет возможность хостинга статичных сайтов&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;http://pages.github.com&quot;&gt;GitHub Pages&lt;/a&gt;. Можно взять свой репозиторий, залить в него статичные файлы и, если всё сделать правильно, можно будет посмотреть на свой статичный сайт либо на адресах Гитхаба, либо на своём домене, настроив соответствующим образом &lt;abbr&gt;DNS&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;Счастье не было бы полным, если бы хостинг был совсем статичным. Ребята из Гитхаба добавили возможность внести чуть-чуть логики и автогенерации&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;генератор статики &lt;a href=&quot;https://github.com/mojombo/jekyll#readme&quot;&gt;Jekyll&lt;/a&gt;. Это единственный способ сделать &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; сложное на базе GitHub Pages (помимо чисто клиентских решений и предгенерённой заранее статики), но при этом оно очень хорошее и вполне рабочее.&lt;/p&gt;
&lt;p&gt;Смысл в том, что на базе Jekyll можно очень просто поднять обычный блог&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;там есть всё, что для этого нужно: категории, теги, пермалинки, генерация фидов и прочее, и прочее. Так как это &lt;em&gt;генератор&lt;/em&gt; статики, то каждая страница генерируется лишь один раз&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;потому нагрузка на сервер будет минимальной&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в итоге все пользователи будут получать обычный статичный html. Поэтому многие авторы выбирают именно Гитхаб в качестве площадки для хостинга своих проектов, в том числе и с большим числом посещений.&lt;/p&gt;
&lt;p&gt;Эту платформу выбрал и я. У меня было очень много всяких требований&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я буду вести блог на двух языках, у меня есть множество экспериментов, которые надо в том или ином виде отображать на страницах, а также есть куча идей о том, что же ещё можно добавить на сайт. В Jekyll используется шаблонизатор &lt;a href=&quot;http://liquidmarkup.org&quot;&gt;Liquid&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;он позиционируется как «безопасный», поэтому (видимо) он очень простой, и с помощью него сложно сделать &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; заковыристое. Но&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;реально. Я активно ковыряю этот движок и уже сделал довольно много интересных улучшений для блога&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;об этом точно будет серия статей, а может, я когда-нибудь допилю это дело и до самостоятельного проекта, с помощью которого любой желающий сможет завести себе простой, но мощный и удобный блог. Так что ожидайте обновлений&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я, правда, уделю много внимания этой связке&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;GitHub+Jekyll+Liquid.&lt;/p&gt;
&lt;h2 id=&quot;prose-io&quot;&gt;Prose.io&lt;/h2&gt;
&lt;p&gt;Так как я использую Гитхабовский Jekyll, мне получается достаточным всего лишь запушить изменения в соответствующий репозиторий сайта&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и весь проект пересоберётся и перевыложится. А так как у Гитхаба есть отличный &lt;abbr&gt;API&lt;/abbr&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;существуют и сторонние сервисы, которые упрощают всё ещё больше. В &lt;span class=&quot;nobr&quot;&gt;общем-то&lt;/span&gt;, сейчас можно создавать пост только через веб-интерфейс: теперь для ведения блога мне не нужно ничего клонировать, достаточно лишь зайти на Гитхаб или &lt;a href=&quot;http://prose.io&quot;&gt;prose.io&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и там всё будет очень просто и удобно. Да, я об этом тоже напишу как минимум одну статью.&lt;/p&gt;
&lt;h2 id=&quot;-напишу-статью-&quot;&gt;«Напишу статью»&lt;/h2&gt;
&lt;p&gt;Вы заметили, что я уже много раз упомянул, что я собираюсь написать кучу статей? Я себе пообещал в новом году, после запуска сайта, писать не реже раза в неделю. Но пока что всё выглядит так, что обновления на сайте буду случаться гораздо, гораздо чаще&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;за время простоя сайта накопилось огромное число идей и мыслей.&lt;/p&gt;
&lt;p&gt;Так что&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;ждите! Я постараюсь чередовать статьи про то, как я создавал сайт (с подробностями по технологиям, решениям и дизайну) с более общими статьями&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на темы, которые я обещал осветить в твиттерах, либо просто о том, что наболело.&lt;/p&gt;
&lt;p&gt;Я пока не решил какой же в итоге будет формат блога/сайта, всё ещё может не раз измениться (скажем, я пока не уверен, что смогу поддерживать в нормальном темпе и в одинаковом качестве публикацию статей на обоих языках), но я точно обещаю, что скучно не будет.&lt;/p&gt;
&lt;h2 id=&quot;в-рстка-и-дизайн&quot;&gt;Вёрстка и дизайн&lt;/h2&gt;
&lt;p&gt;Как я уже сказал&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сейчас сделан самый минимум, позволяющий мне просто взять и создать новый пост, либо поправить старый. Остальное&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не закончено, хоть вешай гифку с землекопом.&lt;/p&gt;
&lt;p&gt;Вёрстка&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на стадии грязного-грязного прототипа, там нет почти ничего интересного. Ну, точнее есть, но оно погребено под горами мусора. Неэффективные селекторы, никакого кодстайла (тем более всё генерится из Стайлуса), куча повторений и лишних стилей&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в общем, не читайте мой &lt;abbr&gt;CSS&lt;/abbr&gt;. Всё, что будет принимать завершённую форму, я буду описывать в новых статьях, так что можно просто &lt;a href=&quot;feed://feeds.feedburner.com/kizu&quot;&gt;подписаться на Фид&lt;/a&gt;, либо &lt;a href=&quot;https://twitter.com/ki_zu&quot;&gt;зафолловить меня в твиттере&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Дизайн, с другой стороны, почти устаканился. Наверняка многое поменяется, но основные концепции уже можно увидеть.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Шрифт! Ему я уделил больше всего внимания. Его много: я выбрал максимально комфортный для себя размер шрифта. Если &lt;span class=&quot;nobr&quot;&gt;кому-то&lt;/span&gt; он покажется большим&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;всегда можно откинуться на спинку табуретки, либо уменьшить размер шрифта средствами браузера. Большой шрифт&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;лучше маленького.&lt;/p&gt;
&lt;p&gt; Мне, внезапно, захотелось поставить шрифт с засечками. Настолько, что я в итоге долго искал какой же конкретно шрифт мне подойдёт. К сожалению, бесплатных кириллических шрифтов очень мало, просмотрев все доступные варианты, я в итоге пошёл смотреть на платные. Их уже чуть больше, и я остановился на шрифте работы &lt;a href=&quot;http://www.letterhead.ru&quot;&gt;студии Letterhead&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;http://www.letterhead.ru/Fonts/21cent.html&quot;&gt;«21 cent»&lt;/a&gt;. Не знаю чем, но он мне приглянулся. Настолько, что я купил основные начертания,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;он у меня, в итоге, лицензирован. Купил у &lt;a href=&quot;http://www.myfonts.com/fonts/letterheadrussia/21-cent/&quot;&gt;myfonts.net&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;у них получается не так дорого и единоразово (если не считать лимиты на просмотры, которые можно за деньги увеличивать навсегда).&lt;/p&gt;
&lt;p&gt; Вообще, со шрифтами я намучился. Догадайтесь, что я сейчас скажу? Про это когда-нибудь будет пост!&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Минималистичность. Как я уже написал в твиттере&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сложно сделать минималистичный текстовый сайт так, чтобы он в итоге не оказался копией &lt;a href=&quot;http://informationarchitects.net&quot;&gt;сайта iA&lt;/a&gt;. У меня несколько итераций подходили опасно близко к тому, что получилось у них. В итоге я постарался остановиться и подумать&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;что же нужно сделать, чтобы было и просто, и хорошо, и результат можно было хоть &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; отличить от аналогичных сайтов, которые заполонили интернеты в последнее время? Надеюсь, у меня получилось. Конечно, ещё не всё доработано&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;скажем, списки постов по разделам совсем не готовы, многие места будут дорабатываться и улучшаться, но в целом всё будет выглядеть примерно так, как сейчас.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Визуальные решения&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;то, что отличает мой сайт от остальных&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;можно вынести в отдельный пункт. Я про это всё ещё напишу (да!), но если кратко: посмотрите на цветовую гамму, я постарался избавиться от чистых чёрных и серых цветов, на шапку и футер постов (приём не новый, но пока ещё не сильно распространённый) и на ссылки. Да, не подчёркнутые, пока на них не наведёшь курсор. Но&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;явно отличимые, с посещённым состоянием и одной маленькой, но приятной деталью, связанной с подчёркиванием :)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;open-source&quot;&gt;Open Source&lt;/h2&gt;
&lt;p&gt;Несмотря на то, что сайт внутри сырой, я выкладываю &lt;a href=&quot;https://github.com/kizu/kizu.github.com/&quot;&gt;его исходники&lt;/a&gt;. Помимо утилитарной необходимости, описанной выше в «Задаче», подобное решение даёт возможность использовать все прелести опенсорса&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;кто угодно может пойти и поправить ошибки у меня на сайте или в любой статье. Более того, в конце каждой статьи я сейчас размещаю две ссылки&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;на добавление нового issue на Гитхабе (такой аналог комментирования), и ссылку на исходник в prose.io&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если залогиниться туда через Гитхаб, то можно будет очень просто редактировать любой пост в блоге.&lt;/p&gt;
&lt;p&gt;В итоге&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;нашли ошибку/опечатку? В каждой статье есть простой способ либо об этом сообщить, либо сразу же и исправить. Для обоих случаев количество необходимых действий&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;минимально, а профит будет для всех: я получу исправленные статьи, а вы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;плюс в карму, коммиты/issue в репозитории и благодарность от меня.&lt;/p&gt;
&lt;p&gt;Да, обо всей этой затее с issues и prose.io будет точно больше одного поста.&lt;/p&gt;
&lt;h2 id=&quot;резюмируя-или-tl-dr&quot;&gt;Резюмируя, или tl;dr&lt;/h2&gt;
&lt;p&gt;У вас перед глазами&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;первый пост из многих грядущих в обрамлении нового сайта. Сайт пока сырой, но дальше&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;больше. Всё будет становиться только лучше, и о процессе я буду или писать в блог, или хотя бы уведомлять в твиттере.&lt;/p&gt;
&lt;p&gt;Спасибо, что дочитали до конца (или доскроллили). Следите за обновлениями и, если что, не стесняйтесь посылать пулл-реквесты с исправлением моих ошибок.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>bemto</title>
    <link href="http://kizu.ru/projects/bemto/"/>
    <updated>2012-07-02T00:00:00+03:00</updated>
    <id>http://kizu.ru/projects/bemto</id>
    <content type="html">&lt;h1 id=&quot;bemto&quot;&gt;bemto&lt;/h1&gt;
&lt;p&gt;Привет. Вот то, над чем я в последнее время немного работаю&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;a href=&quot;https://github.com/kizu/bemto&quot;&gt;bemto&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;набор миксинов для &lt;a href=&quot;https://github.com/visionmedia/jade&quot;&gt;Jade&lt;/a&gt;, позволяющих легко и просто писать код в нотации &lt;a href=&quot;http://bem.github.com/bem-method/pages/beginning/beginning.en.html&quot;&gt;&lt;abbr&gt;БЭМ&lt;/abbr&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Я очень люблю писать код, следуя &lt;abbr&gt;БЭМ&lt;/abbr&gt;, а также мне очень нравится Jade, так что я подумал, что имеет смысл добавить немного &lt;abbr&gt;БЭМ&lt;/abbr&gt;а в Jade. И, надеюсь, что &lt;span class=&quot;nobr&quot;&gt;кому-то&lt;/span&gt; это тоже может пригодиться.&lt;/p&gt;
&lt;p&gt;Если вы ещё не читали &lt;a href=&quot;http://coding.smashingmagazine.com/2012/04/16/a-new-front-end-methodology-bem/&quot;&gt;статью про &lt;abbr&gt;БЭМ&lt;/abbr&gt; в Smashing Magazine&lt;/a&gt; или &lt;a href=&quot;http://nicolasgallagher.com/about-html-semantics-front-end-architecture/&quot;&gt;статью Николаса Галлахера про архитектуру фронтенда&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сейчас самое время это сделать. Эти статьи описывают несколько вариантов того, как можно писать хороший расширяемый и поддерживаемый код.&lt;/p&gt;
&lt;p&gt;Jade же&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;шаблонизатор, во многом похожий на Haml за авторством &lt;a href=&quot;http://tjholowaychuk.com/&quot;&gt;ТиДжея Головайчука&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;В общем, идите и прочитайте &lt;a href=&quot;https://github.com/kizu/bemto#readme&quot;&gt;документацию&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;там всё описано в подробностях. И обратите внимание на &lt;a href=&quot;https://github.com/kizu/bemto/blob/master/README.md#using-for-building-complex-mixins&quot;&gt;подробный юзкейс&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;он показывает как можно писать простые реиспользуемые блоки с bemto.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Легенды и заголовки</title>
    <link href="http://kizu.ru/fun/legends-and-headings/"/>
    <updated>2012-04-27T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/legends-and-headings</id>
    <content type="html">&lt;h1 id=&quot;легенды-и-заголовки&quot;&gt;Легенды и заголовки&lt;/h1&gt;
&lt;p&gt;Однажды в декабре я решил посмотреть, что же можно сделать с элементом &lt;code&gt;legend&lt;/code&gt;. Я хотел подвигать его внутри родительского филдсета, но мне не хотелось целиком сбивать стили: у филдсета с легендой есть уникальное поведение&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;под легенду резервируется пустое пространство.&lt;/p&gt;
&lt;p&gt;В итоге, путём пары хаков, я сделал несколько вариантов: с легендой справа, центрированной и даже с двумя легендами с разных сторон.&lt;/p&gt;
&lt;p&gt;Проще всего оказалось с первым вариантом: чтобы спозиционировать легенду вправо достаточно применить на родителе &lt;code&gt;direction: rtl&lt;/code&gt;, ну и потом не забыть для детей восстановить его значение в &lt;code&gt;ltr&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для центрированного и двойного вариантов пришлось использовать дополнительные элементы и растягивать легенду на всю ширину, эмулируя границу дополнительными элементами. Можно было бы использовать вместо некоторых из них псевдоэлементы, но в &lt;span class=&quot;nobr&quot;&gt;каких-то&lt;/span&gt; браузерах были с этим проблемы в данном контексте, так что я решил просто добавить пару лишних блоков. В итоге получилось &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; такое:&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/legends-and-headings/#Demo_legends&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;А вот более простой пример с заголовками и линиями по краям. Основной смысл заключается в использовании только одного элемента и то, что границы тут достаточно «честные»&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если под заголовок положить фон, то он будет нормально просвечивать. Тогда как в похожих методах, которые я видел, обычно применяют перекрытие центральным блоком линии под ним.&lt;/p&gt;
&lt;p&gt;К сожалению, для многострочных заголовков всё равно нужен лишний блок, но и в этом случае «честность» просветов остаётся. Ну и всё довольно хорошо деградирует для старых браузеров. Вот дабблет этого примера:&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/legends-and-headings/#Demo_headings&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Тени скролла</title>
    <link href="http://kizu.ru/fun/shadowscroll/"/>
    <updated>2012-04-21T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/shadowscroll</id>
    <content type="html">&lt;h1 id=&quot;тени-скролла&quot;&gt;Тени скролла&lt;/h1&gt;
&lt;p&gt;Сверстал тут довольно старый эффект, но вот только на чистом &lt;abbr&gt;CSS&lt;/abbr&gt;.&lt;/p&gt;
&lt;p&gt;Изначально делал с враппером и двумя лишними псевдоэлементами и box-shadow, но потом чуть подумал и реализовал только на одном блоке&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;с помощью радиальных градиентов.&lt;/p&gt;
&lt;p&gt;У метода есть некоторое число ограничений: фон должен быть сплошным (хотя, если взять &lt;code&gt;background-attachment: fixed…&lt;/code&gt;), блок должен иметь определённое позиционирование, но в остальном&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;метод довольно ударопрочный. Если делать не через &lt;abbr&gt;CSS&lt;/abbr&gt;-градиенты, а используя обычные изображения, то метод должен будет заработать и в IE, но я не проверял.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update:&lt;/strong&gt; &lt;a href=&quot;https://twitter.com/leaverou&quot;&gt;Lea Verou&lt;/a&gt; обновила мой эксперимент использовав &lt;code&gt;background-attachment: local&lt;/code&gt;. &lt;a href=&quot;http://lea.verou.me/2012/04/background-attachment-local/&quot;&gt;Подробности можно прочитать в её посте&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/shadowscroll/#Demo_shadowscroll&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Многосторонний ховер</title>
    <link href="http://kizu.ru/fun/multi-directional-hover/"/>
    <updated>2012-03-19T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/multi-directional-hover</id>
    <content type="html">&lt;h1 id=&quot;многосторонний-ховер&quot;&gt;Многосторонний ховер&lt;/h1&gt;
&lt;p&gt;Попробуйте понаводить курсор на этот блок с разных сторон&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/multi-directional-hover/#Demo_hovers&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Несколько мелочей интерфейса приложения Path</title>
    <link href="http://kizu.ru/issues/path-ui/"/>
    <updated>2011-12-05T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/path-ui</id>
    <content type="html">&lt;h1 id=&quot;несколько-мелочей-интерфейса-приложения-path&quot;&gt;Несколько мелочей интерфейса приложения Path&lt;/h1&gt;
&lt;p&gt;&lt;small&gt;Небольшое вступление. Я решил попробовать новый для себя жанр&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;обычно я не высказываю свои мысли по поводу тех или иных интерфейсов, однако, всегда их анализирую и тщательно разбираю. На этот раз я решил сделать исключение: написать об этом печатный текст, т.к. в Path оказалось довольно много вкусных решений.&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Итак, &lt;a href=&quot;https://path.com/&quot;&gt;Path&lt;/a&gt;. Это новая социальная сеть, в первую очередь ориентированная на мобильные устройства: на самом деле пока что она доступна только в версиях &lt;a href=&quot;http://itunes.apple.com/app/path/id403639508&quot;&gt;для айфона&lt;/a&gt; и &lt;a href=&quot;https://market.android.com/details?id=com.path&amp;amp;hl=en&quot;&gt;для андроидов&lt;/a&gt;. Я вчера поставил версию для айфона и хочу рассказать о том, что я там нашёл такого хорошего. Интерфейс оставляет самое приятное впечатление, он не без недостатков, но для старта он очень и очень не плох. Я не буду подробно всё описывать, опишу лишь несколько моментов, которые не оставили меня равнодушным.&lt;/p&gt;
&lt;h2 id=&quot;персонализация&quot;&gt;Персонализация&lt;/h2&gt;
&lt;p&gt;&lt;img class=&quot;Sidepicture&quot; src=&quot;http://i.kizu.ru/misc/path.jpg&quot; alt=&quot;Path&quot;&gt;&lt;/p&gt;
&lt;p&gt;У «больших» социальных сетей и блогохостингов возможность ставить оформление по вкусу обычно остаётся прерогативой браузерной версии. В мобильных клиентах в подавляющем большинстве случаев все те настройки оформления, выставленные на сайте не играют никакой роли.&lt;/p&gt;
&lt;p&gt;В Path, разрабатывая мобильную версию прежде всего, довольно удачно обошли этот момент: сделали возможность поставить в «шапке» твоего таймлайна любую фотографию. При этом довольно удачно решили вопрос её размера: в ленте «что нового» показывается лишь часть её, а чтобы рассмотреть её повнимательнее, нужно оттянуть страницу вниз. А на странице пользователя эта картинка видна целиком.&lt;/p&gt;
&lt;p&gt;Подозреваю, возможность таким образом облагородить страницу, на которую ты будешь чаще всего смотреть в приложении может привязать пользователя. Ему будет уютно запускать приложение и пользоваться им, тогда как все остальные мобильные клиенты очень сухие и безликие. Да и смотреть/читать профили других людей будет тоже приятнее.&lt;/p&gt;
&lt;h2 id=&quot;-лайки-&quot;&gt;«Лайки»&lt;/h2&gt;
&lt;p&gt;Говоря об эмоциях, надо упомянуть о том, как в Path реализовали такую модную функциональность как лайки. В интернетах встречается два варианта оценочной функциональности:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;восторженно-положительная: пресловутый «like», «мне понравилось», большой палец вверх и т.д.;&lt;/li&gt;
&lt;li&gt;нейтрально-отстранённый: «+1», «оценить», звёздочки-флажки.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Первый вариант плох тем, что он не всегда уместен: «лайк» часто используется в качестве возможности поделиться тем или иным сообщением с друзьями или же отложить запись на потом. И в случае когда запись имеет негативную окраску (катастрофы, смерти, всё такое), то бывает довольно странно видеть подпись «сорока двум пользователям это понравилось».&lt;/p&gt;
&lt;p&gt;Второй вариант плох тем, что он чаще всего слишком нейтральный. Да, мы получаем возможность оценивать записи с любым значением, но, вместе с тем, мы и теряем возможность эмоционально реагировать:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;— У меня родился ребёнок!&lt;/p&gt;
&lt;p&gt;— Ну, ок, оценил.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;В Path пошли несколько иным путём: дали возможность оценивать записи при помощи смайликов:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://i.kizu.ru/misc/path-bubble.jpg&quot; alt=&quot;Path-bubble&quot;&gt;&lt;/p&gt;
&lt;p&gt;Хотя таким образом возможность оценить отходит на один тап дальше, но получаемая выгода&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;огромна. Есть всего пять вариантов, но их хватит на все случаи жизни. А если не хватит: остаётся возможность написать комментарий прямо из попапа со смайликами. Кстати, в этом попапе ещё и показываются пользователи, которые увидели эту запись: интересный элемент, который позволяет не забывать о том, что ты не пишешь в пустоту, а для реальных людей.&lt;/p&gt;
&lt;h2 id=&quot;закрытость&quot;&gt;Закрытость&lt;/h2&gt;
&lt;p&gt;Path&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не открытая социальная сеть, по крайней мере&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;пока. Ты не можешь увидеть ленты пользователей, которые тебя не добавили в друзья, всё, что ты видишь: их имена, юзерпики и картинки с обложки. Вместе с тем, что внутри многие действия очень открыты: видны все действия, видно когда &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; заходит к тебе на страницу и т.д., в этой социальной сети, скорее всего, большая часть «друзей» будут составлять близкие знакомые и коллеги. Path&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;не блог и не притворяется им, он пытается создать максимально приятную и уютную атмосферу для общения. Возможно, &lt;span class=&quot;nobr&quot;&gt;когда-то&lt;/span&gt; это изменится, но я не уверен, что здесь подобные изменения нужны: это достаточно удачная ниша, которую Path вполне может попробовать занять.&lt;/p&gt;
&lt;h2 id=&quot;спрятанные-возможности&quot;&gt;Спрятанные возможности&lt;/h2&gt;
&lt;p&gt;У Path получилось сделать довольно удачное сочетание простоты и чистоты интерфейса ленты и возможных действий с ней. По умолчанию на странице ленты есть заголовок с двумя иконками, шапка с картинкой и, собственно, лента. В ленте каждая запись состоит из аватарки, типа поста (на линии, похожей на то, что показывали в картинках к новому интерфейсу фейсбука), тела поста и кнопки-иконки со смайликом и цифрой + пара комментариев под телом поста. Все действия с постом расположены в попапе, появляющемся при тапе по кнопке смайлика: там и оценка, и возможность комментировать, и удаление записи. Тап по аватаркам пользователей перенесёт на их страницу, тап по телу сообщения вызовет контекстное действие: откроет интерфейс чата (с возможностью общения в реальном времени: с уведомлением о процессе написания сообщения и т.д), покажет страницу геометки, страницы пользователей, с которыми подружились, а если есть несколько возможностей, то предложит выбрать одну из них.&lt;/p&gt;
&lt;p&gt;В итоге получаем довольно обширный функционал, который довольно логично спрятан за тапами по различным блокам с контентов: интерфейс почти не замусоривается ненужными контролами. Кстати, тут надо заметить, что всё это реализовано очень гладко: раскиданные тут и там активные области совсем не мешают слайдить ленту, в отличии от множества иных приложений.&lt;/p&gt;
&lt;p&gt;Ах да, забыл про бабл с датой-временем. Удивительно, но этот всплывающий элемент, показывающий на то, к какому моменту времени относится текущее положение ленты, не раздражает. Он достаточно информативный (показывается время, и день недели), но и места совсем не занимает. И &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; привязанности к скроллбару он вряд ли когда-либо будет заслонять &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; лишнее.&lt;/p&gt;
&lt;h2 id=&quot;расширенная-функциональность-с-подсказкой&quot;&gt;Расширенная функциональность с подсказкой&lt;/h2&gt;
&lt;p&gt;И последнее, о чём я сегодня упомяну: о том, как работают две иконки в шапке страницы. Чаще всего там их две: вызов системного меню и меню друзей. Про сами меню я ничего не буду рассказывать: остановлюсь о том, как реализован переход к этим двум страницам. Нажимая на соответствующие кнопки можно увидеть как страница «отъезжает» в сторону, и, помимо визуальной метафоры, это ещё и подсказывает о наличии дополнительной возможности в интерфейсе: возможности вызывать те же страницы не только нажатием на кнопки, но и соответствующими жестами-слайдами. Действительно: достаточно повторить движение, которое нам показали при нажатии на кнопки и сразу становится ясно, что жестом пользоваться удобнее. И радует, что &lt;span class=&quot;nobr&quot;&gt;кнопки-то&lt;/span&gt; всё-таки остаются: хороший компромисс между наличием функции и донесением о её существовании пользователю.&lt;/p&gt;
&lt;h2 id=&quot;-&quot;&gt;…&lt;/h2&gt;
&lt;p&gt;Про недостатки я ничего не буду говорить, они есть. Но я рекомендую &lt;a href=&quot;https://path.com/&quot;&gt;посмотреть и пощупать&lt;/a&gt; это приложение всем, интересующимся интерфейсами: всё очень приятно и с толком сделано. С акцентом на мобильном приложении авторы Path смогли принести тот самый свежий опыт общения с интерфейсом, которого так не хватает во вторичных приложениях-спутниках больших социальных сетей.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Честные полигоны на CSS3</title>
    <link href="http://kizu.ru/fun/polygons/"/>
    <updated>2011-09-18T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/polygons</id>
    <content type="html">&lt;h1 id=&quot;честные-полигоны-на-css3&quot;&gt;Честные полигоны на &lt;abbr&gt;CSS&lt;/abbr&gt;3&lt;/h1&gt;
&lt;p&gt;Используя вращение при помощи трансформов, &lt;code&gt;overflow:hidden&lt;/code&gt; и связку &lt;code&gt;visibility:hidden&lt;/code&gt; для врапперов и &lt;code&gt;visibility:visible&lt;/code&gt; у последнего ребёнка, можно делать любые выпуклые маски, честно кликабельные по всей своей площади.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/polygons/#Demo_polygons&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Я даже создал для этого дела &lt;a href=&quot;https://github.com/kizu/Polygons&quot;&gt;проектик на гитхабе&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;присылайте пулл реквесты с новыми формами :)&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Концепция быстрой записи БЭМ (bemto)</title>
    <link href="http://kizu.ru/issues/bemto-concept/"/>
    <updated>2011-06-23T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/bemto-concept</id>
    <content type="html">&lt;h1 id=&quot;концепция-быстрой-записи-бэм-bemto-&quot;&gt;Концепция быстрой записи &lt;abbr&gt;БЭМ&lt;/abbr&gt; (bemto)&lt;/h1&gt;
&lt;p&gt;Такая идея!&lt;/p&gt;
&lt;p&gt;Сначала я хотел сделать работающий прототип, но потом подумал, что имеет смысл, хотя бы для себя, записать концепцию «на бумаге».&lt;/p&gt;
&lt;p&gt;Итак. Что такое &lt;a href=&quot;http://clubs.ya.ru/bem/&quot;&gt;&lt;abbr&gt;БЭМ&lt;/abbr&gt;&lt;/a&gt; вы, надеюсь, уже знаете.&lt;/p&gt;
&lt;p&gt;Сам по себе &lt;abbr&gt;БЭМ&lt;/abbr&gt; таков, что имена классов для него раздуваются, порой, донельзя. При этом, идея вполне поддаётся автоматизации, так что в клубе по ссылке выше можно и об этом почитать. Однако, я всегда любил писать код руками, любил статичный html, и ничего не могу с собой поделать. Конечно, совсем плейнтекстовые файлы в наше время писать довольно странно, и я уже &lt;a href=&quot;http://kizmarh.ya.ru/replies.xml?item_no=1929&quot;&gt;упоминал&lt;/a&gt; о том, что в последнее время использую для генерации статики фреймворк nanoc. &lt;abbr&gt;HAML&lt;/abbr&gt;, &lt;abbr&gt;SASS&lt;/abbr&gt;, автообновление страниц при рефреше в браузере, всё такое.&lt;/p&gt;
&lt;p&gt;И вот,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;внезапно!&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;писать длинные каскады классов руками выходит довольно муторно. &lt;span class=&quot;nobr&quot;&gt;Какое-то&lt;/span&gt; время я пытался копать в сторону использования подшаблонов для блоков, думал на тему генерации &lt;abbr&gt;SASS&lt;/abbr&gt;, но в итоге ни до чего толком не дошёл.&lt;/p&gt;
&lt;p&gt;И, недавно, в одну из итераций моего мысленного процесса на эту тему, я таки набрёл на ниточку, которая, кажется, приведёт меня к выходу из лабиринта хитросплетений классов для блоков-элементов-модификаторов и бесконечной их копипасты и автокомплита.&lt;/p&gt;
&lt;p&gt;Решение довольно простое, в самом основании её лежит принцип упрощения. Вот сразу, без лишних слов, идея в виде &lt;abbr&gt;HTML&lt;/abbr&gt;-дерева, записанного &lt;abbr&gt;CSS&lt;/abbr&gt;-селекторами, в формате было-стало:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;.b-block_type_foo&lt;/code&gt;{:.nowrap} → &lt;code&gt;.b-block.b-block_type_foo&lt;/code&gt;{:.nowrap}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.b-block &amp;gt; .__element&lt;/code&gt;{:.nowrap} → &lt;code&gt;.b-block &amp;gt; .b-block__element&lt;/code&gt;{:.nowrap}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.b-block &amp;gt; .__el &amp;gt; .__el&lt;/code&gt;{:.nowrap} → &lt;code&gt;.b-block &amp;gt; .b-block__el &amp;gt; .b-block__el__el&lt;/code&gt;{:.nowrap}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.b-block &amp;gt; .__el1 &amp;gt; .____el2&lt;/code&gt;{:.nowrap} → &lt;code&gt;.b-block &amp;gt; .b-block__el1 &amp;gt; .b-block__el2&lt;/code&gt;{:.nowrap}&lt;/li&gt;
&lt;li&gt;&lt;code&gt;.b-bl1 &amp;gt; .b-bl2_foo &amp;gt; .__el + .____el_bar&lt;/code&gt;{:.nowrap} → &lt;code&gt;.b-bl1 &amp;gt; .b-bl2.b-bl2_foo &amp;gt; .b-bl2__el + .b-bl1__el.b-bl1__el_bar&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Это для затравки. Если объяснять словами что происходит:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Чтобы прописать блок с модификатором не обязательно писать название класса по два раза по два раза, достаточно написать сразу модификатор. Модификатор без самого блока используется примерно никогда.&lt;/li&gt;
&lt;li&gt;Элементу блока не нужно прописывать имя блока.&lt;/li&gt;
&lt;li&gt;Можно создавать элемент для элемента.&lt;/li&gt;
&lt;li&gt;Если надо, можно посмотреть «наверх» и прописать элемент для блока выше по дереву (тут, кстати, надо заметить, что я этот пост я пишу в общепринятой &lt;abbr&gt;БЭМ&lt;/abbr&gt;-нотации, тогда как сам использую для себя чуть иную&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;вместо «&lt;code&gt;__&lt;/code&gt;» я пишу «&lt;code&gt;-&lt;/code&gt;». Для меня это получается читаемее и с bemto писать в моей нотации проще)&lt;/li&gt;
&lt;li&gt;Ну и сочетание всего этого дела выше.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Картина начинает складываться?&lt;/p&gt;
&lt;p&gt;Прописанные выше «селекторы» я уже частично применяю, сделав простенький и грязный макрос для текстмейта,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сначала трансформирую селектор, потом вызываю зен-кодинг. &lt;span class=&quot;nobr&quot;&gt;По-хорошему&lt;/span&gt;, надо бы это встроить в зен-кодинг как препроцессор, и я, возможно, когда-нибудь попробую &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; такое соорудить.&lt;/p&gt;
&lt;p&gt;Однако, селекторами дело не ограничивается. Всё то же самое можно сделать и для &lt;abbr&gt;HAML&lt;/abbr&gt; (и, по идее, для любого шаблонизатора, сам я попробую &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; сделать именно для &lt;abbr&gt;HAML&lt;/abbr&gt; т.к. его легко парсить, а я не программист :)), в таком случае запись&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-bl1
  .b-bl2_foo
    .__el
    .____el_bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Будет интерпретироваться как&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-bl1
  .b-bl2.b-bl2_foo
    .b-bl2__el
    .b-bl1__el.b-bl1__el_bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ну а для &lt;abbr&gt;SASS&lt;/abbr&gt;/&lt;abbr&gt;SCSS&lt;/abbr&gt; можно написать уже постпроцессор, тогда&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-block {
    …
    ._foo {…}
    .__element {
        …
        ._bar {…}
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;будет раскрываться сассом сначала в&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-block {…}
.b-block ._foo {…}
.b-block .__element {…}
.b-block .__element ._bar {…}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;что потом простейшей регуляркой преобразуется уже в то, что нам нужно:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-block {…}
.b-block_foo {…}
.b-block__element {…}
.b-block__element_bar {…}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вуаля.&lt;/p&gt;
&lt;p&gt;Концепция простая, реализация не должна быть очень уж сложной, однако, сам я, если &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; и реализую, то это будет, скорее всего, реализовано крайне плохо. Потому, если вдруг &lt;span class=&quot;nobr&quot;&gt;кто-то&lt;/span&gt; загорится идеей и сделает &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; из того, что я описал (дополнение к зен-кодингу, препроцессор для &lt;abbr&gt;HAML&lt;/abbr&gt; и постпроцессор для &lt;abbr&gt;SASS&lt;/abbr&gt;), или же реализует эту концепцию для &lt;span class=&quot;nobr&quot;&gt;чего-то&lt;/span&gt; ещё (&lt;abbr&gt;LESS&lt;/abbr&gt;, любой другой шаблонизатор, что угодно),&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;я буду только за.&lt;/p&gt;
&lt;p&gt;И ещё: это пока только начало. В вёрстке и, в частности, в &lt;abbr&gt;БЭМ&lt;/abbr&gt; я вижу много чего, что можно развивать и улучшать, много моих идей хорошо ложатся рядом с концепцией bemto. Так что, напоследок, можете подумать во что, по моим мыслям, может превратиться следующее:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;.b-block_foo._bar&amp;gt;.__b-link_lol&amp;gt;.__element._
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;добавлено-&quot;&gt;Добавлено:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;В последней версии Zen Coding &lt;a href=&quot;https://github.com/emmetio/emmet/commit/86953fc054492153846098f6095951849a4c04f8&quot;&gt;были реализованы&lt;/a&gt; некоторые аспекты bemto.&lt;/li&gt;
&lt;li&gt;Я начал разработку &lt;a href=&quot;https://github.com/kizu/bemto/&quot;&gt;bemto&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;набора миксинов для Jade, позволяющую делать многие вещи, доступные в bemto (пускай и чуть-чуть обходными путями).&lt;/li&gt;
&lt;/ol&gt;

    </content>
  </entry>
  <entry>
    <title>Паддинги в вёрстке под iOS</title>
    <link href="http://kizu.ru/issues/tap-to-padding/"/>
    <updated>2011-04-18T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/tap-to-padding</id>
    <content type="html">&lt;h1 id=&quot;паддинги-в-в-рстке-под-ios&quot;&gt;Паддинги в вёрстке под iOS&lt;/h1&gt;
&lt;p&gt;Я решил, что раз уж времени на большие посты у меня не хватает, а писать &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; всё-равно хочется, то буду писать о всяких мелочах, которые замечаю.&lt;/p&gt;
&lt;p&gt;Довольно банальная вещь, которая может довольно сильно влиять на восприятие страниц при просмотре их под Сафари в iOS: при зуме через дабл-тап происходит приближение к тому элементу под тапом, который находится ближе всего в дереве и имеет не инлайновое позиционирование.&lt;/p&gt;
&lt;p&gt;Иногда это может сыграть дурную шутку, особенно в случаях когда внутренние элементы &lt;span class=&quot;nobr&quot;&gt;как-то&lt;/span&gt; хитро позиционируются из контейнера.&lt;/p&gt;
&lt;p&gt;Кроме того, зум к элементам стандартных списков в большинстве случаев вынесет маркеры за пределы вьюпорта, что, например, для нумерованных списков будет очень некстати. Чинится это заданием паддинга не к &lt;code&gt;UL&lt;/code&gt;/&lt;code&gt;OL&lt;/code&gt;, а непосредственно к &lt;code&gt;LI&lt;/code&gt;, ну и переопределение стилей для маркеров. Ну и никаких маджинов.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/demos/tap-to-padding.html&quot;&gt;Вот пример&lt;/a&gt;, который можно открыть в iOS и позумиться там к разным блокам.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Автоматический резиновый шеврон</title>
    <link href="http://kizu.ru/fun/chevron/"/>
    <updated>2011-04-03T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/chevron</id>
    <content type="html">&lt;h1 id=&quot;автоматический-резиновый-шеврон&quot;&gt;Автоматический резиновый шеврон&lt;/h1&gt;
&lt;p&gt;Всё довольно просто: только &lt;abbr&gt;CSS&lt;/abbr&gt; и &lt;abbr&gt;HTML&lt;/abbr&gt;, хотя &lt;abbr&gt;HTML&lt;/abbr&gt; в итоге получается ужасающим.&lt;/p&gt;
&lt;p&gt;Смысл этого эксперимента вот в чём: в дропдаун, который показывается по клику на «ещё», автоматически помещаются все пункты, которые не поместились в одну строчку по ширине. При этом заранее неизвестно ни количество элементов, ни их ширина, ни ширина родителя&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;и всё это без JS.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/chevron/#Demo_chevron&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Поизменяйте размер окна для демонстрации работы шеврона. Работоспособность проверялась только в современных !IE браузерах.&lt;/p&gt;
&lt;p&gt;Думаю, не стоит особо объяснять почему такое, на самом деле, лучше делать при помощи яваскрипта, но данный пример, как и многие мои другие эксперименты, создавался, скорее, как proof of concept и исследование возможностей применения разных селекторов и их сочетаний.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Эмуляция text-overflow</title>
    <link href="http://kizu.ru/fun/overflower/"/>
    <updated>2011-03-08T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/overflower</id>
    <content type="html">&lt;h1 id=&quot;эмуляция-text-overflow&quot;&gt;Эмуляция text-overflow&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Эффект «скрытия контента» появляется только если есть что скрывать (следовательно, не будет ситуации когда места для контента хватает, но визуально кажется, что уже &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; скрыто).&lt;/li&gt;
&lt;li&gt;Можно навесить &lt;code&gt;title&lt;/code&gt; на элемент или &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; ещё только если возникает необходимость.&lt;/li&gt;
&lt;li&gt;Метод должен работать как минимум IE7+, хотя данные примеры для него не оптимизированы (работает только тултип).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Можно поизменять размер окна, чтобы увидеть момент перехода.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/overflower/#Demo_overflower&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Фильтры элементов без яваскрипта</title>
    <link href="http://kizu.ru/fun/filters/"/>
    <updated>2011-02-06T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/filters</id>
    <content type="html">&lt;h1 id=&quot;фильтры-элементов-без-яваскрипта&quot;&gt;Фильтры элементов без яваскрипта&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;Цвета&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;просто чекбоксы.&lt;/li&gt;
&lt;li&gt;формы&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;радиобатоны с дополнительным свойством: их можно «анчекать».&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Только &lt;abbr&gt;CSS&lt;/abbr&gt;, никакого JS.&lt;/p&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/filters/#Demo_filters&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Опять же&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;только современные браузеры, в IE можно было бы эмулировать экспрешнами, но лень.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Попапы и дропдауны</title>
    <link href="http://kizu.ru/fun/popups/"/>
    <updated>2011-02-05T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/popups</id>
    <content type="html">&lt;h1 id=&quot;попапы-и-дропдауны&quot;&gt;Попапы и дропдауны&lt;/h1&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/popups/#Demo_popups&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Кастомные контролы без яваскрипта</title>
    <link href="http://kizu.ru/fun/controls/"/>
    <updated>2011-02-03T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/controls</id>
    <content type="html">&lt;h1 id=&quot;кастомные-контролы-без-яваскрипта&quot;&gt;Кастомные контролы без яваскрипта&lt;/h1&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/controls/#Demo_controls&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Graceful degradation все дела, хотя смотреть лучше всего в вебкитах под мак&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;там больше вкусняшек.&lt;/p&gt;
&lt;p&gt;А в вебкитах под винду пока есть дурацкий баг, &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; которого внутренние тени не обрезаются по бордер-радиусу, печаль.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Скруглённые внутренние углы</title>
    <link href="http://kizu.ru/fun/rounded-inner-corners/"/>
    <updated>2010-05-12T00:00:00+03:00</updated>
    <id>http://kizu.ru/fun/rounded-inner-corners</id>
    <content type="html">&lt;h1 id=&quot;скругл-нные-внутренние-углы&quot;&gt;Скруглённые внутренние углы&lt;/h1&gt;
&lt;p&gt;Посмотрите на демо &lt;a href=&quot;http://kizu.ru/fun/rounded-inner-corners/#Demo_rounded-inner-corners&quot;&gt;встроенное в пост&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>WBR и его эмуляция</title>
    <link href="http://kizu.ru/issues/old/wbr/"/>
    <updated>2009-05-19T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/wbr</id>
    <content type="html">&lt;h1 id=&quot;wbr-и-его-эмуляция&quot;&gt;&lt;abbr&gt;WBR&lt;/abbr&gt; и его эмуляция&lt;/h1&gt;
&lt;p&gt;Некоторые, наверное, знают про тег &lt;code&gt;WBR&lt;/code&gt;, &lt;span class=&quot;nobr&quot;&gt;когда-то&lt;/span&gt; давно использовавшийся для того, чтобы переносить слишком длинные слова, если возникает такая необходимость. Основные проблемы этого тега две:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;он не работает в Опере&lt;/li&gt;
&lt;li&gt;он не валидный&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;К счастью, эмулировать его достаточно легко. Кроме того, при помощи этой эмуляции можно починить поведение тега в Опере.&lt;/p&gt;
&lt;p&gt;Вот примерное решение:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-html&quot;&gt;lalala&amp;lt;i class=&amp;quot;wbr&amp;quot;&amp;gt;&amp;lt;/i&amp;gt;lalala
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;и&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;WBR,
.wbr {
    display: inline-block;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Единственный момент, который остаётся за рамками эмуляции: в IE &lt;code&gt;WBR&lt;/code&gt; может создавать разрыв строки при &lt;code&gt;white-space:nowrap&lt;/code&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Стили для верхнего и нижнего индекса в CSS</title>
    <link href="http://kizu.ru/issues/old/sup-and-sub/"/>
    <updated>2009-01-11T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/sup-and-sub</id>
    <content type="html">&lt;h1 id=&quot;стили-для-верхнего-и-нижнего-индекса-в-css&quot;&gt;Стили для верхнего и нижнего индекса в &lt;abbr&gt;CSS&lt;/abbr&gt;&lt;/h1&gt;
&lt;p&gt;Наверное, почти все знают про теги &lt;code&gt;SUP&lt;/code&gt; и &lt;code&gt;SUB&lt;/code&gt;. Довольно подробное описание можно найти в &lt;a href=&quot;http://en.wikipedia.org/wiki/Subscript&quot;&gt;статье&lt;/a&gt; английской википедии.&lt;/p&gt;
&lt;p&gt;Основная проблема в стандартной реализации отображения этих тегов&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;изменение высоты строки за счёт того, что текст в этих тегах выравнивается свойством &lt;abbr&gt;CSS&lt;/abbr&gt; &lt;code&gt;vertical-align&lt;/code&gt;. Это изменение варьируется от браузера к браузеру, но, кроме того, везде различаются как размеры шрифта для таких элементов, так и сами отступы. Об этой проблеме многие знают и, чаще всего, предлагают два решения: уменьшение высоты строки этих элементов, и их относительное позиционирования.&lt;/p&gt;
&lt;p&gt;Для себя я решил это делать так:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt;SUP, SUB {
    vertical-align: baseline;
    position: relative;
    font-size: .7em;
    line-height: 1;
    }
SUP {
    bottom: 1.4ex;
    }
SUB {
    top: .5ex;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Как видно из кода, я «обнулил» вертикальное вырванивание, воспользовался относительным позиционированием, а также уменьшил высоту строки. Кроме того, можно обратить внимание на величины отступов: я их задал в &lt;code&gt;ex&lt;/code&gt;, т.к. по логике и по имеющимся описаниям (например, в уже упомянутой &lt;a href=&quot;http://en.wikipedia.org/wiki/Subscript&quot;&gt;статье&lt;/a&gt; английской википедии) этот отступ должен быть основан именно на этой относительной единице, основанной на &lt;em&gt;высоте&lt;/em&gt; шрифты, нежели на &lt;em&gt;ширине&lt;/em&gt;. Вообще, это достаточно общее определение, в идеале можно использовать различные классы для цифровых значений в индексах, для случаев когда есть только прописные или только строчные буквы и пр. Однако, это уже требует вмешательств в разметку, и к &lt;abbr&gt;CSS&lt;/abbr&gt; уже не имеет отношения.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/demos/sup-and-sub.html&quot;&gt;Примеры как исправленных тегов, так и не исправленных&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Стоит упомянуть, что в некоторых случаях всё-таки может иметь смысл задавать отступ для индексов, увеличивающий высоту строки, скажем, когда у нас есть большая вложенность индексов или ешё &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt;, за счёт чего они могут попасть на другие строки. Правда, чаще всего про это можно забыть.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>IE и поведение ссылок при наведении</title>
    <link href="http://kizu.ru/issues/old/ie-a-hover/"/>
    <updated>2008-12-30T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/ie-a-hover</id>
    <content type="html">&lt;h1 id=&quot;ie-и-поведение-ссылок-при-наведении&quot;&gt;IE и поведение ссылок при наведении&lt;/h1&gt;
&lt;p&gt;В этой заметке я опишу один момент, который довольно часто можно встретить в сложной вёрстке с &lt;abbr&gt;CSS&lt;/abbr&gt;, но который редко проявляет себя или на который редко обращают внимание.&lt;/p&gt;
&lt;p&gt;Этот момент проявляет себя в случае когда в IE внутри ссылки есть блок со свойством &lt;code&gt;hasLayout&lt;/code&gt;, тогда можно заметить следующее:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;клик по картинке, расположенной в таком блоке, не вызывает переход по ссылке;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;при правом клике по блоку с &lt;code&gt;hasLayout&lt;/code&gt; не появляется контекстное меню ссылки (т.е. IE для контекстного меню считает этот блок просто контентом, что также можно заметить по курсору над таким блоком).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Кроме того, если внутри ссылки с прозрачным (&lt;code&gt;transparent&lt;/code&gt;) фоном есть какой-либо элемент, а мы хотим поменять его свойства, скажем, через такой селектор: &lt;code&gt;A:hover EL {…}&lt;/code&gt;, то, при наведении на этот элемент, селектор применяться не будет.&lt;/p&gt;
&lt;p&gt;Собственно, такое поведение селектора исправляется просто&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;необходимо прописать фон для ссылки, в таком случае всё встанет на свои места (или же можно применить &lt;a href=&quot;http://makishvili.com/2009/06/stilizaciya-rebenka-ssylki-pri-hover/&quot;&gt;&lt;code&gt;word-spacing:0&lt;/code&gt;&lt;/a&gt;, что тоже помогает, спасибо &lt;a href=&quot;http://makishvili.ya.ru/&quot;&gt;Вадиму Макишвили&lt;/a&gt; за этот метод.&lt;/p&gt;
&lt;p&gt;Однако, в случае с отсутствием контекстного меню и картинкой всё сложнее.&lt;/p&gt;
&lt;p&gt;Основной способ проявить в таком случае контекстное меню выполняется в два шага:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Необходимо применить к ссылке &lt;code&gt;hasLayout&lt;/code&gt; и прозрачный фон (скажем, прозрачный однопиксельный гиф или же &lt;code&gt;background: url(about:blank)&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;такой фон, в дальнейшем, я буду называть «явный прозрачный фон»)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Самому блоку с &lt;code&gt;hasLayout&lt;/code&gt; необходимо прописать такой же прозрачный фон и отрицательный &lt;code&gt;z-index&lt;/code&gt; с относительным позиционированием.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Если всё сделать правильно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;&lt;span class=&quot;Sidenote-Wrapper&quot;&gt;&lt;a class=&quot;Sidenote-Context&quot; href=&quot;#possibly&quot; id=&quot;possibly&quot;&gt;&lt;em&gt;очень вероятно&lt;/em&gt;&lt;/a&gt;&lt;span class=&quot;Sidenote&quot; role=&quot;note&quot;&gt;&lt;span class=&quot;Sidenote-Misc&quot;&gt; (&lt;/span&gt;Вероятно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;потому что с IE нельзя быть уверенным до конца :)&lt;span class=&quot;Sidenote-Misc&quot;&gt;)&lt;/span&gt;&lt;/span&gt;&lt;a class=&quot;Sidenote-Close&quot; href=&quot;#x&quot; aria-hidden=&quot;true&quot; tabindex=&quot;-1&quot;&gt;&lt;/a&gt;&lt;/span&gt;, что всё заработает. Очень важно, чтобы сама ссылка была с прозрачным фоном (иначе блок с &lt;span class=&quot;nobr&quot;&gt;з-индексом&lt;/span&gt; не будет видно) и без заданного позиционирования (&lt;code&gt;position:static&lt;/code&gt;), иначе опять же не сработает.&lt;/p&gt;
&lt;p&gt;К сожалению, более корректного и простого фикса я не нашёл, поэтому в данный момент, когда у нас есть ссылка, которую надо «тяжело» оформить, желательно все дополнительные элементы класть не внутрь ссылки, а обрамлять её ими. Кроме того, полезно всегда быть уверенным, что ссылка не спозиционирована, т.е., по возможности, позиционировать обрамляющие её элементы. Желательно всегда таким ссылкам прописывать &lt;code&gt;hasLayout&lt;/code&gt; и явный прозрачный фон, в таком случае можно минимизировать возможные проблемы как с контекстным меню, так и с селекторами дочерних элементов. Надо сказать, что явный прозрачный фон у ссылок также может помочь против некоторых багов у Оперы, возможно в будущем я опишу их.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/demos/ie-a-hover.html&quot;&gt;Ну, а вот и несколько примеров&lt;/a&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в которых можно посмотреть поведение ссылок в IE и почитать код.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Двойные классы и IE6</title>
    <link href="http://kizu.ru/issues/old/multiclass/"/>
    <updated>2008-12-22T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/multiclass</id>
    <content type="html">&lt;h1 id=&quot;двойные-классы-и-ie6&quot;&gt;Двойные классы и IE6&lt;/h1&gt;
&lt;p&gt;Одними из самых приятных селекторов в &lt;abbr&gt;CSS&lt;/abbr&gt; могли бы стать множественные классы. Стилизация в зависимости от цепочки классов, прописанных одному элементу могла бы быть очень заманчивой, однако, как всегда, всё портит IE6.&lt;/p&gt;
&lt;p&gt;Собственно, сразу к делу. Вот &lt;a href=&quot;/demos/multiclass.html&quot;&gt;пример применения нескольких классов&lt;/a&gt;. В нормальных браузерах первые две строчки будут иметь зелёный фон, тогда как IE6&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;красный. Это возникает за счёт того, что:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;При использовании цепочки классов, например &lt;code&gt;.class1.class2 {…}&lt;/code&gt; IE6 совершенно игнорирует все классы, кроме последнего в селекторе. Соответственно&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;это можно видеть в первом примере&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;IE6 не обращает внимания на несуществующий класс в селекторе.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;IE6 не просто не обращает внимания на эти классы, он их не добавляет к свойству каскада селектора: более весомый в теории селектор&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в IE6 таким не является.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Таким образом, может создаться впечатление, что в IE6 селектор срабатывает как надо: например, имея &lt;code&gt;.class1 {…} .class1.class2 {…}&lt;/code&gt; и проверяя меняется ли поведение блока при добавлении второго класса,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в IE6 второй селектор будет перекрывать первый только потому, что он идёт вторым.&lt;/p&gt;
&lt;p&gt;Как вывод: нельзя пользоваться такими селекторами и, в случае необходимости, лучше создать дополнительную обёртку, в которой уже продублировать все классы изначального элемента, после чего в селекторе указывать классы через пробел. К сожалению, для тройных и четверных цепочек придётся создавать новые и новые обёртки, так что лучшим выходом будет отказ от использования соединения классов.&lt;/p&gt;
&lt;p&gt;Однако, иногда полезно определять для всей страницы &lt;span class=&quot;nobr&quot;&gt;какой-то&lt;/span&gt; класс, на котором потом будет основываться дальшейшая вёрстка. Часто таким образом для &lt;code&gt;BODY&lt;/code&gt; прописывают множество классов. Но если необходимо применять стили сообразно двум или трём классам, действующим одновременно, имеет смысл создать один-два обрамляющих дива для всей страницы и продублировать классы в них. Это немного увеличит размер &lt;abbr&gt;HTML&lt;/abbr&gt;, но сократит &lt;abbr&gt;CSS&lt;/abbr&gt;, кроме того, сделает работу с каскадными таблицами стилей удобнее.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Микроформат «rel-tag»</title>
    <link href="http://kizu.ru/issues/old/rel-tag/"/>
    <updated>2008-12-03T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/rel-tag</id>
    <content type="html">&lt;h1 id=&quot;микроформат-rel-tag-&quot;&gt;Микроформат «rel-tag»&lt;/h1&gt;
&lt;p&gt;Веб-стандартисты и сторонники семантической вёрстки очень любят микроформаты. &lt;span class=&quot;nobr&quot;&gt;Кто-то&lt;/span&gt; их разрабатывает, обсуждает и выкладывает всю необходимую информацию на &lt;a href=&quot;http://microformats.org/&quot;&gt;официальном сайте микроформатов&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Я, хоть и не разрабатываю их, но слежу за ними, и, бывает, моё мнение не совпадает с мнением сообщества. В этот раз оно не совпало относительно микроформата &lt;a href=&quot;http://microformats.org/wiki/rel-tag&quot;&gt;rel-tag&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Основной момент, с которым я не согласен&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;то, что этот микроформат требует достаточно странной имплементации. Но, судя по всему, и в самой среде разработчиков это не до конца решённый вопрос (в &lt;abbr&gt;XMDP&lt;/abbr&gt; profile ничего не сказано про &lt;code&gt;href&lt;/code&gt;, &lt;a href=&quot;http://microformatique.com/optimus/&quot;&gt;этот валидатор&lt;/a&gt; не видит проблемы в теге &lt;code&gt;A&lt;/code&gt; без хрефа, тогда как во всех текстах указывается только вариант с хрефом, ну и плагин-валидатор &lt;a href=&quot;https://addons.mozilla.org/ru/firefox/addon/4106&quot;&gt;Operator&lt;/a&gt; ругается на его отсутствие). Суть: в вики по этому микроформату написано, что &lt;code&gt;rel-tag&lt;/code&gt; должен применяться только к &lt;em&gt;ссылкам&lt;/em&gt;, при этом, собственно, сам &lt;em&gt;тег&lt;/em&gt; должен браться из последнего слова в адресе страницы, на который ссылается объект, к которому применен микроформат. Скажем, для &lt;code&gt;&amp;lt;a href=&amp;quot;http://technorati.com/tag/tech&amp;quot; rel=&amp;quot;tag&amp;quot;&amp;gt;fish&amp;lt;/a&amp;gt;&lt;/code&gt; (пример из вики) определяющим будет последний компонент аттрибута &lt;code&gt;href&lt;/code&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;«tech», нежели «fish». В этих двух моментах я и не согласен. По моему мнению:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Индикатором тега должно быть его содержимое, либо аттрибут &lt;code&gt;title&lt;/code&gt;, если он имеется и не пустой.&lt;/li&gt;
&lt;li&gt;Соответственно, должен быть допустим вариант указания микроформата без хрефа.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Обосную. Этот микроформат был заявлен, в том числе, и как инлайновый аналог meta-keywords, следовательно, должно быть допустимо указание тегов для записи (текстообразующих элементов) прямо в тексте. Это и логично и семантично. Понятие «области тегов», на которое, по идеям стандартистов, ссылается ссылка из микроформата, имеет смысл, но никак не должно быть главенствующим. С таким понятием тег становится слишком блого-направленным: в случае когда автор не может обеспечить реализацию страницы тегов на уровне движка становится проблематичным составление необходимой ссылки для тега. В обсуждениях встречались варианты указания соответствующих страниц в википедии или на других сайтах, но это не всегда может быть возможно, следовательно, ненадёжно.&lt;/p&gt;
&lt;p&gt;Лично для себя я решил, что когда я могу найти достаточно надёжную и верную ссылку, для указания в микроформате&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;буду её указывать, тогда как в остальных случаях, когда надо указать, что какое-либо слово или термин в тексте является &lt;em&gt;тегом&lt;/em&gt;,&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;буду применять одинокий &lt;code&gt;&amp;lt;a rel=&amp;quot;tag&amp;quot;&amp;gt;&lt;/code&gt;. Это валидно и почти семантично (единственный спорный момент&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;по спецификации &lt;code&gt;rel&lt;/code&gt; указывает отношение ссылки к содержимому по адресу, но в отсутствие ссылки, как мне кажется, семантичность &lt;em&gt;не уменьшается&lt;/em&gt;). В будущем &lt;abbr&gt;XHTML&lt;/abbr&gt;2 можно будет ещё более семантично использовать для этих нужд аттрибут &lt;code&gt;role&lt;/code&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Решение inline-block</title>
    <link href="http://kizu.ru/issues/old/inline-block-solved/"/>
    <updated>2008-09-30T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/inline-block-solved</id>
    <content type="html">&lt;h1 id=&quot;решение-inline-block&quot;&gt;Решение inline-block&lt;/h1&gt;
&lt;p&gt;Одним из самых интересных свойств в &lt;abbr&gt;CSS&lt;/abbr&gt; является &lt;code&gt;inline-block&lt;/code&gt;. Возможность создавать блоки, ведущие себя как строчные элементы потенциально несёт очень много радости. С одной стороны, можно управлять такими блоками при помощи &lt;code&gt;text-align&lt;/code&gt;, с другой&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;внедрять в текст, используя или как иконки, или как отдельные смысловые элементы, вместе с остальным текстом переносящиеся со строчки на строчку и обтекаемые флоатами.&lt;/p&gt;
&lt;p&gt;Однако, существуют две причины, по которой вёрстка с использованием подобных блоков почти не получила распространения:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;display:inline-block&lt;/code&gt; в IE срабатывает только для изначально строчных элементов, вроде &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;SPAN&lt;/code&gt; и прочих. &lt;del&gt;При этом возможности обойти это, насколько мне известно, нет&lt;/del&gt;&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;век живи, век учись&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;если сначала у блока, пускай и блочного, стоит &lt;code&gt;display:inline-block&lt;/code&gt;, а позже только для IE мы пропишем &lt;code&gt;display:inline&lt;/code&gt; всё волшебным образом заработает.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;display:inline-block&lt;/code&gt; никак не работает в FireFox версий ниже 3-ей. Однако, есть один обходной путь.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Тогда, как Fx2 простой &lt;code&gt;inline-block&lt;/code&gt; не понимает, существует проприетарное лисье свойство &lt;code&gt;display:-moz-inline-box&lt;/code&gt;. К сожалению, это не полноценное решение проблемы, а костыль, имеющий множество ограничений по использованию, но на безрыбье и оно сгодится, если использовать его аккуратно.&lt;/p&gt;
&lt;p&gt;Под аккуратностью я понимаю следующие моменты:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Для минимизации глюков поведения &lt;code&gt;-moz-inline-box&lt;/code&gt; желательно внутрь такого элемента вставить дополнительный строковый элемент с &lt;code&gt;display:block&lt;/code&gt;. Однако, в этом случае необходимо добавить &lt;code&gt;float:left&lt;/code&gt; для IE, иначе он будет растягивать такой элемент на всю возможную (для безграничных возможностей ие) ширину.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Если нужно задавать фиксированные размеры для элемента &lt;code&gt;inline-block&lt;/code&gt;, лучше задавать его и для самого элемента, и для внутреннего элемента (во избежание некоторых проблем).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Поведение &lt;code&gt;-moz-inline-box&lt;/code&gt; местами непредсказуемое, поэтому во время разработки нужно чаще тестировать поведение таких элементов в Fx2, однако внутренние элементы уже будут обретать привычные черты.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Т.к. в Fx3 нормальное поведение &lt;code&gt;inline-block&lt;/code&gt; уже реализовано, подключать решение нужно примерно так: &lt;code&gt;display:-moz-inline-box; display:inline-block;&lt;/code&gt;, вторая лиса увидит только свою проприетарщину, а третья&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;заметит и стандартное значение, которое и применит.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;К сожалению, применяя к подобным элементам &lt;code&gt;vertical-align&lt;/code&gt;, очень сложно добиться одинакового выравнивания во всех браузерах.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Ну и &lt;a href=&quot;/demos/inline-block-solved.html&quot;&gt;несколько примеров применения&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P.S.: Следует упомянуть, что существует элемент, который практически во всех браузерах ведет себя как &lt;code&gt;inline-block&lt;/code&gt; элемент почти безукоризненно. Это тег &lt;code&gt;button&lt;/code&gt;. Правда, минусов у реализации &lt;code&gt;inline-block&lt;/code&gt; при помощи кнопок предостаточно: много различных стилей, которые прийдется обнулять, невозможность кроссбраузерно и легко сделать простую ссылку на кнопочной основе, ну и изначальная семантика кнопки, &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; которой возможность её применения будет возникать очень редко.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Мелочь в селекте</title>
    <link href="http://kizu.ru/issues/old/select-label/"/>
    <updated>2008-09-26T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/select-label</id>
    <content type="html">&lt;h1 id=&quot;мелочь-в-селекте&quot;&gt;Мелочь в селекте&lt;/h1&gt;
&lt;p&gt;В различных формах часто можно встретить элемент &lt;code&gt;SELECT&lt;/code&gt;, в котором первым пунктом ставят фразу вроде «Выберите что-нибудь». Чаще всего, её просто вставляют ни о чём не задумываясь. Однако, есть два момента, которые можно учесть:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;В идеале, этот первый пункт вообще не должен быть элементом &lt;code&gt;OPTION&lt;/code&gt;, так как он по сути не опция, а заголовок для селекта. Но в &lt;a href=&quot;http://www.w3.org/TR/html401/interact/forms.html#h-17.6&quot;&gt;спецификации&lt;/a&gt; подобного элемента предусмотрено не было. Так что, можно минимизировать влияние этого элемента на семантику, вынеся этот заголовок из содержимого элемента &lt;code&gt;OPTION&lt;/code&gt; в его атрибут &lt;code&gt;label&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Кроме того, нужно минимизировать возможность пользователя выбрать этот пункт. Решение&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;сделать его &lt;code&gt;disabled&lt;/code&gt; и &lt;code&gt;selected&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Всё было бы хорошо, если бы не всеми любимый IE. &lt;span class=&quot;nobr&quot;&gt;Во-первых&lt;/span&gt;, он совершенно игнорирует атрибут &lt;code&gt;disabled&lt;/code&gt; и исправить это я пока не вижу возможности. &lt;span class=&quot;nobr&quot;&gt;Во-вторых&lt;/span&gt;, он игнорирует атрибут &lt;code&gt;label&lt;/code&gt;. Но это можно обойти простеньким экспрешном, код которого можно посмотреть в &lt;a href=&quot;/demos/select-label.html&quot;&gt;примере&lt;/a&gt; для этой заметки.&lt;/p&gt;
&lt;p&gt;В итоге можно улучшить поведение подобного элемента, и, хотя до полной поддержки всеми браузерами еще далеко, разве это не повод сделать хорошо хотя бы тем, кто это понимает?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Добавлено позже:&lt;/strong&gt; как всегда, поторопился&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;оказывается Firefox также не видит атрибут &lt;code&gt;label&lt;/code&gt;. Однако, мне коллега &lt;a href=&quot;http://lusever.livejournal.com&quot;&gt;Lusever&lt;/a&gt; подсказал, что для лисы есть такая вещь, как &lt;a href=&quot;https://developer.mozilla.org/En/CSS/-moz-binding&quot;&gt;&lt;code&gt;-moz-binding&lt;/code&gt;&lt;/a&gt;, немного посидев, я сделал аналог экспрешна в ие&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;теперь оно работает :) Код можно поискать всё в том же &lt;a href=&quot;/demos/select-label.html&quot;&gt;примере&lt;/a&gt;.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Браузеры против таблиц</title>
    <link href="http://kizu.ru/issues/old/browsers-vs-tables/"/>
    <updated>2008-05-25T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/browsers-vs-tables</id>
    <content type="html">&lt;h1 id=&quot;браузеры-против-таблиц&quot;&gt;Браузеры против таблиц&lt;/h1&gt;
&lt;p&gt;Сложные таблицы являются, наверное, одним из самых интересных мест в верстке.&lt;/p&gt;
&lt;p&gt;В последнее время мне нужно верстать очень много таблиц, при этом разных и со всякими дополнительными элементами. И требованиями.&lt;/p&gt;
&lt;p&gt;В этой статье я расскажу про несколько моментов, с которыми я встретился за последние пару месяцев.&lt;/p&gt;
&lt;h2 id=&quot;выделение-таблиц-и-tfoot&quot;&gt;Выделение таблиц и &lt;code&gt;TFOOT&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;По спецификации блок &lt;code&gt;TFOOT&lt;/code&gt; должен идти до блока &lt;code&gt;TBODY&lt;/code&gt;, при этом в самой таблице он выводится последним. С первого взгляда всё нормально, но если вдруг нам надо будет выделить содержимое таблицы мы столкнемся с тем, что в отображении &lt;code&gt;TFOOT&lt;/code&gt; ставится в конец только визуально и выделяя текст в таблице выделение будет вести себя соответственно: выделяя всю таблицу с верхнего левого угла по нижний правый мы выделим всю таблицу за исключением &lt;code&gt;TBODY&lt;/code&gt; (В Opera, однако, алгоритм слегка иной, и можно таким образом выделить всю таблицу, но и своих глюков с этим в ней хватает).&lt;/p&gt;
&lt;p&gt;Попробуйте сами &lt;span class=&quot;nobr&quot;&gt;по-всякому&lt;/span&gt; выделять текст в таблице:&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;&lt;abbr&gt;THEAD&lt;/abbr&gt;-TH&lt;/th&gt;
 &lt;td&gt;&lt;abbr&gt;THEAD&lt;/abbr&gt;-TD&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tfoot&gt;
 &lt;tr&gt;
 &lt;th&gt;&lt;abbr&gt;TFOOT&lt;/abbr&gt;-TH&lt;/th&gt;
 &lt;td&gt;&lt;abbr&gt;TFOOT&lt;/abbr&gt;-TD&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tfoot&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;th&gt;&lt;abbr&gt;TBODY&lt;/abbr&gt;-TH&lt;/th&gt;
 &lt;td&gt;&lt;abbr&gt;TBODY&lt;/abbr&gt;-TD&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Конечно, можно выделить всю таблицу&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;начиная с &lt;abbr&gt;THEAD&lt;/abbr&gt;-TH и заканчивая &lt;abbr&gt;TBODY&lt;/abbr&gt;-TD, но простые пользователи будут озадачены когда столкнутся с таким поведением выделения.&lt;/p&gt;
&lt;h2 id=&quot;копирование-таблицы-в-буфер-обмена&quot;&gt;Копирование таблицы в буфер обмена&lt;/h2&gt;
&lt;p&gt;Подобное поведение &lt;code&gt;TFOOT&lt;/code&gt; также влияет и на то, что уйдет в буфер обмена, если таблицу выделить и вставить в текстовый редактор или, скажем, Excel.&lt;/p&gt;
&lt;p&gt;В большинстве браузеров &lt;code&gt;TFOOT&lt;/code&gt; будет идти до &lt;code&gt;TBODY&lt;/code&gt;. В Opera, если умудриться выделить всю таблицу, &lt;code&gt;TBODY&lt;/code&gt; всё будет нормально. Но это если выделить&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;скажем, при выполнении команды «Выделить всё» &lt;code&gt;TFOOT&lt;/code&gt; по неизвестным причинам не выделяется. А вручную приходится заниматься пиксель-хантингом.&lt;/p&gt;
&lt;p&gt;В проекте, который я сейчас верстаю, таблицы в том или ином виде присутствуют почти на всех страницах, и требования по выделению и копированию появляются не просто так. И &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; недопонимания браузерами рендеринга таблиц в этом проекте пришлось отказаться от семантики &lt;code&gt;TFOOT&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;не-существующие-аттрибуты-char-и-charoff&quot;&gt;Не существующие аттрибуты &lt;code&gt;CHAR&lt;/code&gt; и &lt;code&gt;CHAROFF&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Если внимательно почитать спецификации, можно найти очень много интересных и полезных вещей. Однако, кое-где можно встретить приписки вроде &lt;em&gt;User agents are not required to support this attribute&lt;/em&gt;, например в &lt;a href=&quot;http://www.w3.org/TR/html401/struct/tables.html#adef-charoff&quot;&gt;описании&lt;/a&gt; поведения горизонтального выравнивания яячеек в присутствии аттрибута &lt;code&gt;CHAROFF&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;По спецификации, связка из аттрибутов &lt;code&gt;ALIGN&lt;/code&gt;, &lt;code&gt;CHAR&lt;/code&gt; и/или &lt;code&gt;CHAROFF&lt;/code&gt; может очень помочь для правильно визуального представления информации. Однако, насколько мне известно, ни один из хоть сколько-нибудь популярных браузеров не реализовал эту возможность.&lt;/p&gt;
&lt;p&gt;Приведу &lt;a href=&quot;http://www.w3.org/TR/html401/struct/tables.html#adef-charoff&quot;&gt;пример из спецификации&lt;/a&gt; (по ссылке можно увидеть как предполагается рендерить подобное свойство):&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
 &lt;colgroup&gt;
 &lt;col /&gt;
 &lt;col align=&quot;char&quot; char=&quot;.&quot; /&gt;
 &lt;/colgroup&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th&gt;Vegetable&lt;/th&gt;
 &lt;th&gt;Cost per kilo&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td&gt;Lettuce&lt;/td&gt;
 &lt;td&gt;$1&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Silver carrots&lt;/td&gt;
 &lt;td&gt;$10.50&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td&gt;Golden turnips&lt;/td&gt;
 &lt;td&gt;$100.30&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Такая функциональность мне сейчас в проекте очень приходилась бы, но увы, производители браузеров решили забыть про неё.&lt;/p&gt;
&lt;h2 id=&quot;нулевые-colspan-и-rowspan&quot;&gt;Нулевые &lt;code&gt;COLSPAN&lt;/code&gt; и &lt;code&gt;ROWSPAN&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;Еще одна полезная вещь, присутствующая в спецификации&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;возможность задать ячейке &lt;code&gt;COLSPAN&lt;/code&gt; или &lt;code&gt;ROWSPAN&lt;/code&gt; равные нулю.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.w3.org/TR/html401/struct/tables.html#adef-rowspan&quot;&gt;В спецификации&lt;/a&gt; &lt;abbr&gt;HTML&lt;/abbr&gt; явно написано, что при нулевом значении этих аттрибутов ячейка должна растягиваться на всю строку или столбец. Однако, правильно рендерит ячейки с таким свойством лишь Firefox, а Опера понимает лишь нулевой &lt;code&gt;ROWSPAN&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Пример:&lt;/p&gt;
&lt;table border=&quot;1&quot;&gt;
 &lt;tbody align=&quot;center&quot;&gt;
 &lt;tr&gt;
 &lt;td rowspan=&quot;4&quot;&gt;TD rowspan=4&lt;/td&gt;
 &lt;td colspan=&quot;4&quot;&gt;TD colspan=4&lt;/td&gt;
 &lt;td rowspan=&quot;0&quot;&gt;TD rowspan=0&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;th&gt;simple TH&lt;/th&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td colspan=&quot;0&quot;&gt;TD colspan=0&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;th&gt;simple TH&lt;/th&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;td&gt;simple TD&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Таким образом, ещё одну полезную функциональность, описанную в спецификации, нельзя применять &lt;span class=&quot;nobr&quot;&gt;из-за&lt;/span&gt; неполной поддержки браузерами.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>5 советов верстальщику</title>
    <link href="http://kizu.ru/issues/old/five-tips/"/>
    <updated>2008-05-21T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/five-tips</id>
    <content type="html">&lt;h1 id=&quot;5-советов-верстальщику&quot;&gt;5 советов верстальщику&lt;/h1&gt;
&lt;p&gt;Ну, раз уж мне &lt;a href=&quot;http://lusever.livejournal.com/21502.html&quot;&gt;передали&lt;/a&gt; эстафету, выскажусь. Тем более есть что сказать.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Начиная верстать какой-либо макет, лучше всего делать сперва разметку семантичной и минимальной; никаких лишних обрамляющих блоков, лишних элементов и прочего&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;в итоге получим чёткую структуру и сразу можно будет увидеть сложные и неоднозначные места. Дальше уже можно смотреть на дизайн и размышлять во что бы обернуть имеющееся, стараясь сохранить логическую последовательность в целостности.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Никогда-никогда-никогда нельзя поддаваться соблазнам и верстать только под один-два браузера. Даже если в ТЗ чётко сказано, что «верстаем только под сафари». Это может быть чревато в будущем. Graceful Degradation &amp;amp; Progressive Enhancement&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;очень правильные стратегии.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Верстая страницу, надо избегать искушения опустить общий враппер, задавая определенные стили напрямую для &lt;code&gt;BODY&lt;/code&gt;. Скажем, никогда-никогда-никогда не применяйте такие вещи как&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-css&quot;&gt; BODY {
     margin: 0 auto;
     }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt; Надо учитывать, что возможности &lt;abbr&gt;CSS&lt;/abbr&gt; и браузеров не безграничны и иногда просто физически нельзя разметить макет как &lt;abbr&gt;XML&lt;/abbr&gt;. От правильно примененных дивов семантики не убудет.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Верстая какие-либо сложные элементы, применяя нестандартные методики и изобретая &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; новое, всегда необходимо очень тщательное тестирование. Мало проверить банальную работоспособность в основных браузерах, иногда необходимы очень жесткие тест-сьюты, т.к. иногда работоспособная на первый взляд вещь может взорваться при странных обстоятельствах.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Никогда не следуйте вслепую чужим советам. Всегда сами тестируйте, исследуйте, сомневайтесь. Верстка порой многогранна и советы лучше воспринимать как некую «тему», в сторону которой надо копать, искать материалы, примеры, не ограничиваться маленькими и поверхностными советами.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Передавать эстафету никому не буду, кто захочет&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;напишет, благо тема обширная и, думаю, у многих есть в запасе &lt;span class=&quot;nobr&quot;&gt;что-то&lt;/span&gt; такое, что они хотели бы поделиться.&lt;/p&gt;

    </content>
  </entry>
  <entry>
    <title>Сафари и растягивающяяся textarea</title>
    <link href="http://kizu.ru/issues/old/safari-and-textarea/"/>
    <updated>2008-03-17T00:00:00+03:00</updated>
    <id>http://kizu.ru/issues/old/safari-and-textarea</id>
    <content type="html">&lt;h1 id=&quot;сафари-и-растягивающяяся-textarea&quot;&gt;Сафари и растягивающяяся textarea&lt;/h1&gt;
&lt;p&gt;Одним из достоинств &lt;a href=&quot;http://www.apple.com/safari/&quot;&gt;Сафари&lt;/a&gt; является наличие у текстовых полей (&lt;code&gt;textarea&lt;/code&gt;) уголочка, за который можно потянуть и, соответственно, растянуть поле по вкусу.&lt;/p&gt;
&lt;p&gt;Однако, часто верстальщикам приходится вписывать текстовое поле в какой-нибудь навороченный дизайн и иногда можно обнаружить, что при изменении размеров текстового поля макет рушится, взрывается и что только с ним не происходит (смотря как тянуть).&lt;/p&gt;
&lt;p&gt;Решение же простое&lt;span class=&quot;nobr&quot;&gt; —&lt;/span&gt;&lt;span class=&quot;thinsp&quot;&gt; &lt;/span&gt;использовать свойства &lt;abbr&gt;CSS&lt;/abbr&gt; &lt;code&gt;min-width&lt;/code&gt;, &lt;code&gt;max-width&lt;/code&gt; и такие же &lt;code&gt;-height&lt;/code&gt;; с помощью них можно очень просто настроить желаемое поведение текстовых полей в сафари.&lt;/p&gt;
&lt;p&gt;Кстати, в будущем, задавая минимальную и максимальную высоту и ширину можно будет регулировать и поведение блоков с заданным свойством &lt;abbr&gt;CSS&lt;/abbr&gt;3 &lt;code&gt;resize&lt;/code&gt;. Об этом можно почитать на &lt;a href=&quot;http://www.css3.info/preview/resize/&quot;&gt;соответствующей странице&lt;/a&gt; сайта &lt;abbr&gt;CSS&lt;/abbr&gt;3.info.&lt;/p&gt;

    </content>
  </entry>
</feed>