<!DOCTYPE html>
<html lang="ru" class="Page Page_post Page_ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Новые фичи в Стайлусе</title>
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://feeds.feedburner.com/kizu">
    <link rel="alternate" hreflang="en" href="http://kizu.ru/en/issues/new-stylus-features/">
    <link rel="alternate" hreflang="ru" href="http://kizu.ru/issues/new-stylus-features/">
    <link rel="stylesheet" href="/s/style.css">
    <link rel="preload" href="/s/extras2.css" as="style" onload="this.rel='stylesheet'">
  </head>
  <body class="Page-Body">
    <header class="Page-Header">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <h1 class="Page-Title"><a href="/" class="Page-Title-Link">Роман Комаров</a>
          </h1>
          <ul class="Page-Languages">
            <li class="Page-Language"><a data-short="en" href="/en/issues/new-stylus-features/" class="Page-Language-Link">in English</a>
            </li>
            <li data-short="ru" class="Page-Language is-current">по-русски
            </li>
          </ul>
        </div>
      </div>
    </header>
    <article role="main" class="Page-Content">
      <div class="LiquidLayout">
        <div class="Main LiquidLayout-Content">
          <header><h1 class="Heading" id="новые-фичи-в-стайлусе"><a class="Anchor" aria-hidden="true" href="#новые-фичи-в-стайлусе"></a><span class="ss01 hang-m">Н</span>овые фичи в Стай­лу­се</h1>
          </header>
<p>Пол­го­да на­зад я <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#maintaining" id="maintaining">стал мейн­тей­не­ром</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>О том, как это про­изо­шло и чем имен­но я там за­ни­ма­юсь, я на­пи­шу <span class="nobr">как-ни</span>­будь в дру­гой раз, тут сто­ит за­ме­тить толь­ко то, что я яв­ля­юсь имен­но <em>мейн­тей­не­ром</em>, а ос­нов­ным <em>раз­ра­бот­чи­ком</em> сей­час яв­ля­ет­ся мой кол­ле­га <a href="@panyakor">Миша Ко­ре­па­нов</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> <a class="Link" href="https://github.com/LearnBoost/stylus">Стай­лу­са</a><span class="nobr"> —</span><span class="thinsp"> </span>от­лич­но­го пре­про­цес­со­ра для <abbr>CSS</abbr>.</p>
<p>На про­шлой неде­ле мы за­ре­ли­зи­ли но­вую вер­сию<span class="nobr"> —</span><span class="thinsp"> </span><a class="Link" href="https://github.com/LearnBoost/stylus/blob/master/History.md#0410--2013-11-30">0.41.0</a>, в ко­то­рой до­ба­ви­ли пару важ­ных фич. А в двух ре­ли­зах до это­го мы до­ба­ви­ли под­держ­ку хе­шей и от­по­ли­ро­ва­ли её, в ре­зуль­та­те этих трёх по­след­них ре­ли­зов те­перь мож­но де­лать мно­го все­го ин­те­рес­но­го. В этой за­мет­ке я опи­шу <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#example-sidenote" id="example-sidenote">один под­ход</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Мо­же­те сра­зу про­мо­тать до <a href="#example">его по­ша­го­во­го опи­са­ния</a>, либо до <a href="#result">ре­зуль­ти­ру­ю­ще­го кода</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>, ко­то­рый те­перь мож­но при­ме­нять в Стай­лу­се, но для на­ча­ла я на­пи­шу немно­го про но­вые фичи.</p>
<h2 class="Heading" id="block-mixins"><a class="Anchor" aria-hidden="true" href="#block-mixins"></a><span class="ss01 hang-m">Б</span>лоч­ные мик­сины</h2>
<p>На­ко­<span class="nobr">нец-то</span>! То, чего так дав­но не хва­та­ло в Стай­лу­се (и что уже дав­но есть в Sass)<span class="nobr"> —</span><span class="thinsp"> </span>воз­мож­ность пе­ре­да­вать в мик­син блок кода.</p>
<p>Син­так­сис пе­ре­да­чи бло­ка до­воль­но про­стой: вы­зы­ва­ем мик­син, ис­поль­зуя пре­фикс «+», по­сле чего пе­ре­да­ём со­от­вет­ству­ю­щий блок либо в фи­гур­ных скоб­ках, либо че­рез блок с но­вым от­сту­пом (как всё обыч­но де­ла­ет­ся в Стай­лу­се):</p>
<pre><code class="language-styl">+foo()
  // Блок, ко­то­рый мы хо­тим пе­ре­дать
  width: 10px
  height: 10px
</code></pre>
<p>По­сле того как мы пе­ре­да­ли блок в мик­син, этот блок стал до­сту­пен внут­ри мик­си­на как име­но­ван­ный ар­гу­мент<span class="nobr"> —</span><span class="thinsp"> </span><code>block</code>. По­сле чего <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#pass" id="pass">его мож­но вы­ве­сти</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Та­к­же мы мо­жем пе­ре­дать эту пе­ре­мен­ную в дру­гой мик­син, или вос­поль­зо­вать­ся ей <span class="nobr">как-то</span> ина­че, при­мер в кон­це ста­тьи за­вя­зан имен­но на этом<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> че­рез <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#block-call" id="block-call">ин­тер­по­ля­цию</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>В бу­ду­щем, воз­мож­но, до­ба­вит­ся воз­мож­ность ис­поль­зо­вать его без ин­тер­по­ля­ции<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>:</p>
<pre><code class="language-styl">foo()
  width: 20px
  .foo
    {block}
</code></pre>
<p>Если вы­звать этот мик­син, на­при­мер, так:</p>
<pre><code class="language-styl">.bar
  +foo()
    padding: 0
    .baz
      height: 20px
</code></pre>
<p>Мы по­лу­чим сле­ду­ющее:</p>
<pre><code class="language-css">.bar {
  width: 20px;
}
.bar .foo {
  padding: 0;
}
.bar .foo .baz {
  height: 20px;
}
</code></pre>
<p>Мы по­лу­чи­ли воз­мож­ность об­рам­лять бло­ки с по­мо­щью мик­си­нов во что угод­но (а в бу­ду­щем, воз­мож­но, до­ба­вим и воз­мож­ность <em>из­ме­нять</em> пе­ре­дан­ные бло­ки). Обыч­но это ис­поль­зу­ют для ра­бо­ты с ме­ди­а­к­ве­ря­ми,<span class="nobr"> —</span><span class="thinsp"> </span>мой при­мер, ко­то­рый бу­дет ниже в ста­тье, как раз из той же об­ласти.</p>
<h2 class="Heading" id="hashes"><a class="Anchor" aria-hidden="true" href="#hashes"></a><span class="ss01 hang-m">Х</span>еши</h2>
<p>Хеши<span class="nobr"> —</span><span class="thinsp"> </span>объ­ек­ты вида «свой­ство-зна­че­ние». Вы­гля­дят они до­воль­но просто:</p>
<pre><code class="language-javascript">foo = {
  bar: 10px,
  raz: #fff,
  baz: {
    blah: blah
    &#39;10%&#39;: yeah
  }
}
</code></pre>
<p>Как вид­но из при­ме­ра, син­так­сис по­хож на обыч­ные явас­крип­то­вые объ­ек­ты: клю­чом мо­жет быть или иден­ти­фи­ка­тор, или стро­ка, а зна­че­ни­ем мо­жет быть по­чти что угод­но, в том чис­ле и вло­жен­ный хеш. Из важ­но­го: в от­ли­чие от обыч­ных бло­ков Стай­лу­са, фи­гур­ные скоб­ки для хе­шей обя­за­тель­ны, но вот за­пя­тые<span class="nobr"> —</span><span class="thinsp"> </span><span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#codestyle" id="codestyle">нет</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Как и осталь­ные оп­ци­о­наль­ные фичи син­так­си­са, если не при­дер­жи­вать­ся ка­ко­<span class="nobr">го-то</span> кон­крет­но­го код-стай­ла, то код бу­дет нечи­та­бель­ным, так что ре­ши­те как вы бу­де­те пи­сать хеши и бло­ки, и при­дер­жи­вай­тесь это­го ре­ше­ния<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>.</p>
<p>По­сле того, как вы объ­яви­ли хеш, мож­но в него до­ба­вить но­вые свой­ства или пе­ре­за­пи­сать ста­рые либо че­рез точ­ку, либо че­рез квад­рат­ные скобки:</p>
<pre><code class="language-styl">foo.bar = 20px
foo[&#39;what­ever&#39;] = &#39;hello&#39;
</code></pre>
<p>От­ли­чия до­воль­но про­стые: че­рез точ­ку мож­но пи­сать толь­ко иден­ти­фи­ка­то­ры, то­гда как в квад­рат­ных скоб­ках мож­но ис­поль­зо­вать лю­бые стро­ки, либо пе­ре­да­вать пе­ре­мен­ные. В об­щем, с квад­рат­ны­ми скоб­ка­ми по­лу­ча­ет­ся бо­лее гиб­ко, а че­рез точ­ку<span class="nobr"> —</span><span class="thinsp"> </span>ко­роче.</p>
<p>По­лу­чать свой­ства мож­но ана­ло­гич­но<span class="nobr"> —</span><span class="thinsp"> </span>либо че­рез точ­ку, либо че­рез квад­рат­ные скобки.</p>
<p>Не буду опи­сы­вать осталь­ные воз­мож­но­сти хе­шей<span class="nobr"> —</span><span class="thinsp"> </span>их <a class="Link" href="http://learnboost.github.io/stylus/docs/hashes.html">до­воль­но мно­го</a>, от­ме­чу, что с ними нор­маль­но ра­бо­та­ет встро­ен­ная функ­ция Стай­лу­са <code>length()</code>, по ним мож­но ите­ри­ро­вать­ся, мож­но про­ве­рять на­ли­чие клю­чей в усло­ви­ях (<code>if baz in foo</code>), а та­к­же есть несколь­ко встро­ен­ных функ­ций для ра­бо­ты с хе­ша­ми (<code>keys()</code>, <code>val­ues()</code>, <code>merge()</code>) и ин­тер­по­ля­ция хе­шей в <abbr>CSS</abbr>-код.</p>
<h2 class="Heading" id="selector"><a class="Anchor" aria-hidden="true" href="#selector"></a><span class="ss01 hang-xs">Ф</span>унк­ция <code>se­lec­tor()</code></h2>
<p>В но­вом Стай­лу­се по­яви­лась неболь­шая, но важ­ная фича<span class="nobr"> —</span><span class="thinsp"> </span>функ­ция <code>se­lec­tor()</code>. До неё в Стай­лу­се не было воз­мож­но­сти <strong>по­лу­чить</strong> те­ку­щий се­лек­тор: его мож­но было со­став­лять из вло­жен­ных бло­ков, ин­тер­по­ли­ро­вать в него, но узнать ка­кой же в ито­ге по­лу­ча­ет­ся се­лек­тор было нельзя.</p>
<p>Те­перь же есть функ­ция <code>se­lec­tor()</code>, ко­то­рая воз­вра­ща­ет те­ку­щий ском­пи­ли­ро­ван­ный се­лек­тор. Его мож­но ис­поль­зо­вать либо для раз­лич­ных про­ве­рок, либо для ка­ких-либо иных це­лей. Уже сей­час эта функ­ция бу­дет очень по­лез­на в раз­ных си­ту­а­ци­ях, а в бу­ду­щих ре­ли­зах она ста­нет ещё мощнее.</p>
<p>В ка­че­стве при­ме­ра я при­ве­ду вот та­кой неболь­шой ку­сок кода:</p>
<pre><code class="language-styl">if match(&#39;:(be­fore|af­ter)&#39;, se­lec­tor())
  con­tent: &#39;&#39;
</code></pre>
<p>Здесь мы про­ве­ря­ем есть ли в се­лек­то­ре ука­за­ние на псев­до­эле­мент, и если так<span class="nobr"> —</span><span class="thinsp"> </span>вы­во­дим <code>con­tent</code>. Это мо­жет при­го­дить­ся, если у вас есть мик­син, це­ли­ком от­ве­ча­ю­щий за ка­<span class="nobr">кое-то</span> по­ве­де­ние, и ко­то­рый мож­но при­ме­нить как к обыч­но­му эле­мен­ту, так и к псев­<span class="nobr">до-эле</span>­менту.</p>
<h2 class="Heading" id="example"><a class="Anchor" aria-hidden="true" href="#example"></a><span class="ss01 hang-m">П</span>ри­мер с ке­ши­ру­е­мы­ми ме­ди­а­к­ве­рями</h2>
<p>В ка­че­стве при­ме­ра ис­поль­зо­ва­ния но­вых фич я при­ве­ду ре­ше­ние од­ной из про­блем мод­но­го нын­че от­зыв­чи­во­го ди­зай­на: огром­но­го ко­ли­че­ства пе­ре­опре­де­ле­ний, ко­то­рые нуж­но рас­став­лять для раз­ных вью­пор­тов. Про­бле­ма за­клю­ча­ет­ся в том, что син­так­сис вы­зо­ва ме­ди­а­к­ве­рей до­воль­но раз­ве­си­стый, по­это­му при­хо­дит­ся либо не об­ра­щать на это вни­ма­ние и ис­поль­зо­вать <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#bubbling" id="bubbling">«<span class="Link-Inner">всплы­тие ме­ди­а­к­ве­рей</span>»</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>В пре­про­цес­со­рах, если ис­поль­зо­вать ме­ди­а­к­ве­ри внут­ри дру­гих бло­ков, они всплы­ва­ют на­верх, со­хра­няя те­ку­щий се­лек­тор<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>, либо, в по­гоне за оп­ти­ми­за­ци­ей, пи­сать все пе­ре­опре­де­ле­ния ря­дом, что во мно­гих си­ту­а­ци­ях бу­дет ме­нее удобно.</p>
<p>Од­на­ко, с блоч­ны­ми мик­си­на­ми, хе­ша­ми и функ­ци­ей <code>se­lec­tor()</code> в Стай­лу­се те­перь мож­но обой­ти эти про­бле­мы (и по­пут­но ре­шить ещё пару дру­гих).</p>
<p>Если крат­ко опи­сать ре­ше­ние: мы со­зда­дим мик­син, за­ме­ня­ю­щий вы­зо­вы ме­ди­а­к­ве­рей и ке­ши­ру­ю­щий их, объ­еди­няя по усло­ви­ям, по­сле чего даём воз­мож­ность вы­ве­сти весь за­ке­ши­ро­ван­ный та­ким об­ра­зом код.</p>
<p>Един­ствен­ным недо­стат­ком та­ко­го под­хо­да бу­дет то, что если несколь­ко усло­вий ме­ди­а­к­ве­рей бу­дут пе­ре­се­кать­ся, то, <span class="nobr">из-за</span> груп­пи­ров­ки всех пра­вил по объ­еди­нён­ным ме­ди­а­к­ве­рям, по­ря­док при­ме­не­ния этих пра­вил мо­жет по­ме­няться.</p>
<p>Для на­ча­ла нам по­на­до­бит­ся объ­ект, в ко­то­рый мы бу­дем со­хра­нять вы­зван­ный в бу­ду­щем код:</p>
<pre><code class="language-styl">$me­di­a_­cache = {}
</code></pre>
<p>По­сле это­го нам бу­дет ну­жен мик­син, ко­то­рый мы и бу­дем ис­поль­зо­вать вме­сто ме­ди­а­к­ве­рей, в пер­вом при­бли­же­нии он бу­дет вы­гля­деть <span class="nobr">как-то</span> так:</p>
<pre><code class="language-styl">me­dia($con­di­tion)
  un­less $me­di­a_­cache[$con­di­tion]
    $me­di­a_­cache[$con­di­tion] = ()
  push($me­di­a_­cache[$con­di­tion], block)
</code></pre>
<p>Мик­син до­воль­но про­стой: если у нас ещё нет в кеше спис­ка по пе­ре­дан­но­му в мик­син клю­чу, мы ини­ци­и­ру­ем этот спи­сок, по­сле чего пу­шим в него пе­ре­дан­ный в мик­син блок<span class="nobr"> —</span><span class="thinsp"> </span>это бу­дет наш кеш.</p>
<p>На са­мом деле нам это­го не бу­дет до­ста­точ­но: та­кой мик­син мож­но бу­дет ис­поль­зо­вать толь­ко вот так:</p>
<pre><code class="language-styl">+me­dia(&#39;(max-width:640px)&#39;)
  .foo
    dis­play: block;
</code></pre>
<p>Мы смо­жем про­ки­ды­вать внутрь толь­ко пол­но­цен­ные бло­ки, у нас не по­лу­чит­ся ис­поль­зо­вать всплытие:</p>
<pre><code class="language-styl">.foo
  +me­dia(&#39;(max-width:640px)&#39;)
    dis­play: block;
</code></pre>
<p>Всё <span class="nobr">из-за</span> того, что мик­син пока ни­че­го не зна­ет о сво­ём кон­тек­сте<span class="nobr"> —</span><span class="thinsp"> </span>он зна­ет толь­ко о бло­ке, ко­то­рый в него пе­ре­да­ли. <span class="nobr">Тут-то</span> нам и по­мо­жет функ­ция <code>se­lec­tor()</code>, да ещё один мик­<span class="nobr">син-по</span>­мощ­ник<span class="nobr"> —</span><span class="thinsp"> </span>вме­сте с ними наш мик­син бу­дет вы­гля­деть так:</p>
<pre><code class="language-styl">me­dia($con­di­tion)
  helper($con­di­tion)
    un­less $me­di­a_­cache[$con­di­tion]
      $me­di­a_­cache[$con­di­tion] = ()
    push($me­di­a_­cache[$con­di­tion], block)

  +helper($con­di­tion)
    {se­lec­tor()}
      {block}
</code></pre>
<p>Для того, что­бы со­хра­нять кон­текст, мы вы­но­сим из­на­чаль­ный код, по­ме­ща­ю­щий пе­ре­дан­ный блок в кеш, в мик­син <code>helper</code>, ко­то­рый тут же и вы­зы­ва­ем, об­рам­ляя пе­ре­дан­ный блок в те­ку­щий се­лектор.</p>
<p>Так как те­перь при вы­зо­ве на­ше­го мик­си­на всё бу­дет по­ме­щать­ся в кеш, оно не бу­дет вы­во­дить­ся само по себе. Зна­чит, нам нуж­на функ­ция, ко­то­рая возь­мёт со­дер­жи­мое кеша и вы­плес­нет его там, где мы эту функ­цию при­ме­ним (ло­гич­но бу­дет вы­зы­вать её в кон­це фай­ла):</p>
<pre><code class="language-styl">ap­ply_­me­di­a_­cache()
  for $me­dia, $blocks in $me­di­a_­cache
    @me­dia $me­dia
      for $block in $blocks
        {$block}
</code></pre>
<p>Всё до­воль­но про­сто: сна­ча­ла ите­ри­ру­ем­ся по кешу, по­лу­чая по оче­ре­ди усло­вия (<code>$me­dia</code>) и спи­сок вы­зван­ных с та­ким усло­ви­ем бло­ков (<code>$blocks</code>), по­сле чего со­зда­ём со­от­вет­ству­ю­щую ме­ди­а­к­ве­ри, внут­ри ко­то­рой уже ите­ри­ру­ем­ся по всем бло­кам, вы­во­дя их один за другим.</p>
<p>Те­перь, если мы в кон­це до­ку­мен­та вы­зо­вем эту функцию:</p>
<pre><code class="language-styl">ap­ply_­me­di­a_­cache()
</code></pre>
<p>мы по­лу­чим то, ради чего всё за­те­вали.</p>
<p>Од­на­ко, и эту функ­цию мож­но улуч­шить: ведь мы не хо­тим каж­дый раз пи­сать при вы­зо­ве ско­боч­ки, да и, на са­мом деле, хо­ро­шо бы все­гда иметь в усло­ви­ях <code>only screen and</code>. Кро­ме того, мы и во­все мо­жем за­хо­теть ис­поль­зо­вать вме­сто кон­крет­ных зна­че­ний клю­че­вые сло­ва, типа <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#keywords" id="keywords"><code>palm</code>, <code>portable</code>, <code>desk</code></a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Для при­ме­ра я вы­брал гра­да­ции из фрейм­вор­ка <a href="@csswizardry">Гар­ри Ро­берт­са</a> <a href="http://inuitcss.com/">inuit.css</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> и т.п. Вме­сте с до­пол­не­ни­я­ми и все­ми преды­ду­щи­ми ша­га­ми мы по­лу­ча­ем вот та­кой код:</p>
<h3 class="Heading" id="result"><a class="Anchor" aria-hidden="true" href="#result"></a><span class="ss01 hang-m">И</span>то­го­вый код</h3>
<pre><code class="language-styl">// Опре­де­ля­ем объ­ект кеша и объ­ект с али­а­са­ми
$me­di­a_­cache = {}
$me­di­a_aliases = {
  palm:       &#39;(max-width: 480px)&#39;
  lap:        &#39;(min-width: 481px) and (max-width: 1023px)&#39;
  lap-and-up: &#39;(min-width: 481px)&#39;
  portable:   &#39;(max-width: 1023px)&#39;
  desk:       &#39;(min-width: 1024px)&#39;
  desk-wide:  &#39;(min-width: 1200px)&#39;
}

// Мик­син, ке­ши­ру­ю­щий ме­ди­а­к­ве­ри
me­dia($con­di­tion)
  helper($con­di­tion)
    un­less $me­di­a_­cache[$con­di­tion]
      $me­di­a_­cache[$con­di­tion] = ()
    push($me­di­a_­cache[$con­di­tion], block)

  +helper($con­di­tion)
    {se­lec­tor() + &#39;&#39;}
      {block}

// Функ­ция, вы­зы­ва­ю­щая за­ке­ши­ро­ван­ные ме­ди­а­к­ве­ри
ap­ply_­me­di­a_­cache()
  for $me­dia, $blocks in $me­di­a_­cache
    $me­dia = un­quote($me­di­a_aliases[$me­dia] || $me­dia)
    $me­dia = &#39;(%s)&#39; % $me­dia un­less match(&#39;\(&#39;, $me­dia)
    $me­dia = &#39;only screen and %s&#39; % $me­dia
    @me­dia $me­dia
      for $block in $blocks
        {$block}

// Здесь бу­дет ос­нов­ной код с вы­зо­ва­ми мик­си­на
// …

// Вы­зы­ва­ем все за­ке­ши­ро­ван­ные ме­ди­а­к­ве­ри
ap­ply_­me­di­a_­cache()
</code></pre>
<p>Те­перь мы мо­жем пи­сать код при­мер­но так:</p>
<pre><code class="language-styl">.foo
  width: 10px

  +me­dia(&#39;lap&#39;)
    width: 20px

  +me­dia(&#39;desk&#39;)
    width: 30px

  +me­dia(&#39;min-width: 200px&#39;)
    width: 60px

.bar
  height: 10px

  +me­dia(&#39;lap&#39;)
    height: 20px

  +me­dia(&#39;desk&#39;)
    height: 30px

  +me­dia(&#39;min-width: 200px&#39;)
    height: 50px

  +me­dia(&#39;(min-width: 500px) and (max-width: 700px)&#39;)
    height: 50px
</code></pre>
<p>И в ре­зуль­та­те по­лу­чим сле­ду­ющее:</p>
<pre><code class="language-css">.foo {
  width: 10px;
}
.bar {
  height: 10px;
}
@me­dia only screen and (min-width: 481px) and (max-width: 1023px) {
  .foo {
    width: 20px;
  }
  .bar {
    height: 20px;
  }
}
@me­dia only screen and (min-width: 1024px) {
  .foo {
    width: 30px;
  }
  .bar {
    height: 30px;
  }
}
@me­dia only screen and (min-width: 200px) {
  .foo {
    width: 60px;
  }
  .bar {
    height: 50px;
  }
}
@me­dia only screen and (min-width: 500px) and (max-width: 700px) {
  .bar {
    height: 50px;
  }
}
</code></pre>
<p>В по­след­нем ва­ри­ан­те функ­ции <code>ap­ply_­me­di­a_­cache</code> мож­но уви­деть, что мы до­ба­ви­ли объ­ект с али­а­са­ми. Кро­ме того, мы те­перь мо­жем вы­зы­вать мик­син как в со­кра­щён­ном ва­ри­ан­те, без ско­бок, так и со скоб­ка­ми<span class="nobr"> —</span><span class="thinsp"> </span>все ва­ри­ан­ты бу­дут ра­ботать.</p>
<p>В ито­ге, бла­го­да­ря но­вым воз­мож­но­стям, по­явив­шим­ся в по­след­них вер­си­ях Стай­лу­са, мы по­лу­чи­ли воз­мож­ность быст­ро и удоб­но ис­поль­зо­вать всплы­ва­ю­щие ме­ди­а­к­ве­ри в коде, с али­а­са­ми на клю­че­вые сло­ва и с груп­пи­ров­кой ре­зуль­ти­ру­ю­ще­го кода по ме­ди­а­к­верям.</p>
<p>На­вер­ня­ка этот код не иде­а­лен, его мож­но улуч­шать и улуч­шать, но моей це­лью было по­ка­зать но­вые фичи, а по­лу­чив­ши­я­ся функ­ция<span class="nobr"> —</span><span class="thinsp"> </span>лишь ре­зультат.</p>

          <p class="Metadata Published">Опубликовано 
            <time datetime="2013-12-05">5 декабря 2013 г.</time> в <a href="../" class="Link">Заметках</a>.
          </p>
          <p class="Metadata ThanksTo">Спасибо <a class="Link" href="https://twitter.com/sapegin">Артёму Сапегину</a> за уместные замечания.
          </p>
          <aside class="Feedback">
            <p>Если вы заметили ошибку или хотите чем-то дополнить статью, вы всегда можете <a href="https://github.com/kizu/kizu.github.com/issues/new?title=%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BD%D0%B0%20%C2%AB%D0%9D%D0%BE%D0%B2%D1%8B%D0%B5%20%D1%84%D0%B8%D1%87%D0%B8%20%D0%B2%20%D0%A1%D1%82%D0%B0%D0%B9%D0%BB%D1%83%D1%81%D0%B5%C2%BB" class="Link">написать мне об этом</a>, или <a href="https://github.com/kizu/kizu.github.com/blob/source/src/documents/posts/2013-12-05-(issues)-new-stylus-features/index.ru.md" class="Link">поправить статью прямо на Гитхабе</a>.
            </p>
          </aside>
        </div>
      </div>
    </article>
    <footer class="Page-Footer">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <nav class="PrevNext"><a href="/blog/ios7/" class="Link Link_wrapper Link_prev"><span class="Link-Inner">iOS 7</span></a><a href="/blog/flex-baseline/" class="Link Link_wrapper Link_next"><span class="Link-Inner">Битва за базовую линию</span></a>
          </nav>
          <p role="contentinfo" class="Page-Copy"><a href="/" class="Link Link_wrapper">© 2016 <span class="Link-Inner">Роман Комаров</span>. </a><a href="https://twitter.com/ki_zu" class="Link Link_wrapper"><span class="Link-Inner">Читайте меня в твиттере</span>!</a>
          </p>
        </div>
      </div>
    </footer>
    <script>var supportsWoff2=function(A){if(!("FontFace"in A)||"function"!=typeof A.FontFace)return!1;var t=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAADcAAoAAAAAAggAAACWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk4ALAoUNAE2AiQDCAsGAAQgBSAHIBtvAcieB3aD8wURQ+TZazbRE9HvF5vde4KCYGhiCgq/NKPF0i6UIsZynbP+Xi9Ng+XLbNlmNz/xIBBqq61FIQRJhC/+QA/08PJQJ3sK5TZFMlWzC/iK5GUN40psgqvxwBjBOg6JUSJ7ewyKE2AAaXZrfUB4v+hze37ugJ9d+DeYqiDwVgCawviwVFGnuttkLqIMGivmDg" ) format( "woff2" )',{});return t.load()["catch"](function(){}),"loading"==t.status||"loaded"==t.status}(this),h=document.getElementsByTagName("head")[0],link=document.createElement("link");link.href="/s/extras"+(supportsWoff2?"2":"")+".css",link.type="text/css",link.rel="stylesheet",h.appendChild(link);
    </script>
    <script src="/j/prism.js"></script>
    <script src="//mc.yandex.ru/metrika/watch.js"></script>
    <script type="text/javascript">
      //<![CDATA[
      (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter632758 = new Ya.Metrika({id:632758, clickmap:true, trackLinks:true, trackHash:true, webvisor:true}); } catch(e) {} }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f); } else { f(); } })(document, window, "yandex_metrika_callbacks");
      //]]>
    </script>
    <noscript><img src="//mc.yandex.ru/watch/632758" style="position:absolute; left:-9990px;" alt=""></noscript>
  </body>
</html>