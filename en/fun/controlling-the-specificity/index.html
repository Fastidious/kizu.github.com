<!DOCTYPE html>
<html lang="en" class="Page Page_post Page_en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Controlling the Specificity</title>
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://feeds.feedburner.com/kizuruen">
    <link rel="stylesheet" href="/s/style.css">
    <link rel="preload" href="/s/extras2.css" as="style" onload="this.rel='stylesheet'">
  </head>
  <body class="Page-Body">
    <header class="Page-Header">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <h1 class="Page-Title"><a href="/en/" class="Page-Title-Link">Roman Komarov</a>
          </h1>
          <ul class="Page-Languages">
            <li data-short="en" class="Page-Language is-current">in English
            </li>
            <li class="Page-Language"><a data-short="ru" title="Для этой статьи пока нет перевода, почему — можете узнать перейдя по этой ссылке" href="/blog/just-en/" class="Page-Language-Link">по-русски?</a>
            </li>
          </ul>
        </div>
      </div>
    </header>
    <article role="main" class="Page-Content">
      <div class="LiquidLayout">
        <div class="Main LiquidLayout-Content">
          <header><h1 class="Heading" id="controlling-the-specificity"><a class="Anchor" aria-hidden="true" href="#controlling-the-specificity"></a><span class="ss02 hang-xs">C</span>ontrolling the Specificity</h1>
          </header>
<p>In <a class="Link" href="/en/fun/conditions-for-css-variables/">the pre­vi­ous ar­ti­cle about con­di­tions for <abbr>CSS</abbr> vari­ables</a> I talked about things that could be used rather soon, even if the sup­port for them is not there yet. In this ar­ti­cle I&#39;ll go even fur­<span class="nobr">ther —</span><span class="thinsp"> </span>I&#39;ll be talk­ing about one thing from the <a class="Link" href="https://drafts.csswg.org/selectors-4/"><abbr>CSS</abbr> Se­lec­tors Level 4</a>, which is even less adopted.</p>
<p>The part of this spec I&#39;ll be look­ing at to­day is the new, en­hanced <code>:not()</code>. Im­por­tant dis­claimer: the fea­ture I would talk about have al­most to no sup­port at the mo­ment (only lat­est Sa­fari?), and even if it did, I wouldn&#39;t rec­om­mend to use it as some­thing other than ex­per­i­ment. You&#39;ll see why. And af­ter dis­cussing what be­comes pos­si­ble with this new <code>:not()</code> I&#39;ll de­scribe one more us­able sim­i­lar thing and then pro­pose a few things that I think should be there in <abbr>CSS</abbr> in­stead.</p>
<h2 class="Heading" id="the-all-new-negation-pseudoclass"><a class="Anchor" aria-hidden="true" href="#the-all-new-negation-pseudoclass"></a><span class="ss01 hang-m">T</span>he All-New Negation Pseudoclass</h2>
<p>In Se­lec­tors Level 3 <code>:not()</code> could have only a sin­gle sim­ple se­lec­tor in­side of it. The lev­<span class="nobr">eled-up</span> ver­sion al­lows for so much more!</p>
<p>The <a class="Link" href="https://drafts.csswg.org/selectors-4/#negation">spec­i­fi­ca­tion for the <code>:not()</code></a> doesn&#39;t say much about its new fea­tures. Al­most all it says is that in­stead of a sim­ple se­lec­tor you can put a <strong>se­lec­tor list</strong> in­side. But that alone means a lot.</p>
<h3 class="Heading" id="selector-lists"><a class="Anchor" aria-hidden="true" href="#selector-lists"></a><span class="ss01 hang-xs">S</span>elector Lists</h3>
<p>So, now we can use comma-sep­a­rated se­lec­tor lists in­side any <code>:not()</code>. The com­mas in usual comma-sep­a­rated se­lec­tor lists are an equiv­a­lent of log­i­cal <strong>or</strong>, but when used in­side the <code>:not()</code> they ac­tu­ally be­come <strong>and</strong>.</p>
<p>Look at this ex­am­<span class="nobr">ple —</span><span class="thinsp"> </span>such se­lec­tor would tar­get all but­tons that are not hov­ered and not fo­cused <em>at the same time</em>:</p>
<pre><code class="language-css">button:not(:hover, :focus)
</code></pre>
<p>And it is ba­si­cally an equiv­a­lent of</p>
<pre><code class="language-css">button:not(:hover):not(:focus)
</code></pre>
<p>The dif­fer­ence there is how the speci­ficity works for se­lec­tor lists in­side <code>:not()</code>, here is <a class="Link" href="https://drafts.csswg.org/selectors-4/#specificity-rules">what Spec says</a>:</p>
<blockquote>
<p>The speci­ficity of a <code>:not()</code> pseudo-class is re­placed by the speci­ficity of the most spe­cific com­plex se­lec­tor in its se­lec­tor list ar­gument.</p>
</blockquote>
<p>That means that the speci­ficity of <code>:not(:hover, :fo­cus)</code> is the same as the speci­ficity of a sin­gle class, so it is re­ally dif­fer­ent than if you&#39;d just use mul­ti­ple <code>:not()</code>s. You can fit any num­ber of se­lec­tors in­side a se­lec­tor list in­side <code>:not()</code>, and you still would get the speci­ficity of only the high­est one. And if the speci­ficity would be the same for each se­lec­tor in a list, you&#39;ll get only this speci­ficity.</p>
<p>This is a first cru­cial fea­ture for our case.</p>
<h3 class="Heading" id="complex-selectors"><a class="Anchor" aria-hidden="true" href="#complex-selectors"></a><span class="ss02 hang-xs">C</span>omplex Selectors</h3>
<p>The sec­ond cru­cial fea­ture is that those se­lec­tor lists can now con­tain com­plex se­lec­tors. Be­fore, you could put only a sim­ple se­lec­tor in­side <code>:not()</code>, but now there won&#39;t be such limit, so you could do stuff like <code>:not(a.foo:nth-child(2n+1):hover)</code> and it would just work.</p>
<p>An­other in­ter­est­ing thing in <code>:not()</code> now ac­cept­ing com­plex se­lec­tors, is that it can also ac­cept se­lec­tors with com­bi­na­tors like <code>:not(.foo + .bar)</code>.</p>
<h3 class="Heading" id="negation-of-negation"><a class="Anchor" aria-hidden="true" href="#negation-of-negation"></a><span class="ss01 hang-m">N</span>egation of Negation</h3>
<p>Of course, since the <code>:not()</code> se­lec­tor is it­self a com­plex one, you can now use it in­side other <code>:not()</code>s.</p>
<p>And, yeah, we&#39;re at the point where the magic would hap­pen. What does dou­ble nega­tion mean in logic? It re­turns the value to its orig­i­nal bi­nary state.</p>
<p>If we&#39;d have some­thing like that:</p>
<pre><code class="language-css">:not(:not(:hover))
</code></pre>
<p>That would work just the same as a <code>:hover</code> pseudo­class. That&#39;s rather sim­ple. But what would hap­pen if we&#39;d have a se­lec­tor list there?</p>
<pre><code class="language-css">:not(:not(:hover), :not(:focus))
</code></pre>
<p>As the se­lec­tor lists in­side <code>:not()</code> work as a log­i­cal <strong>and</strong>, and given that each of the se­lec­tors would be re­turned to its orig­i­nal mean­ing, the re­sult would be al­most the same as <code>:hover:fo­cus</code>. The dif­fer­ence would be that the speci­ficity of the dou­ble negated se­lec­tor wouldn&#39;t be the same as of the usual com­plex one. Each of the nested <code>:not()</code> would have a speci­ficity of a sin­gle pseudo­class, and due to how se­lec­tor lists work in­side <code>:not()</code>, the speci­ficity of the whole con­struc­tion would be equal, again, to a speci­ficity of a sin­gle pseudo­class.</p>
<h2 class="Heading" id="reducing-the-specificity"><a class="Anchor" aria-hidden="true" href="#reducing-the-specificity"></a><span class="ss01 hang-m">R</span>educing the Specificity</h2>
<p>I think you can al­ready guess what all of this means. That&#39;s <span class="nobr">right —</span><span class="thinsp"> </span>us­ing the new <code>:not()</code> we can now write se­lec­tors with a speci­ficity of a sin­gle class. And, ac­tu­ally, we can write <em>al­most any se­lec­tor</em> this way.</p>
<p>So, if we&#39;d like to have a mul­ti­class se­lec­tor with some states, like <code>.foo.bar.baz:link:hover</code> and for it to have a speci­ficity of a sin­gle class, so it could be eas­ier over­rid­den later on, we could rewrite this se­lec­tor this way:</p>
<pre><code class="language-css">:not(:not(.foo), :not(.bar), :not(.baz), :not(:link), :not(:hover))
</code></pre>
<h3 class="Heading" id="what-about-combinators-"><a class="Anchor" aria-hidden="true" href="#what-about-combinators-"></a><span class="ss01 hang-m">W</span>hat About Combinators?</h3>
<p>But what if we&#39;d like to have more com­plex se­lec­tors with com­bi­na­tors, like this one?</p>
<pre><code class="language-css">.foo:hover &gt; .bar .baz
</code></pre>
<p>They&#39;re pos­si­ble too, but with a slightly more com­plex code. What would help us is a uni­ver­sal se­lec­tor. Here is how the se­lec­tor above could look like if we&#39;d want it to have a speci­ficity of a sin­gle class:</p>
<pre><code class="language-css">:not(:not(:not(:not(:not(:not(.foo), :not(:hover)) &gt; *), :not(.bar)) *), :not(.baz))
</code></pre>
<p>That looks aw­ful, right? But <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#works" id="works">that works!</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Here is a <a href="http://codepen.io/kizu/pen/PbgYNV">test at Code­Pen</a> with this se­lec­tor, if you&#39;d open it in the lat­est Sa­fari, you&#39;ll see it in ac­tion.<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span></p>
<p>Of course, it would be­come a bit read­able if we&#39;d use some in­den­ta­tions and stuff:</p>
<pre><code class="language-css">:not(
    :not(
        :not(
            :not(
                :not(
                    :not(.foo),
                    :not(:hover)
                ) &gt; *
            ),
            :not(.bar)
        ) *
    ),
    :not(.baz)
)
</code></pre>
<p>Still ugly, but man­age­able (and now, if you&#39;d imag­ine all of the <code>:not()</code> and uni­ver­sal se­lec­tors would dis­ap­pear, you could read it al­most as our orig­i­nal se­lec­tor).</p>
<p>But why it works? Due to how the se­lec­tor match­ing mech­a­nism works, the se­lec­tors with com­bi­na­tors would match from right to left, so the right­most se­lec­tor would be al­ways the one that matches the el­e­ment we&#39;re test­ing the <code>:not()</code> on, so we could safely use just a uni­ver­sal se­lec­tor in­stead of it if we need to just check the par­ents. And the uni­ver­sal se­lec­tor brings no speci­ficity with it.</p>
<p>The al­go­rithm be­yond rewrit­ing the se­lec­tor this way is rather sim­ple: we go from right to left, re­plac­ing re­cur­sively all the parts with the dou­ble nega­tions, so for when we have nested com­bi­na­tors, we would have more nested <code>:not()</code>s. And this way we would al­ways be guar­an­teed to have the same speci­ficity on each step.</p>
<h2 class="Heading" id="complete-control"><a class="Anchor" aria-hidden="true" href="#complete-control"></a><span class="ss02 hang-xs">C</span>omplete Control</h2>
<p>It worth men­tion­ing that we can al­ready in­crease the speci­ficity of any given class just by <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#foofoofoo" id="foofoofoo">mul­ti­ply­ing it</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>You can read about this method in Harry Roberts&#39; <a href="http://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/#safely-increasing-specificity">ar­ti­cle on speci­ficity hacks</a> (and, as Harry, I first saw this method in <a href="https://speakerdeck.com/mathiasbynens/3-dot-14-things-i-didnt-know-about-css-at-css-day-2014">Math­ias By­nens&#39; talk</a>).<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>, so <code>.foo.foo.foo</code> matches just the same as <code>.foo</code>, but with a speci­ficity of three classes. And as we can now both re­duce and in­crease the speci­ficity of al­most any given se­lec­tors, that means we can, fi­nally, <strong>con­trol</strong> the speci­ficity of our se­lec­tors, re­gard­less of their com­plex­ity. Of course, with the ex­cep­tion that we can&#39;t re­duce the speci­ficity to be less than the one of the biggest sin­gle se­lec­tor&#39;s one, so we can&#39;t make a se­lec­tor that con­tains a class to be as spe­cific as an el­e­ment se­lec­tor or a uni­ver­sal one.</p>
<h2 class="Heading" id="preprocessors-"><a class="Anchor" aria-hidden="true" href="#preprocessors-"></a><span class="ss01 hang-m">P</span>reprocessors?</h2>
<p>Yes, it is pos­si­ble to pro­gram­mat­i­cally con­vert al­most any se­lec­tor to the same se­lec­tor with any cus­tom speci­ficity from one class to any given num­ber. But I in­ten­tion­ally won&#39;t im­ple­ment it now. As I men­tioned at the <span class="nobr">start —</span><span class="thinsp"> </span>the browser sup­port for the new <code>:not()</code> is not yet there, and even if it would be there, the gen­er­ated code we&#39;d get for such se­lec­tors would be aw­ful. If you&#39;d like a small chal­lenge, you can go and im­ple­ment it just for fun us­ing any pre­proces­sor or post­proces­sor you like, but I don&#39;t rec­om­mend on us­ing it any­where close to pro­duction.</p>
<h2 class="Heading" id="possible-usage"><a class="Anchor" aria-hidden="true" href="#possible-usage"></a><span class="ss01 hang-m">P</span>ossible Usage</h2>
<p>One of the eas­i­est tar­gets for con­trol­ling the speci­ficity are any re­sets or nor­mal­iz­ing <span class="nobr">styles —</span><span class="thinsp"> </span>right now they of­ten con­tain things like at­tribute se­lec­tors and pseudo­classes like <code>:nth-child</code>, and given that those se­lec­tors would also have the el­e­ment se­lec­tors, they would al­ways be higher than a sin­gle class in speci­ficity, which would make it harder to over­ride it in the code for your blocks.</p>
<p>For ex­am­ple, you can look at <a class="Link" href="https://github.com/necolas/normalize.css/blob/1da0911/normalize.css#L125">one part</a> of Nico­las Gal­lagher&#39;s nor­mal­ize.css:</p>
<pre><code class="language-css">/**
 * 1. Remove the bottom border in Firefox 39-.
 * 2. Add the correct text decoration in Chrome, Edge, IE, Opera, and Safari.
 */
abbr[title] {
  border-bottom: none; /* 1 */
  text-decoration: underline; /* 2 */
  text-decoration: underline dotted; /* 2 */
}
</code></pre>
<p>Here if you&#39;d like to have a com­po­nent that uses <code>&lt;abbr&gt;</code> and you&#39;d want a bor­der or text-dec­o­ra­tion other than un­der­lined, you couldn&#39;t use a sin­gle class for this com­po­nent in your <abbr>CSS</abbr> along­side us­ing nor­mal­ize.<span class="nobr">css —</span><span class="thinsp"> </span>you&#39;d need to over­ride the speci­ficity of two classes in­stead.</p>
<p>But if we could re­duce the speci­ficity of each se­lec­tor in our re­sets and nor­mal­izes to the small­<span class="nobr">est —</span><span class="thinsp"> </span>of a sin­gle el­e­ment or a sin­gle <span class="nobr">class —</span><span class="thinsp"> </span>those tools would be­come even more pow­er­ful and flex­ible.</p>
<p>An­other area where the con­trol over speci­ficity is a must have are any com­plex <abbr>CSS</abbr> method­olo­gies. The eas­i­est ex­am­ple would be Harry Roberts&#39; <a class="Link" href="http://itcss.io">it<abbr>CSS</abbr></a> <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#itcss" id="itcss">which</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>There is not much writ­ten on it any­where, if you&#39;d like to read more on it, you can try <a href="https://www.xfive.co/blog/itcss-scalable-maintainable-css-architecture/">this ar­ti­cle</a> by Lu­bos Kmetko.<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> have lay­ers of se­lec­tors united by sim­i­lar area of re­spon­si­bil­ity. If we could split those lay­ers so they wouldn&#39;t merge in their speci­ficity, we would ob­tain the ul­ti­mate power over <abbr>CSS</abbr> (ok, I ex­ag­ger­ated it a bit there).</p>
<p>Our gen­eral styles for ty­pog­ra­phy would be al­ways higher in speci­ficity than the re­sets; our generic ob­jects would al­ways over­ride the ty­pog­ra­phy styles of any com­plex­ity; our com­po­nents would al­ways be guar­an­teed to over­ride the styles of generic ob­jects; and any util­i­ties would al­ways over­ride any­thing else, and all with­out us­ing <code>!im­por­tant</code>. And we could even han­dle things in­side each layer by cre­at­ing sub-lay­ers, to al­low mod­i­fiers for com­po­nents to over­ride their base styles even if those base styles are some­what complex.</p>
<h3 class="Heading" id="try-it-today"><a class="Anchor" aria-hidden="true" href="#try-it-today"></a><span class="ss01 hang-m">T</span>ry It Today</h3>
<p>Talk­ing about all of <span class="nobr">this —</span><span class="thinsp"> </span>we can al­ready kinda im­ple­ment our styles this way us­ing noth­ing but the in­creas­ing of speci­ficity avail­able al­ready.</p>
<p>The al­go­rithm would be sim­ple: for each layer we need to cal­cu­late the max­i­mum speci­ficity, then add a num­ber of re­dun­dant match­ing class se­lec­tors to each se­lec­tor in a way they would split all the things into groups.</p>
<p>Let&#39;s say we have an ab­stract ob­ject&#39;s se­lec­tor: <code>.but­ton:hover</code>, then a com­po­nent <code>.My­Block-Sub­mit</code>, and, fi­nally, a util­ity <code>.is-hid­den</code>. We can leave alone the first layer for the ob­ject, it would be the most bot­tom one. Then we cal­cu­late that it have two class-level se­lec­tors, so we add that num­ber (plus one, to guar­an­tee the over­ride of any pos­si­ble generic se­lec­tor there) to each se­lec­tor of the sec­ond layer of com­po­nents. Then we cal­cu­late the speci­ficity of the com­po­nent layer (here we have just one class ini­tially, in re­al­ity, it would be of­ten much larger, plus the three classes from the pre­vi­ous layer, plus one for re­li­a­bil­ity) and add the cor­re­spond­ing num­ber of re­dun­dant class se­lec­tors to any­thing in util­ity group.</p>
<p>The eas­i­est (and the one method with the most sup­port) way to add the de­sired speci­ficity is pos­si­ble if you have con­trol over the <abbr>HTML</abbr> of a page: just add a class con­tain­ing a sin­gle un­der­score to <code>html</code> el­e­<span class="nobr">ment —</span><span class="thinsp"> </span><code>&lt;html class=&quot;_&quot;&gt;</code>, and then use the chains of <code>._._</code> be­fore your se­lec­tors. It would look like this:</p>
<pre><code>.button:hover {}
._._._ .MyBlock-Submit {}
._._._._._ .is-hidden {}
</code></pre>
<p>The only is­sue that can hap­pen is that one of the se­lec­tors you&#39;re pre­fix­ing would have a part that tar­gets a root se­lec­tor. In case of <code>:root</code> or <code>html</code> ones we could rather eas­ily prop­erly at­tach this part to the ac­tual se­lec­tor, for more am­bigu­ous se­lec­tors we&#39;d need to du­pli­cate it like <code>._._._._.is-hid­den, ._._._._ .is-hid­den</code>, though, if you know that you&#39;re do­ing, you prob­a­bly wouldn&#39;t want to use any other classes on root.</p>
<p>And here we have all of the lay­ers sep­a­rated in a way their or­der doesn&#39;t mat­ter at all and you could make any layer as com­plex as you like with­out the fear of the need to over­ride it later. And yes, you&#39;d still have all the usual <abbr>CSS</abbr> speci­ficity rules in­side of lay­ers if you&#39;d want to use them for more gran­u­lar con­trol of things.</p>
<h2 class="Heading" id="proposal-for-native-tools"><a class="Anchor" aria-hidden="true" href="#proposal-for-native-tools"></a><span class="ss01 hang-m">P</span>roposal For Native Tools</h2>
<p>In this ar­ti­cle, I have shown that it would be al­ready pos­si­ble to set the speci­ficity of any se­lec­tor to any given num­ber from one class to eter­nity. This could be used for more fine-grained con­trol over your li­braries&#39; code and com­po­nents, and in my prac­tice, I had nu­mer­ous oc­ca­sions where it would be tremen­dously helpful.</p>
<p>That&#39;s why I pro­pose to add the nec­es­sary tools to na­tive <nobr><abbr>CSS</abbr>&#8202;—</nobr>&#8202;to al­low de­vel­op­ers to con­trol the speci­ficity. Oth­er­wise, it is pos­si­ble de­vel­op­ers in need would rely on hacks and aw­ful code in the future.</p>
<p>What ex­actly I pro­pose? Cer­tainly <strong>not</strong> some­thing like a pseudo­class for mod­i­fy­ing the speci­ficity of a given se­lec­tor. That would have too com­plex syn­tax (how would you pass the speci­ficity to it?) and you&#39;ll need to use this just any­where when solv­ing your usual <abbr>CSS</abbr> prob­lems. That&#39;s bad.</p>
<p>What I&#39;d like to see is some kind of a more gen­eral way of con­trol­ling the speci­ficity not for spe­cific se­lec­tors or rules, but for groups of rules. I think of some kind of an @-rule for it, so you could group any num­ber of rules in a “layer”, then some­how de­ter­mine the re­la­tion­ships of those lay­ers be­tween them­selves, and voilà<span class="nobr"> —</span><span class="thinsp"> </span>you&#39;d have a way to con­trol the <em>cas­cade</em> it­self, the thing that al­ways was out of touch when you were de­vel­op­ing your stylesheets.</p>
<p>And the best <span class="nobr">part —</span><span class="thinsp"> </span>speci­ficity is a part of <abbr>CSS</abbr> that is ap­plied only for se­lec­tors, it doesn&#39;t de­pend on <abbr>DOM</abbr>, on any in­her­i­tance there etc. So there shouldn&#39;t be a lot of trou­bles im­ple­ment­ing some­thing that changes the speci­ficity it­self (or cre­ates groups of it like it is al­ready there with the dif­fer­ent parts of the cas­cade).</p>
<h2 class="Heading" id="conclusion"><a class="Anchor" aria-hidden="true" href="#conclusion"></a><span class="ss02 hang-xs">C</span>onclusion</h2>
<p><abbr>CSS</abbr> is fun, and as this ar­ti­cle shows, would be re­ally pow­er­ful with the tools new Specs would pro­vide. There would be in­cred­i­ble things pos­si­ble through hacks. There are al­ready hacks like <code>.foo.foo.foo</code> for mod­i­fy­ing the speci­ficity, and those tools can al­low us to write and reuse the code that is more ef­fec­tive and main­tain­able than ever.</p>
<p>But I&#39;d like to see those things pos­si­ble not through hacks, but us­ing the na­tive <abbr>CSS</abbr>. I think this is en­tirely pos­si­ble to im­ple­ment in browsers.</p>

          <p class="Metadata Published">Published on 
            <time datetime="2016-12-21">December 21, 2016</time>, in <a href="../" class="Link">Experiments</a>.
          </p>
          <aside class="Feedback">
            <p>If you've spotted a typo or a mistake, or wish to add something on, you could either <a href="https://github.com/kizu/kizu.github.com/issues/new?title=Feedback%20for%20%E2%80%9CControlling%20the%20Specificity%E2%80%9D" class="Link">write me about this</a> or <a href="https://github.com/kizu/kizu.github.com/blob/source/src/documents/posts/2016-12-21-(fun)-controlling-the-specificity/index.en.md" class="Link">edit this article on Github</a>.
            </p>
          </aside>
        </div>
      </div>
    </article>
    <footer class="Page-Footer">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <nav class="PrevNext"><a href="/en/fun/conditions-for-css-variables/" class="Link Link_wrapper Link_prev"><span class="Link-Inner">Conditions for CSS Variables</span></a><a href="/en/blog/label-to-input/" class="Link Link_wrapper Link_next"><span class="Link-Inner">Label-to-Input States</span></a>
          </nav>
          <p role="contentinfo" class="Page-Copy"><a href="/en/" class="Link Link_wrapper">© 2017 <span class="Link-Inner">Roman Komarov</span>. </a><a href="https://twitter.com/kizmarh" class="Link Link_wrapper"><span class="Link-Inner">Follow me on twitter</span>!</a>
          </p>
        </div>
      </div>
    </footer>
    <script>var supportsWoff2=function(A){if(!("FontFace"in A)||"function"!=typeof A.FontFace)return!1;var t=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAADcAAoAAAAAAggAAACWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk4ALAoUNAE2AiQDCAsGAAQgBSAHIBtvAcieB3aD8wURQ+TZazbRE9HvF5vde4KCYGhiCgq/NKPF0i6UIsZynbP+Xi9Ng+XLbNlmNz/xIBBqq61FIQRJhC/+QA/08PJQJ3sK5TZFMlWzC/iK5GUN40psgqvxwBjBOg6JUSJ7ewyKE2AAaXZrfUB4v+hze37ugJ9d+DeYqiDwVgCawviwVFGnuttkLqIMGivmDg" ) format( "woff2" )',{});return t.load()["catch"](function(){}),"loading"==t.status||"loaded"==t.status}(this),h=document.getElementsByTagName("head")[0],link=document.createElement("link");link.href="/s/extras"+(supportsWoff2?"2":"")+".css",link.type="text/css",link.rel="stylesheet",h.appendChild(link);
    </script>
    <script src="/j/prism.js"></script>
    <script src="//mc.yandex.ru/metrika/watch.js"></script>
    <script type="text/javascript">
      //<![CDATA[
      (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter632758 = new Ya.Metrika({id:632758, clickmap:true, trackLinks:true, trackHash:true, webvisor:true}); } catch(e) {} }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f); } else { f(); } })(document, window, "yandex_metrika_callbacks");
      //]]>
    </script>
    <noscript><img src="//mc.yandex.ru/watch/632758" style="position:absolute; left:-9990px;" alt=""></noscript>
  </body>
</html>