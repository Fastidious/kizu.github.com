<!DOCTYPE html>
<html lang="en" class="Page Page_post Page_en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>New Stylus Features</title>
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://feeds.feedburner.com/kizuruen">
    <link rel="alternate" hreflang="en" href="http://kizu.ru/en/issues/new-stylus-features/">
    <link rel="alternate" hreflang="ru" href="http://kizu.ru/issues/new-stylus-features/">
    <link rel="stylesheet" href="/s/style.css">
    <link rel="preload" href="/s/extras2.css" as="style" onload="this.rel='stylesheet'">
  </head>
  <body class="Page-Body">
    <header class="Page-Header">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <h1 class="Page-Title"><a href="/en/" class="Page-Title-Link">Roman Komarov</a>
          </h1>
          <ul class="Page-Languages">
            <li data-short="en" class="Page-Language is-current">in English
            </li>
            <li class="Page-Language"><a data-short="ru" href="/issues/new-stylus-features/" class="Page-Language-Link">по-русски</a>
            </li>
          </ul>
        </div>
      </div>
    </header>
    <article role="main" class="Page-Content">
      <div class="LiquidLayout">
        <div class="Main LiquidLayout-Content">
          <header><h1 class="Heading" id="new-stylus-features"><a class="Anchor" aria-hidden="true" href="#new-stylus-features"></a><span class="ss01 hang-m">N</span>ew Sty­lus Fea­tures</h1>
          </header>
<p>Not so long ago I <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#maintaining" id="maintaining">be­came a main­tainer</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>I&#39;ll write some­day later how this hap­pened and what ex­actly I do there, but it worth to men­tion that I&#39;m <em>a main­tainer</em>, but the main <em>de­vel­oper</em> now is my col­league <a href="gh:panya">Mikhail Ko­repanov</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> for <a class="Link" href="https://github.com/LearnBoost/stylus">Sty­lus</a> <abbr>CSS</abbr> pre­proces­sor. At the end of the last week, we re­leased a new ver­<span class="nobr">sion —</span><span class="thinsp"> </span><a class="Link" href="https://github.com/LearnBoost/stylus/blob/master/History.md#0410--2013-11-30">0.41.0</a><span class="nobr"> —</span><span class="thinsp"> </span>where we added some new fea­tures. And in the two ear­lier re­leases we added sup­port for the hashes and pol­ished it, so af­ter all this work it is now pos­si­ble to do a lot of in­ter­est­ing new things. In this ar­ti­cle, I&#39;ll ex­plain one <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#example-sidenote" id="example-sidenote">new tech</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>You can go straight to <a href="#example">its <span class="nobr">step-by</span>-step ex­pla­na­tion</a>, or to the <a href="#result">re­sult­ing code</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> that is now pos­si­ble in the new Sty­lus, but I&#39;ll de­scribe the new fea­tures for a start.</p>
<h2 class="Heading" id="block-mixins"><a class="Anchor" aria-hidden="true" href="#block-mixins"></a><span class="ss01 hang-m">B</span>lock mixins</h2>
<p>Fi­nally! The thing that was miss­ing from Sty­lus for so <span class="nobr">long —</span><span class="thinsp"> </span>the abil­ity to pass blocks of Sty­lus code into mix­ins and then use those blocks in­side the mix­ins&#39; bodies.</p>
<p>The syn­tax for pass­ing the block is rather sim­ple: we call a mixin us­ing a <code>+</code> pre­fix, then we pass the block ei­ther in the curly braces, or us­ing a new in­dent level (as you could do with a lot of things in Sty­lus):</p>
<pre><code class="language-styl">+foo()
  // The block we want to pass
  width: 10px
  height: 10px
</code></pre>
<p>Af­ter we passed the block to the mixin, this block be­comes avail­able in­side of it as a named ar­gu­<span class="nobr">ment —</span><span class="thinsp"> </span><code>block</code>. You can then use it any­where in­side the mixin us­ing <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#block-call" id="block-call">an in­ter­po­la­tion</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>There is a pos­si­bil­ity we would add a way of us­ing it with­out in­ter­po­la­tion in the fu­ture though<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>:</p>
<pre><code class="language-styl">foo()
  width: 20px
  .foo
    {block}
</code></pre>
<p>Or we could pass this as a vari­able to the next mixin, or use it in any other way.</p>
<p>Any­way, if you&#39;ve called a mixin above like this:</p>
<pre><code class="language-styl">.bar
  +foo()
    padding: 0
    .baz
      height: 20px
</code></pre>
<p>You would get this:</p>
<pre><code class="language-css">.bar {
  width: 20px;
}
.bar .foo {
  padding: 0;
}
.bar .foo .baz {
  height: 20px;
}
</code></pre>
<p>With block mix­ins, we have a way of wrap­ping blocks with mix­ins and then wrap­ping them with any­thing. This fea­ture is of­ten used for han­dling me­dia queries, and my ex­am­ple that you&#39;ll see later in this ar­ti­cle is also from the <abbr>RWD</abbr> area.</p>
<h2 class="Heading" id="hashes"><a class="Anchor" aria-hidden="true" href="#hashes"></a><span class="ss01 hang-m">H</span>ashes</h2>
<p>As I al­ready men­tioned, in the lat­est re­leases of Sty­lus we added (and pol­ished to a us­able state) hashes as a data type. Hashes are ob­jects with key-value pairs, and they look rather simple:</p>
<pre><code class="language-javascript">foo = {
  bar: 10px,
  raz: #fff,
  baz: {
    blah: blah
    &#39;10%&#39;: yeah
  }
}
</code></pre>
<p>As you can see from this ex­am­ple, the syn­tax is sim­i­lar to the ob­jects in JavaScript: the key could be ei­ther an in­dent or a string, and any­thing could go into value, even nested hashes. An im­por­tant part: while you can use or­di­nary blocks with or with­out curly braces in Sty­lus, they are manda­tory for hashes, while the trail­ing com­mas <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#codestyle" id="codestyle">are not</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>And as with all other op­tional syn­tax fea­tures of Sty­lus, you should use a con­sis­tent code style in your stylesheets. Oth­er­wise your code would be messy as hell<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>.</p>
<p>Then, af­ter you de­fined a hash, you could add new prop­er­ties to it or re­de­fine old ones us­ing dots or square brackets:</p>
<pre><code class="language-styl">foo.bar = 20px
foo[&#39;what­ever&#39;] = &#39;hello&#39;
</code></pre>
<p>The dif­fer­ences are sim­ple: while you could use only idents with the dot syn­tax, with square brack­ets you could pass any string con­tain­ing any sym­bols, or use a vari­able in­stead. So, the brack­ets are more flex­i­ble, while the dot is not.</p>
<p>You can get the val­ues from the hash in the same <span class="nobr">way —</span><span class="thinsp"> </span>ei­ther by us­ing a dot or us­ing the square brackets.</p>
<p>I won&#39;t de­scribe <a class="Link" href="http://learnboost.github.io/stylus/docs/hashes.html">all the fea­tures</a> of the hashes, I&#39;ll just men­tion that you can use the <span class="nobr">built-in</span> <code>length()</code> func­tion with them, you can it­er­ate through them, use them in con­di­tions (<code>if baz in foo</code>), and there are also some <span class="nobr">built-in</span> func­tions to work with hashes (<code>keys()</code>, <code>val­ues()</code>, <code>merge()</code>). And you can in­ter­po­late hashes into <abbr>CSS</abbr>.</p>
<h2 class="Heading" id="selector"><a class="Anchor" aria-hidden="true" href="#selector"></a><code>se­lec­tor()</code> function</h2>
<p>There is now one small but im­por­tant fea­ture in Sty­<span class="nobr">lus —</span><span class="thinsp"> </span><code>se­lec­tor()</code>. While you can con­struct com­plex se­lec­tors in Sty­lus by us­ing nested blocks, in­ter­po­la­tions, mix­ins and other things, you couldn&#39;t <strong>get</strong> the com­piled se­lec­tor, they only ex­isted in the com­piled <abbr>CSS</abbr>.</p>
<p>But now, us­ing <code>se­lec­tor()</code> func­tion that re­turns the cur­rently com­piled se­lec­tor, you could do a lot of use­ful things, like check the se­lec­tor for some­thing us­ing the <code>match()</code> func­tion, or use it for some­thing else. It is al­ready very use­ful, and it would be­come even more so in fu­ture re­leases.</p>
<p>As an ex­am­ple, you can take this small chunk of code:</p>
<pre><code class="language-styl">if match(&#39;:(be­fore|af­ter)&#39;, se­lec­tor())
  con­tent: &#39;&#39;
</code></pre>
<p>Here we check if the se­lec­tor has any <span class="nobr">pseudo-el</span>­e­ments in it and if <span class="nobr">so —</span><span class="thinsp"> </span>we ap­ply the <code>con­tent</code>. This could be use­ful if we have some mixin, con­tain­ing styles that could be ap­plied both to a nor­mal el­e­ment and to a pseudo one.</p>
<h2 class="Heading" id="example"><a class="Anchor" aria-hidden="true" href="#example"></a><span class="ss01 hang-m">E</span>xam­ple with cached me­dia queries</h2>
<p>As a us­age ex­am­ple of the new Sty­lus fea­tures, I&#39;ll give you a so­lu­tion for one of those small, re­spon­sive web de­sign prob­lems: the code you need to write for dif­fer­ent view­port break­points. The prob­lem is that the syn­tax of me­dia queries could be rather long, so you could ei­ther use bub­bling me­dia queries which would re­sult in not ideal <abbr>CSS</abbr>, or, in the race for bytes, you&#39;ll need to write all the over­rides in one place, and that won&#39;t be very com­fort­able in a lot of sit­u­a­tions.</p>
<p>How­ever, in the new Sty­lus, with block mix­ins, hashes and the <code>se­lec­tor()</code> func­tion, you could work around this prob­lem (and solve some oth­ers on your way to it).</p>
<p><span class="nobr">Briefly —</span><span class="thinsp"> </span>we can cre­ate a mixin that could be used in­stead of me­dia queries and would cache the given blocks, com­bin­ing them by con­di­tions, so you could then out­put all of them us­ing the sec­ond function.</p>
<p>The only down­side of this method is the group­ing it­<span class="nobr">self —</span><span class="thinsp"> </span>the se­lec­tors would be in a dif­fer­ent or­der, so the speci­ficity of the se­lec­tors could change.</p>
<p>For the start we need an ob­ject where we would store the cached blocks:</p>
<pre><code class="language-styl">$me­di­a_­cache = {}
</code></pre>
<p>Then we would need a mixin which we could use in­stead of me­dia queries; its ba­sic form would be this:</p>
<pre><code class="language-styl">me­dia($con­di­tion)
  un­less $me­di­a_­cache[$con­di­tion]
    $me­di­a_­cache[$con­di­tion] = ()
  push($me­di­a_­cache[$con­di­tion], block)
</code></pre>
<p>This mixin&#39;s logic is rather sim­ple: if we don&#39;t have a list of the blocks for a given con­di­tion, we ini­tial­ize it then we pass the block to this list.</p>
<p>It won&#39;t be enough for us ac­tu­ally: this mixin could be used only this way:</p>
<pre><code class="language-styl">+me­dia(&#39;(max-width:640px)&#39;)
  .foo
    dis­play: block;
</code></pre>
<p>We could only pass full blocks to it, but couldn&#39;t use the bub­bling:</p>
<pre><code class="language-styl">.foo
  +me­dia(&#39;(max-width:640px)&#39;)
    dis­play: block;
</code></pre>
<p>The code of our <code>me­dia</code> mixin doesn&#39;t know any­thing about the con­text, the se­lec­tor where we called <span class="nobr">it —</span><span class="thinsp"> </span>yet. Here the new <code>se­lec­tor()</code> func­tion and an ex­tra helper mixin are re­quired, and with them <code>me­dia</code> mixin would look like this:</p>
<pre><code class="language-styl">me­dia($con­di­tion)
  helper($con­di­tion)
    un­less $me­di­a_­cache[$con­di­tion]
      $me­di­a_­cache[$con­di­tion] = ()
    push($me­di­a_­cache[$con­di­tion], block)

  +helper($con­di­tion)
    {se­lec­tor()}
      {block}
</code></pre>
<p>To save the con­text we move the ini­tial code of this mixin in­side a helper mixin, then call it pass­ing the <code>block</code> in­side the in­ter­po­lated<code>se­lec­tor()</code>.</p>
<p>So, as we now wrap the code with a mixin, it won&#39;t build au­to­mat­i­cally. We would need to call a func­tion that would take a cache and put all it con­tains where we call it (and it would be log­i­cal to call it at the end of our stylesheet):</p>
<pre><code class="language-styl">ap­ply_­me­di­a_­cache()
  for $me­dia, $blocks in $me­di­a_­cache
    @me­dia $me­dia
      for $block in $blocks
        {$block}
</code></pre>
<p>It is rather easy: we it­er­ate through the cache, tak­ing the con­di­<span class="nobr">tion —</span><span class="thinsp"> </span><code>$me­dia</code>, and the list of all the blocks that were called with <span class="nobr">it —</span><span class="thinsp"> </span><code>$blocks</code>, then we cre­ate the me­dia query with that con­di­tion and in­side of it it­er­ate through all the blocks, yield­ing all of them one by one.</p>
<p>So, if we would then call this func­tion at the end of the doc­ument:</p>
<pre><code class="language-styl">ap­ply_­me­di­a_­cache()
</code></pre>
<p>We would get what we want.</p>
<p>How­ever, there are a few things to im­prove in this func­tion: we do not want al­ways to write the paren­the­ses, and, ac­tu­ally, we won&#39;t want to write all those <code>only screen and</code>. Also, we would want to use some key­words in­stead of the lit­eral con­di­tions, like <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#keywords" id="keywords"><code>palm</code>, <code>portable</code>, <code>desk</code></a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>I&#39;ve taken the names from the great <a href="http://inuitcss.com/">inuit.css</a> frame­work by <a href="@csswizardry">Harry Roberts</a><span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> and so on. With those im­prove­ments and all the pre­vi­ous steps the re­sult­ing code would be this:</p>
<h3 class="Heading" id="result"><a class="Anchor" aria-hidden="true" href="#result"></a><span class="ss01 hang-m">R</span>esult­ing code</h3>
<pre><code class="language-styl">// De­fine the cache and the aliases
$me­di­a_­cache = {}
$me­di­a_aliases = {
  palm:       &#39;(max-width: 480px)&#39;
  lap:        &#39;(min-width: 481px) and (max-width: 1023px)&#39;
  lap-and-up: &#39;(min-width: 481px)&#39;
  portable:   &#39;(max-width: 1023px)&#39;
  desk:       &#39;(min-width: 1024px)&#39;
  desk-wide:  &#39;(min-width: 1200px)&#39;
}

// Mixin for caching the blocks with the given con­di­tions
me­dia($con­di­tion)
  helper($con­di­tion)
    un­less $me­di­a_­cache[$con­di­tion]
      $me­di­a_­cache[$con­di­tion] = ()
    push($me­di­a_­cache[$con­di­tion], block)

  +helper($con­di­tion)
    {se­lec­tor() + &#39;&#39;}
      {block}

// Func­tion we would use to call all the cached styles
ap­ply_­me­di­a_­cache()
  for $me­dia, $blocks in $me­di­a_­cache
    $me­dia = un­quote($me­di­a_aliases[$me­dia] || $me­dia)
    $me­dia = &#39;(%s)&#39; % $me­dia un­less match(&#39;\(&#39;, $me­dia)
    $me­dia = &#39;only screen and %s&#39; % $me­dia
    @me­dia $me­dia
      for $block in $blocks
        {$block}

// Here would be our main styles, us­ing the `me­dia` mixin
// …

// Here we call all the cached styles
ap­ply_­me­di­a_­cache()
</code></pre>
<p>Then we could write our stylesheets like this:</p>
<pre><code class="language-styl">.foo
  width: 10px

  +me­dia(&#39;lap&#39;)
    width: 20px

  +me­dia(&#39;desk&#39;)
    width: 30px

  +me­dia(&#39;min-width: 200px&#39;)
    width: 60px

.bar
  height: 10px

  +me­dia(&#39;lap&#39;)
    height: 20px

  +me­dia(&#39;desk&#39;)
    height: 30px

  +me­dia(&#39;min-width: 200px&#39;)
    height: 50px

  +me­dia(&#39;(min-width: 500px) and (max-width: 700px)&#39;)
    height: 50px
</code></pre>
<p>And get this re­sult af­ter­wards:</p>
<pre><code class="language-css">.foo {
  width: 10px;
}
.bar {
  height: 10px;
}
@me­dia only screen and (min-width: 481px) and (max-width: 1023px) {
  .foo {
    width: 20px;
  }
  .bar {
    height: 20px;
  }
}
@me­dia only screen and (min-width: 1024px) {
  .foo {
    width: 30px;
  }
  .bar {
    height: 30px;
  }
}
@me­dia only screen and (min-width: 200px) {
  .foo {
    width: 60px;
  }
  .bar {
    height: 50px;
  }
}
@me­dia only screen and (min-width: 500px) and (max-width: 700px) {
  .bar {
    height: 50px;
  }
}
</code></pre>
<p>In the re­sult­ing code, we can see that we added the hash with aliases, we can also call the mixin with con­di­tions lack­ing paren­theses.</p>
<p>By us­ing this code we can now use me­dia queries bub­bling any­where we want and don&#39;t even need to think about the ex­tra <span class="nobr">bytes —</span><span class="thinsp"> </span>every­thing would be nicely grouped in­side non-dou­bling me­dia queries. All thanks to the new Sty­lus fea­tures.</p>
<p>Of course, this code is not ideal, and there could be a lot of ways to im­prove it, but my goal was to demon­strate the new fea­tures and how they work, af­ter all.</p>

          <p class="Metadata Published">Published on 
            <time datetime="2013-12-05">December 5, 2013</time>, in <a href="../" class="Link">Articles</a>.
          </p>
          <p class="Metadata ThanksTo">Thanks to <a class="Link" href="https://twitter.com/iandevlin">Ian Devlin</a> for the proofreading.
          </p>
          <aside class="Feedback">
            <p>If you've spotted a typo or a mistake, or wish to add something on, you could either <a href="https://github.com/kizu/kizu.github.com/issues/new?title=Feedback%20for%20%E2%80%9CNew%20Stylus%20Features%E2%80%9D" class="Link">write me about this</a> or <a href="https://github.com/kizu/kizu.github.com/blob/source/src/documents/posts/2013-12-05-(issues)-new-stylus-features/index.en.md" class="Link">edit this article on Github</a>.
            </p>
          </aside>
        </div>
      </div>
    </article>
    <footer class="Page-Footer">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <nav class="PrevNext"><a href="/en/blog/updated-jekyll/" class="Link Link_wrapper Link_prev"><span class="Link-Inner">Updated Jekyll</span></a><a href="/en/blog/flex-baseline/" class="Link Link_wrapper Link_next"><span class="Link-Inner">Battle for Baseline</span></a>
          </nav>
          <p role="contentinfo" class="Page-Copy"><a href="/en/" class="Link Link_wrapper">© 2017 <span class="Link-Inner">Roman Komarov</span>. </a><a href="https://twitter.com/kizmarh" class="Link Link_wrapper"><span class="Link-Inner">Follow me on twitter</span>!</a>
          </p>
        </div>
      </div>
    </footer>
    <script>var supportsWoff2=function(A){if(!("FontFace"in A)||"function"!=typeof A.FontFace)return!1;var t=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAADcAAoAAAAAAggAAACWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk4ALAoUNAE2AiQDCAsGAAQgBSAHIBtvAcieB3aD8wURQ+TZazbRE9HvF5vde4KCYGhiCgq/NKPF0i6UIsZynbP+Xi9Ng+XLbNlmNz/xIBBqq61FIQRJhC/+QA/08PJQJ3sK5TZFMlWzC/iK5GUN40psgqvxwBjBOg6JUSJ7ewyKE2AAaXZrfUB4v+hze37ugJ9d+DeYqiDwVgCawviwVFGnuttkLqIMGivmDg" ) format( "woff2" )',{});return t.load()["catch"](function(){}),"loading"==t.status||"loaded"==t.status}(this),h=document.getElementsByTagName("head")[0],link=document.createElement("link");link.href="/s/extras"+(supportsWoff2?"2":"")+".css",link.type="text/css",link.rel="stylesheet",h.appendChild(link);
    </script>
    <script src="/j/prism.js"></script>
    <script src="//mc.yandex.ru/metrika/watch.js"></script>
    <script type="text/javascript">
      //<![CDATA[
      (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter632758 = new Ya.Metrika({id:632758, clickmap:true, trackLinks:true, trackHash:true, webvisor:true}); } catch(e) {} }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f); } else { f(); } })(document, window, "yandex_metrika_callbacks");
      //]]>
    </script>
    <noscript><img src="//mc.yandex.ru/watch/632758" style="position:absolute; left:-9990px;" alt=""></noscript>
  </body>
</html>