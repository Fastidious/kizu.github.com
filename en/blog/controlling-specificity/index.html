<!DOCTYPE html>
<html lang="en" class="Page Page_post Page_en without-sidebar">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=EmulateIE7,IE=edge">
    <title>Controlling Specificity</title>
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://feeds.feedburner.com/kizuruen">
    <link rel="stylesheet" href="/s/style.css">
    <link rel="preload" href="/s/extras2.css" as="style" onload="this.rel='stylesheet'">
  </head>
  <body class="Page-Body">
    <header role="banner" class="Page-Header">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <h1 class="Page-Title"><a href="/en/" class="Page-Title-Link">Roman Komarov</a>
          </h1>
          <ul class="Page-Languages">
            <li data-short="en" class="Page-Language is-current">in English
            </li>
            <li class="Page-Language"><a data-short="ru" title="Для этой статьи нет перевода, но для многих других — есть" href="/" class="Page-Language-Link">по-русски*</a>
            </li>
          </ul>
        </div>
      </div>
    </header>
    <article role="main" class="Page-Content">
      <div class="LiquidLayout">
        <div class="Main LiquidLayout-Content">
          <header><h1 class="Heading" id="controlling-specificity"><a class="Anchor" aria-hidden="true" href="#controlling-specificity"></a><span class="ss02 hang-xs">C</span>on<span class="shy"></span>trol<span class="shy"></span>ling Speci<span class="shy"></span>ficity</h1>
          </header>
<p>In <a class="Link" href="/en/fun/conditions-for-css-variables/">pre<span class="shy"></span>vi<span class="shy"></span>ous ar<span class="shy"></span>ti<span class="shy"></span>cle about con<span class="shy"></span>di<span class="shy"></span>tions for <abbr>CSS</abbr> vari<span class="shy"></span>ables</a> I talked about things that could be used rather soon, even if the sup<span class="shy"></span>port is not there yet. In this ar<span class="shy"></span>ti<span class="shy"></span>cle I&#39;ll go even fur<span class="shy"></span><nobr>ther —</nobr><span class="thinsp"> </span>I&#39;ll be talk<span class="shy"></span>ing about one thing from the <a class="Link" href="https://drafts.csswg.org/selectors-4/"><abbr>CSS</abbr> Se<span class="shy"></span>lec<span class="shy"></span>tors Level 4</a>, which is even less adopted yet.</p>
<p>The part of this spec I&#39;ll be look<span class="shy"></span>ing at to<span class="shy"></span>day is the new, en<span class="shy"></span>hanced <code>:not()</code>.</p>
<h2 class="Heading" id="the-all-new-negation-pseudoclass"><a class="Anchor" aria-hidden="true" href="#the-all-new-negation-pseudoclass"></a><span class="ss01 hang-m">T</span>he All-New Nega<span class="shy"></span>tion Pseudoclass</h2>
<p>In Se<span class="shy"></span>lec<span class="shy"></span>tors Level 3 <code>:not()</code> could have only a sin<span class="shy"></span>gle sim<span class="shy"></span>ple se<span class="shy"></span>lec<span class="shy"></span>tor in<span class="shy"></span>side of it. The lev<span class="shy"></span><nobr>eled-up</nobr> ver<span class="shy"></span>sion al<span class="shy"></span>lows for so much more!</p>
<p>The <a class="Link" href="https://drafts.csswg.org/selectors-4/#negation">spec<span class="shy"></span>i<span class="shy"></span>fi<span class="shy"></span>ca<span class="shy"></span>tion for the <code>:not()</code></a> doesn&#39;t say much about its new fea<span class="shy"></span>tures, al<span class="shy"></span>most all it says is that in<span class="shy"></span>stead of a sim<span class="shy"></span>ple se<span class="shy"></span>lec<span class="shy"></span>tor you can put a <strong>se<span class="shy"></span>lec<span class="shy"></span>tor list</strong> in<span class="shy"></span>side. But that alone means a lot.</p>
<h3 class="Heading" id="selector-lists"><a class="Anchor" aria-hidden="true" href="#selector-lists"></a><span class="ss01 hang-xs">S</span>elec<span class="shy"></span>tor Lists</h3>
<p>So, now we can use comma-sep<span class="shy"></span>a<span class="shy"></span>rated se<span class="shy"></span>lec<span class="shy"></span>tor lists in<span class="shy"></span>side <code>:not()</code>. The com<span class="shy"></span>mas there are ac<span class="shy"></span>tu<span class="shy"></span>ally an equiv<span class="shy"></span>a<span class="shy"></span>lent of log<span class="shy"></span>i<span class="shy"></span>cal <strong>or</strong>, but when in<span class="shy"></span>side the <code>:not()</code> they ac<span class="shy"></span>tu<span class="shy"></span>ally be<span class="shy"></span>come <strong>and</strong>.</p>
<p>This se<span class="shy"></span>lec<span class="shy"></span>tor would tar<span class="shy"></span>get all but<span class="shy"></span>tons that are not hov<span class="shy"></span>ered and not fo<span class="shy"></span>cused <em>at the same time</em>:</p>
<pre><code class="language-css">but<span class="shy"></span>ton:not(:hover, :fo<span class="shy"></span>cus)
</code></pre>
<p>And it is ba<span class="shy"></span>si<span class="shy"></span>cally an equiv<span class="shy"></span>a<span class="shy"></span>lent of</p>
<pre><code class="language-css">but<span class="shy"></span>ton:not(:hover):not(:fo<span class="shy"></span>cus)
</code></pre>
<p>The dif<span class="shy"></span>fer<span class="shy"></span>ent there is how the speci<span class="shy"></span>ficity works for se<span class="shy"></span>lec<span class="shy"></span>tor lists in<span class="shy"></span>side <code>:not()</code>, here is <a class="Link" href="https://drafts.csswg.org/selectors-4/#specificity-rules">what Spec says</a>:</p>
<blockquote>
<p>The speci<span class="shy"></span>ficity of a <code>:not()</code> pseudo-class is re<span class="shy"></span>placed by the speci<span class="shy"></span>ficity of the most spe<span class="shy"></span>cific com<span class="shy"></span>plex se<span class="shy"></span>lec<span class="shy"></span>tor in its se<span class="shy"></span>lec<span class="shy"></span>tor list ar<span class="shy"></span>gument.</p>
</blockquote>
<p>That means that the speci<span class="shy"></span>ficity of <code>:not(:hover, :fo<span class="shy"></span>cus)</code> is the same as the speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle class, so it is re<span class="shy"></span>ally dif<span class="shy"></span>fer<span class="shy"></span>ent than if you&#39;d just use mul<span class="shy"></span>ti<span class="shy"></span>ple <code>:not()</code>s. You can fit any num<span class="shy"></span>ber of se<span class="shy"></span>lec<span class="shy"></span>tors in<span class="shy"></span>side a se<span class="shy"></span>lec<span class="shy"></span>tor list in<span class="shy"></span>side <code>:not()</code> and you still would get the speci<span class="shy"></span>fi<span class="shy"></span>ity of only the high<span class="shy"></span>est one. And if the speci<span class="shy"></span>ficity would be the same for each se<span class="shy"></span>lec<span class="shy"></span>tor in list, you&#39;ll get only this speci<span class="shy"></span>ficity.</p>
<p>This is a first cru<span class="shy"></span>tial fea<span class="shy"></span>ture for our case.</p>
<h3 class="Heading" id="complex-selectors"><a class="Anchor" aria-hidden="true" href="#complex-selectors"></a><span class="ss02 hang-xs">C</span>om<span class="shy"></span>plex Se<span class="shy"></span>lectors</h3>
<p>The sec<span class="shy"></span>ond cru<span class="shy"></span>tial fea<span class="shy"></span>ture is that those se<span class="shy"></span>lec<span class="shy"></span>tor lists can now con<span class="shy"></span>tain com<span class="shy"></span>plex se<span class="shy"></span>lec<span class="shy"></span>tors. You could put only a sim<span class="shy"></span>ple se<span class="shy"></span>lec<span class="shy"></span>tor in<span class="shy"></span>side <code>:not()</code>, but now there won&#39;t be such limit, so you could do stuff like <code>:not(a.foo:nth-child(2n+1):hover)</code> and it would just work.</p>
<p>An<span class="shy"></span>other in<span class="shy"></span>ter<span class="shy"></span>est<span class="shy"></span>ing thing in <code>:not()</code> ac<span class="shy"></span>cept<span class="shy"></span>ing com<span class="shy"></span>plex se<span class="shy"></span>lec<span class="shy"></span>tors is that it can now also ac<span class="shy"></span>cept se<span class="shy"></span>lec<span class="shy"></span>tors with com<span class="shy"></span>bi<span class="shy"></span>na<span class="shy"></span>tors like <code>:not(.foo + .bar)</code>.</p>
<h3 class="Heading" id="negation-of-negation"><a class="Anchor" aria-hidden="true" href="#negation-of-negation"></a><span class="ss01 hang-m">N</span>ega<span class="shy"></span>tion of Negation</h3>
<p>Of course, since the <code>:not()</code> se<span class="shy"></span>lec<span class="shy"></span>tor is it<span class="shy"></span>self a com<span class="shy"></span>plex one, you can now use it in<span class="shy"></span>side other <code>:not()</code>s.</p>
<p>And, yeah, we&#39;re at the point where the magic would hap<span class="shy"></span>pen. What does dou<span class="shy"></span>ble nega<span class="shy"></span>tion means in logic? It re<span class="shy"></span>turns the value to its orig<span class="shy"></span>i<span class="shy"></span>nal bi<span class="shy"></span>nary state.</p>
<p>If we&#39;d have some<span class="shy"></span>thing like that:</p>
<pre><code class="language-css">:not(:not(:hover))
</code></pre>
<p>That would work just the same as a <code>:hover</code> pseudo<span class="shy"></span>class. That&#39;s rather sim<span class="shy"></span>ple. But what would hap<span class="shy"></span>pen if we&#39;d have a se<span class="shy"></span>lec<span class="shy"></span>tor list there?</p>
<pre><code class="language-css">:not(:not(:hover), :not(:fo<span class="shy"></span>cus))
</code></pre>
<p>As the se<span class="shy"></span>lec<span class="shy"></span>tor lists in<span class="shy"></span>side <code>:not()</code> work as a log<span class="shy"></span>i<span class="shy"></span>cal <strong>and</strong>, and given that each of the se<span class="shy"></span>lec<span class="shy"></span>tor would be re<span class="shy"></span>turned to its orig<span class="shy"></span>i<span class="shy"></span>nal mean<span class="shy"></span>ing, the re<span class="shy"></span>sult would be al<span class="shy"></span>most the same as <code>:hover:fo<span class="shy"></span>cus</code>. The dif<span class="shy"></span>fer<span class="shy"></span>ence would be that the speci<span class="shy"></span>ficity of the dou<span class="shy"></span>ble negated se<span class="shy"></span>lec<span class="shy"></span>tor wouldn&#39;t be the same as of the usual com<span class="shy"></span>plex one. Each of the nested <code>:not()</code> would have a speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle pseudo<span class="shy"></span>class, and due to how se<span class="shy"></span>lec<span class="shy"></span>tor lists work in<span class="shy"></span>side <code>:not()</code>, the speci<span class="shy"></span>ficity of the whole con<span class="shy"></span>struc<span class="shy"></span>tion would be equal, again, to a speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle pseudo<span class="shy"></span>class.</p>
<h2 class="Heading" id="controlling-the-specificity"><a class="Anchor" aria-hidden="true" href="#controlling-the-specificity"></a><span class="ss02 hang-xs">C</span>on<span class="shy"></span>trol<span class="shy"></span>ling the Speci<span class="shy"></span>ficity</h2>
<p>I think you can al<span class="shy"></span>ready guess what all of this means. That&#39;s <nobr>right —</nobr><span class="thinsp"> </span>us<span class="shy"></span>ing the new <code>:not()</code> we can now write se<span class="shy"></span>lec<span class="shy"></span>tors with a speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle class. And, ac<span class="shy"></span>tu<span class="shy"></span>ally, we can write <em>al<span class="shy"></span>most any se<span class="shy"></span>lec<span class="shy"></span>tor</em> this way.</p>
<p>So, if we&#39;d like to have a mul<span class="shy"></span>ti<span class="shy"></span>class with some states, like</p>
<pre><code class="language-css">.foo.bar.baz:link:hover
</code></pre>
<p>and for it to have a speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle class, so it could be eas<span class="shy"></span>ier over<span class="shy"></span>ri<span class="shy"></span>den later on, we could rewrite this se<span class="shy"></span>lec<span class="shy"></span>tor this way:</p>
<pre><code class="language-css">:not(:not(.foo), :not(.bar), :not(.baz), :not(:link), :not(:hover))
</code></pre>
<h3 class="Heading" id="what-about-combinators-"><a class="Anchor" aria-hidden="true" href="#what-about-combinators-"></a><span class="ss01 hang-m">W</span>hat About Com<span class="shy"></span>bi<span class="shy"></span>nators?</h3>
<p>But what if we&#39;d like to have more com<span class="shy"></span>plex se<span class="shy"></span>lec<span class="shy"></span>tors with com<span class="shy"></span>bi<span class="shy"></span>na<span class="shy"></span>tors, like this one?</p>
<pre><code class="language-css">.foo:hover &gt; .bar .baz
</code></pre>
<p>They&#39;re pos<span class="shy"></span>si<span class="shy"></span>ble too, but with a slightly more com<span class="shy"></span>plex code. What would help us is a uni<span class="shy"></span>ver<span class="shy"></span>sal se<span class="shy"></span>lec<span class="shy"></span>tor. Here is how the se<span class="shy"></span>lec<span class="shy"></span>tor above could look like if we&#39;d want it to have a speci<span class="shy"></span>ficity of a sin<span class="shy"></span>gle class:</p>
<pre><code class="language-css">:not(:not(:not(:not(:not(:not(.foo), :not(:hover)) &gt; *), :not(.bar)) *), :not(.baz))
</code></pre>
<p>That looks aw<span class="shy"></span>ful, right? But that works!</p>
<p>Of course, it would be<span class="shy"></span>come a bit read<span class="shy"></span>able if we&#39;d use some in<span class="shy"></span>den<span class="shy"></span>ta<span class="shy"></span>tions and stuff:</p>
<pre><code class="language-css">:not(
    :not(
        :not(
            :not(
                :not(
                    :not(.foo),
                    :not(:hover)
                ) &gt; *
            ),
            :not(.bar)
        ) *
    ),
    :not(.baz)
)
</code></pre>
<p>Due to how the se<span class="shy"></span>lec<span class="shy"></span>tor match<span class="shy"></span>ing mech<span class="shy"></span>a<span class="shy"></span>nism works, the se<span class="shy"></span>lec<span class="shy"></span>tors with com<span class="shy"></span>bi<span class="shy"></span>na<span class="shy"></span>tors would match from right to left, so the right<span class="shy"></span>est se<span class="shy"></span>lec<span class="shy"></span>tor would be al<span class="shy"></span>ways the one that matches the el<span class="shy"></span>e<span class="shy"></span>ment we&#39;re test<span class="shy"></span>ing the <code>:not()</code> on, so we can safely use just a uni<span class="shy"></span>ver<span class="shy"></span>sal se<span class="shy"></span>lec<span class="shy"></span>tor in<span class="shy"></span>stead of it if we need to just check the par<span class="shy"></span>ents. And the uni<span class="shy"></span>ver<span class="shy"></span>sal se<span class="shy"></span>lec<span class="shy"></span>tor brings no speci<span class="shy"></span>ficity with it.</p>
<p>The al<span class="shy"></span>go<span class="shy"></span>rithm be<span class="shy"></span>yond rewrit<span class="shy"></span>ing the se<span class="shy"></span>lec<span class="shy"></span>tor this way is rather sim<span class="shy"></span>ple: we go from right to left, re<span class="shy"></span>plac<span class="shy"></span>ing re<span class="shy"></span>cur<span class="shy"></span>cively all the parts with the dou<span class="shy"></span>ble nega<span class="shy"></span>tions, so for when we have nested com<span class="shy"></span>bi<span class="shy"></span>na<span class="shy"></span>tors, we would have more nested <code>:not()</code>s. And this way we would al<span class="shy"></span>ways be guar<span class="shy"></span>an<span class="shy"></span>teed to have the same speci<span class="shy"></span>ficity on each step.</p>
<h2 class="Heading" id="controlling-the-specificity"><a class="Anchor" aria-hidden="true" href="#controlling-the-specificity"></a><span class="ss02 hang-xs">C</span>on<span class="shy"></span>trol<span class="shy"></span>ling the Speci<span class="shy"></span>ficity</h2>
<p>It worth men<span class="shy"></span>tion<span class="shy"></span>ing that we can al<span class="shy"></span>ready in<span class="shy"></span>creace the speci<span class="shy"></span>ficity of any given class by just mul<span class="shy"></span>ti<span class="shy"></span>ply<span class="shy"></span>ing it, so <code>.foo.foo.foo</code> is just the same as <code>.foo</code>, but with a speci<span class="shy"></span>ficity of three classes. You can read about this method in Harry Roberts&#39; <a class="Link" href="http://csswizardry.com/2014/07/hacks-for-dealing-with-specificity/">ar<span class="shy"></span>ti<span class="shy"></span>cle on speci<span class="shy"></span>ficity hacks</a>. And as we can now both re<span class="shy"></span>duce and in<span class="shy"></span>crease the speci<span class="shy"></span>ficity of al<span class="shy"></span>most any given se<span class="shy"></span>lec<span class="shy"></span>tors, that means we can, fi<span class="shy"></span>nally, <strong>con<span class="shy"></span>trol</strong> the speci<span class="shy"></span>ficity of our se<span class="shy"></span>lec<span class="shy"></span>tors, re<span class="shy"></span>gard<span class="shy"></span>less of their com<span class="shy"></span>plex<span class="shy"></span>ity. Of couse, with the ex<span class="shy"></span>cep<span class="shy"></span>tion that we can&#39;t re<span class="shy"></span>duce the speci<span class="shy"></span>ficity to be less than the one of the biggest sin<span class="shy"></span>gle se<span class="shy"></span>lec<span class="shy"></span>tor&#39;s one, so we can&#39;t make a se<span class="shy"></span>lec<span class="shy"></span>tor con<span class="shy"></span>tain<span class="shy"></span>ing class to be as spe<span class="shy"></span>cific as an el<span class="shy"></span>e<span class="shy"></span>ment or uni<span class="shy"></span>ver<span class="shy"></span>sal se<span class="shy"></span>lector.</p>
<h2 class="Heading" id="possible-usage"><a class="Anchor" aria-hidden="true" href="#possible-usage"></a><span class="ss01 hang-m">P</span>os<span class="shy"></span>si<span class="shy"></span>ble Usage</h2>

          <p class="Metadata Published">Wrote as a draft, not published yet.
          </p>
          <aside class="Feedback">
            <p>If you've spotted a typo or a mistake, or wish to add something on, you could either <a href="https://github.com/kizu/kizu.github.com/issues/new?title=Feedback%20for%20%E2%80%9CControlling%20Specificity%E2%80%9D" class="Link">write me about this</a> or <a href="https://github.com/kizu/kizu.github.com/blob/source/src/documents/posts/drafts/controlling-specificity/index.en.md" class="Link">edit this article on Github</a>.
            </p>
          </aside>
        </div>
      </div>
    </article>
    <footer class="Page-Footer">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <nav role="navigation" class="PrevNext">
          </nav>
          <p role="contentinfo" class="Page-Copy"><a href="/en/" class="Link Link_wrapper">© 2016 <span class="Link-Inner">Roman Komarov</span>. </a><a href="https://twitter.com/kizmarh" class="Link Link_wrapper"><span class="Link-Inner">Follow me on twitter</span>!</a>
          </p>
        </div>
      </div>
    </footer>
    <script>var supportsWoff2=function(A){if(!("FontFace"in A)||"function"!=typeof A.FontFace)return!1;var t=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAADcAAoAAAAAAggAAACWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk4ALAoUNAE2AiQDCAsGAAQgBSAHIBtvAcieB3aD8wURQ+TZazbRE9HvF5vde4KCYGhiCgq/NKPF0i6UIsZynbP+Xi9Ng+XLbNlmNz/xIBBqq61FIQRJhC/+QA/08PJQJ3sK5TZFMlWzC/iK5GUN40psgqvxwBjBOg6JUSJ7ewyKE2AAaXZrfUB4v+hze37ugJ9d+DeYqiDwVgCawviwVFGnuttkLqIMGivmDg" ) format( "woff2" )',{});return t.load()["catch"](function(){}),"loading"==t.status||"loaded"==t.status}(this),h=document.getElementsByTagName("head")[0],link=document.createElement("link");link.href="/s/extras"+(supportsWoff2?"2":"")+".css",link.type="text/css",link.rel="stylesheet",h.appendChild(link);
    </script>
    <script src="/j/prism.js"></script>
    <script src="//mc.yandex.ru/metrika/watch.js"></script>
    <script type="text/javascript">
      //<![CDATA[
      (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter632758 = new Ya.Metrika({id:632758, clickmap:true, trackLinks:true, trackHash:true, webvisor:true}); } catch(e) {} }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f); } else { f(); } })(document, window, "yandex_metrika_callbacks");
      //]]>
    </script>
    <noscript><img src="//mc.yandex.ru/watch/632758" style="position:absolute; left:-9990px;"></noscript>
  </body>
</html>