---

categories: fun

layout: post

published: true

invisible: true

thanks_to:
    - "[Fev](http://taerin.deviantart.com/) за иллюстрацию"

---

# Отображение в потоке

![Как же собрать этот пазл?](/pictures/the-flow-of-display.jpg){:.b-figure width="756" height="382"}

В CSS есть множество нюансов. Иногда ты смотришь на код и думаешь: «Почему это вообще работает?!», и чем опытнее ты становишься, тем реже это происходит. Но всё ещё иногда происходит.

Несколько дней назад мои коллеги нашли решение одной проблемы, но не смогли понять _почему_ оно работает, так что они показали его мне. Я тоже не смог сходу разобраться, и только через несколько минут с кодом этого решения я понял в чём заключается решение. Это было то, что я и так, оказывается, знал, но применённое в довольно необычном контексте.

Итак, у меня есть для вас небольшая задачка, решение для которой я приведу позже в этой статье: у вас есть два элемента с одинаковым HTML вокруг и внутри, а также с практически одинаковым CSS. Помимо других общих вещей, эти элементы имеют `float:left` в CSS. И единственная вещь, которая различается — один из элементов имеет `display:inline-block`, а другой — `display:block`.

Так вот вопрос: какие должны быть условия, чтобы в этом случае — когда оба элемента имеют в своём CSS и `float:left` — была разница в том, какое значение `display` (`inline-block` или `block`) к ним применяется?

В поисках такого условия можно добавлять любой CSS к этим элементам, любой HTML контекст, главное, чтобы всё это было одинаковым для обоих элементов, и, понятное дело, нельзя переопределять свойства `float` и `display`.

Советую подумать над этим вопросом (и поэкспериментировать с кодом) перед тем, как читать продолжение статьи, задачка того стоит.

## Ближе к ответу {#closer-to-the-answer}

Забавно, что это поведение можно использовать в реальном коде, а не только в качестве головоломка. Собственно, именно на реальном примере я с этим и столкнулся — как с одим из возможных решений довольно непростой задачки. Приведу её тут.

Задача в том, чтобы в конце однострочного списка элементов был ещё один элемент, находящийся вплотную к остальным, при этом количество элементов до него варьируется в зависимости от и их ширины, и от ширины доступного горизонтального места.

Единственное решение, которое мы нашли, основано на допущении, что ширина этого последнего элемента фиксированная — но для нашей задачи этого было достаточно.

Собственно, вот живой пример того, как работает описываемый в этой статье эффект, попробуйте поменять ширину браузера, чтобы увидеть что происходит с элементами списка.

[demo:the-flow-of-display1]

На самом деле тот эффект, что описывается в статье, можно заменить на чуть другой код, но это будет менее лаконично и интересно.

Небольшая последняя подсказка перед тем, как раскрыть карты: как можно отменить эффект свойства `float`, но оставить влияние свойства `display`, отличного от `none`?

Есть одно свойство, которое можно добавить, и которое сделает всё то, что нам нужно. Это `position`.

## Поток

А если точнее, то `position:absolute` — если добавить его к нашим одинаковым элементам, то мы отменим поведение `float`. И многие разработчики думают, что оно полностью отменит и поведение `display`, но это не так.

В спецификациях CSS есть одно интересное место, которое можно перевести примерно так:

> whahahahahaha

Это значит, что если у элемента с `position:absolute` нет заданных свойств `top`, `right`, `bottom` и `left`, то этот элемент будет располагаться в том потоке, в котором он бы находился без применения позиционирования, и `display` в этом случае как раз влияет на то, какой будет поток.

Вот пример работы этого поведения:

[demo:the-flow-of-display2]

HTML для обоих примеров одинаков, за исключением классов:

{:.language-html}
    <p>
      Hello
      <span class="a">A</span>
    </p>
    <p>
      Hello
      <span class="b">B</span>
    </p>

CSS для них такой:

{:.language-css}
    .a {
        float: left;
        display: inline-block;
        }
    .b {
        float: left;
        display: block;
        }
    .a,
    .b {
        position: absolute;
        }

Да, `float` тут не нужен, так он ничего не будет делать, но он не будет и отменять поведение `display`. И, тогда как оба элемента полностью одинаковы и имеют `position:absolute`, из-зазначений `display` результат различается.

Чудесно! Подумайте о том, как одно свойство отменяет другое, но с добавлением третьего свойства первое свойство отменяется, а второе начинает действовать.

## Пример использования

Теперь я попробую описать почему это поведение может быть полезно для примера со списком, я приведу его тут ещё раз:

[demo:the-flow-of-display1]

Что тут происходит, и чего хотелось достичь — последний элемент должен всегда быть видимым и находиться в конце списка, при том, что ширина списка динамически меняется: элементы «спрыгивают» за `overflow` когда им не хватает места.

Не самая простая задачка, причём я сам её сходу не смог быстро решить, но, по крайней мере, теперь я знаю как это сделать и почему это можно сделать именно так.

HTML для этого списка: 

{:.language-html}
    <ul class="just-some-items">
        <li class="just-some-item">One</li>
        <li class="just-some-item">Two</li>
        <li class="just-some-item">Three</li>
        <li class="just-some-item">Four</li>
        <li class="just-some-item">Five</li>
        <li class="just-some-item">Six</li>
        <li class="just-some-item">Seven</li>
        <li class="just-some-item">Eight</li>
        <li class="just-some-item">Nine</li>
        <li class="just-some-item">Ten</li>
        <li class="just-some-item">Eleven</li>
        <li class="just-some-item">…last</li>
    </ul>

И значащий CSS таков (я оставлю часть презентационных стилей за рамками):

{:.language-css}
    .just-some-items {
        overflow: hidden;

        height: 2em;
        padding-right: 2.4em;
        margin: 0;
        }
    .just-some-item {
        float: left;

        margin-right: 0.5em;

        line-height: 2em;
        }
    .just-some-item:last-child {
        position: absolute;

        display: inline-block;

        width: 2.4em;
        }

Даже зная, что происходит внутри, когда я увидел этот код в первый раз, я не сразу разобрался. А происходит тут следующее:

1. Все элементы списка флоатятся, что обычно для подобных списков. Важно, что тут нельзя заменить `float` на `inline-block`.

2. Наличие флоатов выносит их из обычного потока. Это значит, что если мы рядом положим какой-нибудь элемент в обычный поток, то все флоаты будут его обтекать.

3. Теперь важно чтобы «ширина» нашего элемента была нулевой. В этом случае он как раз и будет всегда оставаться на первой «строчке» обычного потока, даже в тех случаях, когда флоаты занимают всё доступное место.

4. Тут в игру вступает `position:absolute`: он как раз и делает ровно то, что нам нужно — убирает элемент из потока (это равно заданию этому элементу нулевой ширины), а заодно и убирает `float` с этого элемента.

5. Но так как исходные элементы — `<li>`, они изначально имеют блочное поведение. А нам нужно, чтобы этот последний элемент находился в строчном контексте, иначе он не будет располагатсья на правильном месте. Тут мы и добавляем `display:inline-block` (и, на самом деле, достаточно добавить любое другое значение `display`, делающее его строчным). Элемент «нулевой ширины» становится на место в обычном потоке, которое мог бы занять, то есть ровно после всех предыдущих флоатов на первой строке.



## Заключение

Эффект, описываемый в статье — именно то, за что я так люблю CSS. Различные его свойства работают не только сами по себе, но и взаимодействуют друг с другом, порой в очень необычных, странных, неожиданных, но очень интересных комбинациях.

Чтобы полностью понять CSS, важно экспериментировать и консультироваться со спецификациями в тех случаях, когда вы не понимаете почему ваши эксперименты работают, но вы не знаете почему.

В этом случае вы узнаете много нового, и потом, когда встретите сложную задачу, сможете собрать решение из тех кусков паззла, что будут у вас на руках.