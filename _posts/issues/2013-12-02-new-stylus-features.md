---

categories: issues

layout: post

published: true

invisible: true

---

# Новые фичи в Стайлусе

Не так давно я <span class="sidenote" id="maintaining">стал мейнтейнером (* О том, как это произошло и чем именно я там занимаюсь я напишу как-нибудь в другой раз, тут стоит заметить только то, что я являюсь именно _мейнтейнером_, а основным _разработчиком_ сейчас является мой коллега [Миша Корепанов](@panyakor))</span> [Стайлуса](gh:LearnBoost/stylus) — отличного препроцессора для CSS.

Вчера мы зарелизили новую версию — [0.41.0](https://github.com/LearnBoost/stylus/blob/master/History.md#0410--2013-11-30), в которой добавили пару новых важных фич. А в двух релизах до этого мы добавили поддержку хешей и отполировали её, в результате этих трёх последних релизов стало возможным делать много всего интересного. В этой заметке я опишу <span class="sidenote" id="maintaining">один подход (* можете сразу промотать до [его пошагового описания](#example), либо до [результирующего кода](#result), либо [посмотреть на него в действии](#ololo-not-yet) на CodePen)</span>, который теперь доступен в Стайлусе, но сначала я немного напишу про новые фичи.

## Блочные миксины {#block-mixins}

Наконец-то! То, чего так давно не хватало в Стайлусе, и что уже довольно давно есть в главном «конкуренте» — Sass: возможность передавать в миксин блок стайлусовского кода и потом его использовать внутри миксина.

Синтаксис передачи блока довольно простой: вызываем миксин, используя префикс `+`, после чего передаём соответствующий блок либо в фигурных скобках, либо через блок с новым отступом (как всё обычно делается в Стайлусе):

    +foo()
      // Блок, который мы хотим передать
      width: 10px
      height: 10px
{:.language-css}

После того как мы таким образом передаём блок в миксин, этот блок становится доступным внутри миксина как именованный аргумент — `block`. После чего его можно или использовать сразу, используя <span class="sidenote" id="block-call">интерполяцию (* в будущем, возможно, добавится возможность использовать его без интерполяции)</span>:

    foo()
      width: 20px
      .foo
        {block}
{:.language-css}

Либо мы можем передать эту переменную дальше в другой миксин, или воспользоваться ей как-то иначе.

В итоге, если вызвать функцию выше как-то так:

    .bar
      +foo()
        padding: 0
        .baz
          height: 20px    
{:.language-css}

Мы получим следующее:

    .bar {
      width: 20px;
    }
    .bar .foo {
      padding: 0;
    }
    .bar .foo .baz {
      height: 20px;
    }
{:.language-css}

В итоге мы получаем возможность обрамлять блоки с помощью миксинов во что угодно (а в будущем, возможно, добавим и возможность _изменять_ переданные блоки). Обычно это используют для работы с медиакверями, и мой пример, который будет ниже в статье, как раз из той же области.

## Хеши {#hashes}

Как я уже упомянул, в последних релизах Стайлуса была добавлена (и потом допилена до рабочего состояния) возможность использовать хеши — объекты вида «свойство-значение». Выглядят они довольно просто:

    foo = {
      bar: 10px,
      raz: #fff,
      baz: {
        blah: blah
        '10%': yeah
      }
    }
{:.language-css}

Как видно из примера, синтаксис похож на обычные яваскриптовые объекты: ключём может быть или идент, или строка, а значением может быть почти что угодно, в том числе и вложенные хеши. Из важного: в отличие от обычных блоков в Стайлусе, фигурные скобки для хешей обязательны, но вот запятые — <span class="sidenote" id="codestyle">не обязательно (* Как и остальные опциональные фичи синтаксиса, если не придерживаться какого-то конкретного код-стайла, то код будет нечитабельным, так что решите как вы будете писать хеши и блоки и придерживайтесь этого решения)</span>.

После того, как вы объявили хеш, можно в него добавлять новые свойства или перезаписывать старые либо используя свойство через точку, либо через квадратные скобки:

    foo.bar = 20px
    foo['whatever'] = 'hello'
{:.language-css}

Отличия довольно простые: через точку можно писать только иденты, тогда как в квадратных скобкам нужно использовать любые строки, либо передавать переменные, в общем, с квадратными скобками получается более гибко, а через точку — короче.

Получать свойства из хешей можно аналогично — либо через точку, либо через квадратные скобки.

Не буду описывать остальные возможности хешей — их [довольно много](http://learnboost.github.io/stylus/docs/hashes.html), отмечу, что с ними нормально работает встроенная функция стайлуса `length()`, по ним можно итерироваться, можно проверять наличие ключей в условиях (`if baz in foo`), а также есть несколько встроенных функций для работы с хешами (`keys()`, `values()`, `merge`) и интерполяция хешей в CSS.

## Функция `selector()` {#selector}

В новом Стайлусе появилась небольшая, но важная фича — функция `selector()`. До неё в Стайлусе не было возможности _получить_ текущий селектор: его можно было составлять из вложенных блоков, интерполировать в него, но узнать какой же в итоге селектор получается было нельзя.

Но теперь есть функция `selector()`, которая возвращает текущий скомпилированный селектор. Его можно использовать для различных проверок, либо для каких-либо иных целей. Уже сейчас эта функция будет очень полезна в разных ситуациях, но в будущих релизах она станет ещё мощнее.

## Пример с кешируемыми медиакверями {#example}

В качестве примера использования новых фич я приведу решение одной из проблем модного нынче responsive design: огромного количества переопределений, которые нужно расставлять для разных вьюпортов. Проблема заключается в том, что синтаксис вызова медиакверей довольно объёмный, таким образом, приходится либо не обращать на это внимания и спокойно использовать <span class="sidenote" id="bubbling">«всплытие медиакверей» (* в препроцессорах, если использовать медиаквери внутри других блоков, они всплывают наверх, сохраняя текущий селектор)</span>, либо, в погоне за оптимизацией, писать все переопределения рядом, что во многих ситуациях будет менее удобно.

Однако, с блочными миксинами, хешами и функцией `selector()` в Стайлусе теперь можно обойти эти проблемы (и попутно решить ещё пару).

Если кратко описать решение: мы создадим миксин, заменяющий вызовы медиакверей и кеширующий их, объединяя по условиям, после чего даём возможность вывести весь закешированный код.

Единственным недостатком такого подхода будет то, что, так как всё группируется по конкретным медиакверям, порядок правил в коде поменяется, а следовательно, и их специфичность.

Для начала нам понадобится объект, в который мы будем сохранять вызванный в будущем код:

    $media_cache = {}
{:.language-css}

После этого нам нужен миксин, который мы и будем использовать вместо медиакверей, в первом приближении он будет выглядеть как-то так:

    media($type)
      $media_cache[$type] = () unless $media_cache[$type]
      push($media_cache[$type], block)
{:.language-css}

Миксин довольно простой: если у нас ещё нет в кеше списка по переданному в миксин ключу, мы инициируем его, после чего пушим переданный в миксин блок в кеш.

Но на самом деле нам этого не будет достаточно: такой миксин можно будет использовать только вот так:

    +media('(max-width:640px)')
      .foo
        display: block;
{:.language-css}

То есть мы только сможем прокидывать внутрь него полноценные блоки, но у нас не получится использовать всплытие:

    .foo
      +media('(max-width:640px)')
        display: block;
{:.language-css}

так как миксин ничего не знает о своём контексте — он знает только о блоке, который в него передали. Тут нам и поможет функция `selector()` плюс ещё один миксин-помощник, вместе с ними наш миксин будет выглядеть так:

    media($type)
      helper($type)
        $media_cache[$type] = () unless $media_cache[$type]
        push($media_cache[$type], block)
        
      +helper($type)
        {selector()}
          {block}
{:.language-css}

Для того, чтобы сохранять контекст, мы выносим изначальный код, помещающий переданный блок в кеш, в миксин `helper`, который тут же и вызываем, обрамляя переданный блок в текущий селектор.

Так как теперь при вызове нашего миксина всё будет помещаться в кеш, оно не будет выводиться само по себе. Значит, нам нужна функция, которая возьмёт содержимое кеша и выплеснет его там, где мы эту функцию применим (логично будет вызывать её в конце файла):

    apply_media_cache()
      for $media, $blocks in $media_cache
        @media $media
          for $block in $blocks
            {$block}
{:.language-css}

Всё довольно просто: сначала итерируемся по кешу, получая по очереди условие медиаквери `$media` и список вызванных с таким условием блоков `$blocks`, после чего создаём соответствующую медиаквери, внутри которой уже итерируемся по всем блокам, выводя их по очереди.

Теперь, если мы в конце документа её вызовем:

    apply_media_cache()
{:.language-css}

Мы получим то, ради чего всё затевали.

Однако, и эту функцию можно улучшить: ведь мы не хотим каждый раз писать при вызове скобочки, да и на самом деле хорошо бы всегда иметь в условии `screen and `. Кроме того, мы и вовсе можем захотеть использовать вместо конкретных значений ключевые слова, типа <span class="sidenote" id="bubbling">`palm`, `portable`, `desk` (* Для примера я выбрал градации из фреймворка Гарри Робертса [inuit.css](http://inuitcss.com/))</span> и т.п. Вместе с дополнениями и всеми предыдущими шагами мы получаем вот такой код:

### Итоговый код {#result}

    // Определяем объект кеша и объект с алиасами
    $media_cache = {}
    $media_aliases = {
      palm:       '(max-width: 480px)'
      lap:        '(min-width: 481px) and (max-width: 1023px)'
      lap-and-up: '(min-width: 481px)'
      portable:   '(max-width: 1023px)'
      desk:       '(min-width: 1024px)'
      desk-wide:  '(min-width: 1200px)'
    }

    // Миксин, кеширующая медиаквери
    media($type)
      helper($type)
        $media_cache[$type] = () unless $media_cache[$type]
        push($media_cache[$type], block)

      +helper($type)
        {selector()}
          {block}

    // Функция, вызывающая закешированные медиаквери
    apply_media_cache()
      for $media, $blocks in $media_cache
        $media = unquote($media_aliases[$media] || $media)
        $media = '(%s)' % $media unless match('\(', $media)
        $media = 'only screen and %s' % $media
        @media $media
          for $block in $blocks
            {$block}

    // Здесь будет основной код с вызовами миксина
    // …

    // Вызываем все закешированные медиаквери
    apply_media_cache()
{:.language-css}

Теперь мы можем писать код примерно так:

    .foo
      width: 10px

      +media('lap')
        width: 20px

      +media('desk')
        width: 30px

      +media('min-width: 200px')
        width: 60px

    .bar
      height: 10px

      +media('lap')
        height: 20px

      +media('desk')
        height: 30px

      +media('min-width: 200px')
        height: 50px

      +media('(min-width: 500px) and (max-width: 700px)')
        height: 50px
{:.language-css}

И в результате получим следующее:

    .foo {
      width: 10px;
    }
    .bar {
      height: 10px;
    }
    @media only screen and (min-width: 481px) and (max-width: 1023px) {
      .foo {
        width: 20px;
      }
      .bar {
        height: 20px;
      }
    }
    @media only screen and (min-width: 1024px) {
      .foo {
        width: 30px;
      }
      .bar {
        height: 30px;
      }
    }
    @media only screen and (min-width: 200px) {
      .foo {
        width: 60px;
      }
      .bar {
        height: 50px;
      }
    }
    @media only screen and (min-width: 500px) and (max-width: 700px) {
      .bar {
        height: 50px;
      }
    }
{:.language-css}

В итоговом коде видно, что мы добавили объект с алиасами, кроме того, мы можем вызывать миксин как в сокращённом варианте: без скобок, так и со скобками — все варианты будут работать.

Таким образом мы получили возможность удобно и быстро использовать всплывающие медиаквери в коде, с алиасами на ключевые слова и с группировкой результирующего кода по медиакверям. Всё благодаря новым возможностям, появившимся в последних трёх версиях Стайлуса.

Наверняка этот код не идеален, его можно улучшать и улучшать, но моей целью было показать новые фичи, а получившияся функция — лишь результат.