<!DOCTYPE html>
<html lang="ru" class="Page Page_post Page_ru">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Условия для CSS-переменных</title>
    <link rel="alternate" type="application/atom+xml" title="Atom feed" href="http://feeds.feedburner.com/kizu">
    <link rel="alternate" hreflang="en" href="http://kizu.ru/en/fun/conditions-for-css-variables/">
    <link rel="alternate" hreflang="ru" href="http://kizu.ru/fun/conditions-for-css-variables/">
    <link rel="stylesheet" href="/s/style.css">
    <link rel="preload" href="/s/extras2.css" as="style" onload="this.rel='stylesheet'">
  </head>
  <body class="Page-Body">
    <header class="Page-Header">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <h1 class="Page-Title"><a href="/" class="Page-Title-Link">Роман Комаров</a>
          </h1>
          <ul class="Page-Languages">
            <li class="Page-Language"><a data-short="en" href="/en/fun/conditions-for-css-variables/" class="Page-Language-Link">in English</a>
            </li>
            <li data-short="ru" class="Page-Language is-current">по-русски
            </li>
          </ul>
        </div>
      </div>
    </header>
    <article role="main" class="Page-Content">
      <div class="LiquidLayout">
        <div class="Main LiquidLayout-Content">
          <header><h1 class="Heading" id="условия-для-css-переменных"><a class="Anchor" aria-hidden="true" href="#условия-для-css-переменных"></a><span class="ss01 hang-m">У</span>сло­вия для <abbr>CSS</abbr>-пе­ре­мен­ных</h1>
          </header>
<p>Я нач­ну с того, что в спе­ци­фи­ка­ци­ях <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#not-those" id="not-those">нет ни­че­го</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Хотя и есть мо­дуль с на­зва­ни­ем “<a href="https://www.w3.org/TR/css3-conditional/"><abbr>CSS</abbr> Con­di­tional Rules</a>”, не сто­ит ожи­дать, что он о <abbr>CSS</abbr>-пе­ре­мен­ных<span class="nobr"> —</span><span class="thinsp"> </span>в нём толь­ко вся­кое про at-rules. И, кста­ти, даже есть <a href="https://tabatkins.github.io/specs/css-when-else/">пред­ло­же­ние</a> о @-пра­ви­лах <code>@when</code>/<code>@else</code>, ко­то­рые, опять же, ни­ка­ко­го от­но­ше­ния к пе­ре­мен­ным не име­ют.<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span> про усло­вия для <a class="Link" href="https://www.w3.org/TR/css-variables-1/"><abbr>CSS</abbr>-пе­ре­мен­ных</a>. Я ду­маю, что это огром­ное упу­ще­ние, так как, хотя пе­ре­мен­ные уже предо­став­ля­ют кучу ве­щей, ко­то­рые невоз­мож­но до­стичь ины­ми сред­ства­ми, от­сут­ствие усло­вий очень удру­ча­ет, так как их очень мно­го для чего мож­но было бы ис­поль­зовать.</p>
<p>Но что, если бы нам за­хо­те­лось ис­поль­зо­вать эти во­об­ра­жа­е­мые несу­ще­ству­ю­щие услов­ные кон­струк­ции для пе­ре­мен­ных уже <em>сей­час</em>? Как и со мно­же­ством дру­гих ве­щей в <abbr>CSS</abbr>, в ка­<span class="nobr">ких-то</span> слу­ча­ях мы мо­жем обой­тись и ха­ками.</p>
<h2 class="Heading" id="определение-проблемы"><a class="Anchor" aria-hidden="true" href="#определение-проблемы"></a><span class="ss01 hang-xs">О</span>пре­де­ле­ние про­блемы</h2>
<p>Итак, что нам нуж­но: воз­мож­ность при по­мо­щи един­ствен­ной <abbr>CSS</abbr>-пе­ре­мен­ной уметь за­да­вать <em>раз­ные</em> зна­че­ния для раз­ных <abbr>CSS</abbr>-свойств, при этом без того, что­бы эти зна­че­ния были ос­но­ва­ны на этой са­мой пе­ре­мен­ной (или дру­ги­ми сло­ва­ми<span class="nobr"> —</span><span class="thinsp"> </span>эти зна­че­ния не долж­ны <em>вы­чис­лять­ся</em> из на­шей пе­ре­мен­ной).</p>
<p>Нам нуж­ны <strong>усло­вия</strong>.</p>
<h2 class="Heading" id="использование-вычислений-для-бинарных-условий"><a class="Anchor" aria-hidden="true" href="#использование-вычислений-для-бинарных-условий"></a><span class="ss01 hang-m">И</span>споль­зо­ва­ние вы­чис­ле­ний для би­нар­ных условий</h2>
<p>Пе­рей­ду сра­зу к делу и при­ве­ду схо­ду ре­ше­ние, ко­то­рое уже поз­же объ­яс­ню, мо­же­те сна­ча­ла по­про­бо­вать сами по­нять что тут как ра­бо­тает:</p>
<pre><code class="language-css">:root {
    --is-big: 0;
}

.is-big {
    --is-big: 1;
}

.block {
    padding: calc(
        25px * var(--is-big) +
        10px * (1 - var(--is-big))
    );
    bor­der-width: calc(
        3px * var(--is-big) +
        1px * (1 - var(--is-big))
    );
}
</code></pre>
<p>В этом при­ме­ре мы за­став­ля­ем все наши эле­мен­ты с <code>.block</code> по­лу­чать пад­дин­ги рав­ные <code>10px</code> и ши­ри­ны гра­ниц рав­ные <code>1px</code>, до тех пор, пока зна­че­ние пе­ре­мен­ной <code>--is-big</code> на этих эле­мен­тах не ста­нет рав­ным <code>1</code>, и в этом слу­чае зна­че­ния ста­нут <code>25px</code> и <code>3px</code> со­от­вет­ственно.</p>
<p>Ме­ха­низм под всем этим до­воль­но про­стой: мы ис­поль­зу­ем оба воз­мож­ных зна­че­ния в еди­ном вы­чис­ле­нии, ис­поль­зуя <code>calc()</code>, где мы об­ну­ля­ем одно зна­че­ние и остав­ля­ем дру­гое в за­ви­си­мо­сти от на­шей пе­ре­мен­ной, ко­то­рая мо­жет при­ни­мать одно из двух зна­че­ний: <code>1</code> или <code>0</code>. Ины­ми сло­ва­ми, у нас там бу­дет <code>25px * 1 + 10px * 0</code> в од­ном слу­чае и <code>25px * 0 + 10px * 1</code> в другом.</p>
<h2 class="Heading" id="более-сложные-условия"><a class="Anchor" aria-hidden="true" href="#более-сложные-условия"></a><span class="ss01 hang-m">Б</span>олее слож­ные условия</h2>
<p>Мы мо­жем ис­поль­зо­вать этот ме­тод не толь­ко для вы­бо­ра из двух воз­мож­ных зна­че­ний, но и для трёх или бо­лее. Прав­да, для каж­до­го но­во­го зна­че­ния слож­ность вы­чис­ле­ния уве­ли­чи­ва­ет­ся. Так, для трёх воз­мож­ных зна­че­ний, вы­чис­ле­ние ста­нет уже таким:</p>
<pre><code class="language-css">.block {
    padding: calc(
        100px * (1 - var(--foo)) * (2 - var(--foo)) * 0.5 +
         20px * var(--foo) * (2 - var(--foo)) +
          3px * var(--foo) * (1 - var(--foo)) * -0.5
    );
}
</code></pre>
<p>Тут это вы­чис­ле­ние при­ни­ма­ет три воз­мож­ных зна­че­ния для пе­ре­мен­ной <code>--foo</code><span class="nobr"> —</span><span class="thinsp"> </span><code>0</code>, <code>1</code> и <code>2</code>, и вы­чис­ля­ет пад­динг рав­ный <code>100px</code>, <code>20px</code> или <code>3px</code> со­от­вет­ственно.</p>
<p>Об­щий прин­цип тот же: нам нуж­но каж­дый воз­мож­ный ре­зуль­тат умно­жить на вы­ра­же­ние, да­ю­щее <code>1</code> для нуж­но­го зна­че­ния пе­ре­мен­ной и <code>0</code> для осталь­ных. И это вы­ра­же­ние со­став­ля­ет­ся так же про­сто: нам нуж­но об­ну­лять каж­дое иное воз­мож­ное зна­че­ние пе­ре­мен­ной. По­сле чего нам нуж­но под­ста­вить то зна­че­ние, ко­то­рое долж­но да­вать <code>1</code> в по­лу­чив­ше­е­ся вы­ра­же­ние и до­ба­вить мно­жи­тель для того, что­бы при­ве­сти-таки ре­зуль­тат к этой са­мой еди­нице.</p>
<h3 class="Heading" id="возможная-ловушка-в-спецификациях"><a class="Anchor" aria-hidden="true" href="#возможная-ловушка-в-спецификациях"></a><span class="ss01 hang-m">В</span>озмож­ная ло­вуш­ка в спе­ци­фи­ка­циях</h3>
<p>С уве­ли­че­ни­ем слож­но­сти вы­чис­ле­ний по­яв­ля­ет­ся шанс, что они пе­ре­ста­нут ра­бо­тать. По­че­му? В <a class="Link" href="https://drafts.csswg.org/css-values-3/#calc-syntax">спе­ци­фи­ка­ции</a> есть та­кая вот за­мет­ка (в моём пе­ре­во­де):</p>
<blockquote>
<p>Бра­у­зе­ры долж­ны под­дер­жи­вать <code>calc()</code>-вы­ра­же­ния, со­сто­я­щие как ми­ни­мум из 20 тер­ми­нов, где каж­дое <abbr>ЧИС</abbr>­ЛО, <abbr>РАЗ</abbr>­<abbr>МЕР</abbr>­<abbr>НОСТЬ</abbr> или <abbr>ПРО</abbr>­<abbr>ЦЕНТ</abbr> яв­ля­ет­ся тер­ми­ном. Если <code>calc()</code>- вы­ра­же­ние со­дер­жит боль­ше тер­ми­нов, чем под­дер­жи­ва­ет­ся, та­кое вы­ра­же­ние долж­но счи­тать­ся нева­лидным.</p>
</blockquote>
<p>Ко­неч­но, я немно­го по­те­сти­ро­вал это дело и не смог най­ти по­доб­ных огра­ни­че­ний в су­ще­ству­ю­щих бра­у­зе­рах, но, так или ина­че, есть шанс, что если вы на­пи­ше­те до­ста­точ­но слож­ный код, то вы столк­нё­тесь с этим огра­ни­че­ни­ем, ну или ка­<span class="nobr">кие-то</span> бра­у­зе­ры вполне мо­гут его в бу­ду­щем до­ба­вить, так что будь­те осто­рожны.</p>
<h2 class="Heading" id="условия-для-цветов"><a class="Anchor" aria-hidden="true" href="#условия-для-цветов"></a><span class="ss01 hang-m">У</span>сло­вия для цветов</h2>
<p>Как мож­но уви­деть, та­кие вы­чис­ле­ния мо­гут ис­поль­зо­вать­ся толь­ко для тех ве­щей, ко­то­рые вы мо­же­те <em>вы­чис­лить</em>, так что не по­лу­чит­ся ис­поль­зо­вать это дело для пе­ре­клю­че­ния зна­че­ний свойств типа <code>dis­play</code> и ана­ло­гич­ных. Но что на­счёт цве­тов? На са­мом деле, мы мо­жем вы­чис­лять зна­че­ния от­дель­ных ком­по­нент цве­та. К со­жа­ле­нию, сей­час это бу­дет ра­бо­тать толь­ко в веб­ки­тах и блин­ках, а вот Fire­fox <a class="Link" href="https://bugzilla.mozilla.org/show_bug.cgi?id=984021" title="Bugzilla ticket">пока не под­дер­жи­ва­ет</a> <code>calc()</code> внут­ри <code>rgba()</code> или дру­гих цве­то­вых функций.</p>
<p>Но ко­гда та­кая под­держ­ка по­явит­ся (ну или если вам за­хо­чет­ся по­экс­пе­ри­мен­ти­ро­вать над этим де­лом там, где оно уже ра­бо­та­ет), мы мо­жем де­лать вещи вро­де этой:</p>
<pre><code class="language-css">:root {
    --is-red: 0;
}

.block {
    back­ground: rgba(
        calc(
            255*var(--is-red) +
            0*(1 - var(--is-red))
            ),
        calc(
            0*var(--is-red) +
            255*(1 - var(--is-red))
            ),
        0, 1);
}
</code></pre>
<p>Тут у нас бу­дет по умол­ча­нию зе­лё­ный цвет, и крас­ный, если мы за­да­дим <code>--is-red</code> зна­че­ние <code>1</code> (сто­ит от­ме­тить, что если ка­<span class="nobr">кой-то</span> ком­по­нент дол­жен быть ну­лём, то мы, оче­вид­но, мо­жем про­сто все его мно­же­те­ли опу­стить для бо­лее ком­пакт­ной за­пи­си, но тут я их оста­вил для луч­ше­го по­ни­ма­ния ал­го­рит­ма).</p>
<p>И, так как мы мо­жем вы­чис­лять лю­бые ком­по­нен­ты цве­та, мы мо­жем со­зда­вать для них наши услов­ные вы­чис­ле­ния (и, воз­мож­но, смо­жем де­лать их даже для гра­ди­ен­тов? Вам сто­ит это по­про­бо­вать!).</p>
<h3 class="Heading" id="очередная-ловушка-в-спецификациях"><a class="Anchor" aria-hidden="true" href="#очередная-ловушка-в-спецификациях"></a><span class="ss01 hang-xs">О</span>че­ред­ная ло­вуш­ка в спе­ци­фи­ка­циях</h3>
<p>Ко­гда я те­сти­ро­вал как ра­бо­та­ют улов­ные вы­чис­ле­ния для цве­тов, я на­ткнул­ся на очень, <em>очень</em> <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#issue-resolved" id="issue-resolved">стран­ное огра­ни­че­ние в спе­ци­фи­ки­ци­ях</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Таб Ат­кинс <a href="https://github.com/kizu/kizu.github.com/issues/186">рас­ска­зал</a> о том, что эта про­бле­ма с ком­по­нен­та­ми цве­та была по­прав­ле­на в спе­ци­фи­ка­ци­ях (но ис­прав­ле­ние ещё не под­дер­жа­но бра­у­зе­ра­ми). Ура! Та­к­же он ска­зал, что есть ещё ре­ше­ние<span class="nobr"> —</span><span class="thinsp"> </span>ис­поль­зо­вать внут­ри <code>rgba</code> про­цен­ты, а я со­вер­шен­но о та­кой воз­мож­но­сти за­был, хаха.<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>. Огра­ни­че­ние под на­зва­ни­ем <a class="Link Link_wrapper" href="https://twitter.com/kizmarh/status/788504161864261632">«<span class="Link-Inner">про­вер­ка ти­пов</span>»</a>. Те­перь я её офи­ци­аль­но нена­ви­жу. Что это огра­ни­че­ние зна­чит<span class="nobr"> —</span><span class="thinsp"> </span>если ваше свой­ство при­ни­ма­ет толь­ко зна­че­ние с ти­пом <code>&lt;in­te­ger&gt;</code>, то если у вас внут­ри <code>calc()</code> бу­дут дроб­ные чис­ла или лю­бое де­ле­ние, то даже если в ре­зуль­та­те бу­дет га­ран­ти­ро­ва­но це­лое чис­ло, то так на­зы­ва­е­мый «re­solved type» бу­дет не <code>&lt;in­te­ger&gt;</code>, а <code>&lt;num­ber&gt;</code>, что, в свою оче­редь, не даст этим свой­ствам при­ни­мать это зна­че­ние как ва­лид­ное. А так как, если по­смот­реть выше, в на­ших услов­ных вы­ра­же­ни­ях с бо­лее чем дву­мя зна­че­ни­я­ми ока­жут­ся дроб­ные мо­ди­фи­ка­то­ры, то они сде­ла­ют наши вы­чис­ле­ния нева­лид­ны­ми, как для ком­по­нент цве­та, так и для дру­гих свойств, при­ни­ма­ю­щих толь­ко <code>&lt;in­te­ger&gt;</code> (на­при­мер, <code>z-in­dex</code>).</p>
<p>Вот та­кое вы­ра­жение:</p>
<pre><code class="language-css">calc(255 * (1 - var(--bar)) * (var(--bar) - 2) * -0.5)
</code></pre>
<p>Не бу­дет ва­лид­ным внут­ри <code>rgba()</code>. Из­на­чаль­но я даже ду­мал, что та­кое по­ве­де­ние<span class="nobr"> —</span><span class="thinsp"> </span>баг, осо­бен­но учи­ты­вая, что цве­то­вые функ­ции во­об­ще хо­ро­шо пе­ре­ва­ри­ва­ют вся­кие зна­че­ния, вы­хо­дя­щие за ра­зум­ные гра­ни­цы (вы вполне мо­же­те на­пи­сать <code>rgba(9001, +9001, -9001, 42)</code> и это даст вам ва­лид­ный жёл­тый цвет), но вот эта вот ти­пи­за­ция ока­зы­ва­ет­ся слиш­ком слож­но пе­ре­ва­ри­ва­е­мой для бра­у­зеров.</p>
<h4 class="Heading" id="возможные-решения-"><a class="Anchor" aria-hidden="true" href="#возможные-решения-"></a><span class="ss01 hang-m">В</span>озмож­ные ре­шения?</h4>
<p>Есть одно до­воль­но да­лё­кое от иде­а­ла ре­ше­ние. Так как в на­шем слу­чае мы зна­ем и же­ла­е­мое зна­че­ние, и про­блем­ный мо­ди­фи­ка­тор с дро­бью, то мы мо­жем пред­вы­чис­лить их вме­сте и округ­лить пе­ред тем, как встав­лять в <code>calc()</code>. Да, во мно­гих слу­ча­ях по­лу­ча­е­мое зна­че­ние бу­дет чуть от­ли­чать­ся <span class="nobr">из-за</span> по­те­ри в точ­но­сти. Но это же луч­ше, чем ни­че­го, ведь правда?</p>
<p>Хотя есть ещё одно ре­ше­ние, но ко­то­рое бу­дет ра­бо­тать толь­ко с цве­та­ми<span class="nobr"> —</span><span class="thinsp"> </span>мы мо­жем ис­поль­зо­вать <code>hsla</code> вме­сто <code>rgba</code>, так как в та­ком слу­чае внут­ри бу­дут не це­лые чис­ла, а то, что таки нор­маль­но пе­ре­жё­вы­ва­ет <code>calc()</code>. Но да, для свойств вро­де <code>z-in­dex</code> это не про­ка­тит. И даже для цве­тов всё рав­но воз­мож­ны неболь­шие по­те­ри в точ­но­сти если пе­ре­во­дить для это­го <code>rgb</code> в <code>hsl</code>. Но эти по­те­ри долж­ны быть мень­ше, чем в преды­ду­щем ре­шении.</p>
<h2 class="Heading" id="препроцессинг"><a class="Anchor" aria-hidden="true" href="#препроцессинг"></a><span class="ss01 hang-m">П</span>ре­про­цессинг</h2>
<p>То­гда как для би­нар­ных усло­вий вполне ре­аль­но пи­сать вы­чис­ле­ния вруч­ную, для бо­лее слож­ных слу­ча­ев, или в слу­чае тех же цве­тов, нам бы при­го­ди­лись ин­стру­мен­ты, ко­то­рые бы поз­во­ли­ли де­лать это всё ав­то­ма­ти­че­ски. К сча­стью, у нас есть для это­го пре­про­цес­соры.</p>
<p>Вот как я ре­а­ли­зо­вал это быст­рень­ко на <span class="Sidenote-Wrapper"><a class="Sidenote-Context" href="#pen" id="pen">Стай­лу­се</a><span class="Sidenote" role="note"><span class="Sidenote-Misc"> (</span>Мож­но по­смот­реть на этот же код <a href="http://codepen.io/kizu/pen/zKmyvG">на Code­Pen</a> in ac­tion.<span class="Sidenote-Misc">)</span></span><a class="Sidenote-Close" href="#x" aria-hidden="true" tabindex="-1"></a></span>:</p>
<pre><code class="language-styl">con­di­tional($var, $val­ues...)
  $re­sult = &#39;&#39;

  // If there is only an ar­ray passed, use its con­tents
  if length($val­ues) == 1
    $val­ues = $val­ues[0]

  // Val­i­dat­ing the val­ues and check if we need to do any­thing at all
  $type = null
  $equal = true

  for $value, $i in $val­ues
    if $i &gt; 0 and $value != $val­ues[0]
      $equal = false

    $val­ue_­type = typeof($value)
    $type = $type || $val­ue_­type
    if !($type == &#39;unit&#39; or $type == &#39;rgba&#39;)
      er­ror(&#39;Con­di­tional func­tion can ac­cept only num­bers or col­ors&#39;)

    if $type != $val­ue_­type
      er­ror(&#39;Con­di­tional func­tion can ac­cept only same type val­ues&#39;)

  // If all the val­ues are equal, just re­turn one of them
  if $equal
    re­turn $val­ues[0]

  // Han­dling num­bers
  if $type == &#39;unit&#39;
    $re­sult = &#39;calc(&#39;
    $i_­count = 0
    for $value, $i in $val­ues
      $mul­ti­plier = &#39;&#39;
      $mod­i­fier = 1
      $j_­count = 0
      for $j in 0..(length($val­ues) - 1)
        if $j != $i
          $j_­count = $j_­count + 1
          // We could use just the gen­eral mul­ti­plier,
          // but for 0 and 1 we can sim­plify it a bit.
          if $j == 0
            $mod­i­fier = $mod­i­fier * $i
            $mul­ti­plier = $mul­ti­plier + $var
          else if $j == 1
            $mod­i­fier = $mod­i­fier * ($j - $i)
            $mul­ti­plier = $mul­ti­plier + &#39;(1 - &#39; + $var + &#39;)&#39;
          else
            $mod­i­fier = $mod­i­fier * ($i - $j)
            $mul­ti­plier = $mul­ti­plier + &#39;(&#39; + $var + &#39; - &#39; + $j + &#39;)&#39;

          if $j_­count &lt; length($val­ues) - 1
            $mul­ti­plier = $mul­ti­plier + &#39; * &#39;

      // If value is zero, just don&#39;t add it there lol
      if $value != 0
        if $mod­i­fier != 1
          $mul­ti­plier = $mul­ti­plier + &#39; * &#39; + (1 / $mod­i­fier)
        $re­sult = $re­sult + ($i_­count &gt; 0 ? &#39; + &#39; : &#39;&#39;) + $value + &#39; * &#39; + $mul­ti­plier
        $i_­count = $i_­count + 1

    $re­sult = $re­sult + &#39;)&#39;

  // Han­dling col­ors
  if $type == &#39;rgba&#39;
    $hues = ()
    $sat­u­ra­tions = ()
    $light­nesses = ()
    $al­phas = ()

    for $value in $val­ues
      push($hues, unit(hue($value), &#39;&#39;))
      push($sat­u­ra­tions, sat­u­ra­tion($value))
      push($light­nesses, light­ness($value))
      push($al­phas, al­pha($value))

    $re­sult = &#39;hsla(&#39; + con­di­tional($var, $hues) + &#39;, &#39; + con­di­tional($var, $sat­u­ra­tions) + &#39;, &#39; + con­di­tional($var, $light­nesses) + &#39;, &#39; + con­di­tional($var, $al­phas) +  &#39;)&#39;

  re­turn un­quote($re­sult)
</code></pre>
<p>Да, кода до­воль­но мно­го, но этот мик­син спо­со­бен ге­не­ри­ро­вать усло­вия как для чи­сел, так и для цве­тов, и не толь­ко для би­нар­ных усло­вий, но и для лю­бо­го чис­ла воз­мож­ных зна­че­ний в них.</p>
<p>Ис­поль­зо­ва­ние мик­си­на очень простое:</p>
<pre><code class="language-styl">bor­der-width: con­di­tional(var(--foo), 10px, 20px)
</code></pre>
<p>Пер­вый ар­гу­мент<span class="nobr"> —</span><span class="thinsp"> </span>наша пе­ре­мен­ная, вто­рым ар­гу­мен­том бу­дет то зна­че­ние, ко­то­рое долж­но при­ме­нять­ся ко­гда пе­ре­мен­ная бу­дет рав­на <code>0</code>, тре­тий ар­гу­мент<span class="nobr"> —</span><span class="thinsp"> </span><code>1</code>, и т.д.</p>
<p>Вы­зов мик­си­на выше сге­не­рит вот та­кое услов­ное вы­ра­жение:</p>
<pre><code class="language-css">bor­der-width: calc(10px * (1 - var(--foo)) + 20px * var(--foo));
</code></pre>
<p>А вот бо­лее слож­ный при­мер с цве­тами:</p>
<pre><code class="language-styl">color: con­di­tional(var(--bar), red, lime, re­bec­ca­pur­ple, or­ange)
</code></pre>
<p>Он сге­не­рит то, что вы точ­но не за­хо­ти­те пи­сать вручную:</p>
<pre><code class="language-css">color: hsla(calc(120 * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 270 * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 38.82352941176471 * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), calc(100% * (1 - var(--bar)) * (var(--bar) - 2) * (var(--bar) - 3) * 0.16666666666666666 + 100% * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 49.99999999999999% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 100% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), calc(50% * (1 - var(--bar)) * (var(--bar) - 2) * (var(--bar) - 3) * 0.16666666666666666 + 50% * var(--bar) * (var(--bar) - 2) * (var(--bar) - 3) * 0.5 + 40% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 3) * 0.5 + 50% * var(--bar) * (1 - var(--bar)) * (var(--bar) - 2) * -0.16666666666666666), 1);
</code></pre>
<p>Сто­ит от­ме­тить, что у меня в мик­сине нет под­держ­ки тех мест, где при­ни­ма­ют­ся толь­ко <code>&lt;in­te­ger&gt;</code>, так что он мо­жет не ра­бо­тать для <code>z-in­dex</code> и про­чих. Но он уже кон­вер­ти­ру­ет цве­та в <code>hsla()</code>, что­бы с ними справ­лять­ся (хотя и это мож­но до­де­лать так, что­бы это про­ис­хо­ди­ло толь­ко то­гда ко­гда нуж­но, а не все­гда). Дру­гая вещь, ко­то­рую я не ре­а­ли­зо­вал (пока?) в этом мик­сине<span class="nobr"> —</span><span class="thinsp"> </span>воз­мож­ность про­ки­ды­вать в ка­че­стве зна­че­ний дру­гие <abbr>CSS</abbr>-пе­ре­мен­ные. Это вполне воз­мож­но для тех свойств, что при­ни­ма­ют не <code>&lt;in­te­ger&gt;</code>, так как их мож­но бу­дет про­сто под­став­лять в наши услов­ные вы­чис­ле­ния. Воз­мож­но, ко­<span class="nobr">гда-ни</span>­будь я и най­ду вре­мя что­бы это до­де­лать. А пока мож­но для про­стых слу­ча­ев пи­сать эти вы­ра­же­ния вруч­ную сле­дуя ал­го­рит­му, опи­сан­но­му в этой статье.</p>
<h2 class="Heading" id="фолбеки"><a class="Anchor" aria-hidden="true" href="#фолбеки"></a><span class="ss01 hang-xs">Ф</span>ол­беки</h2>
<p>Ко­неч­но, если вы дей­стви­тель­но со­би­ра­е­тесь всё это дело ис­поль­зо­вать, вам по­на­до­бит­ся воз­мож­ность ис­поль­зо­вать фол­бе­ки. Для бра­у­зе­ров, не под­дер­жи­ва­ю­щих пе­ре­мен­ные, это про­сто<span class="nobr"> —</span><span class="thinsp"> </span>мож­но опре­де­лять де­кла­ра­цию с фол­бе­ком за­ранее:</p>
<pre><code class="language-css">.block {
    padding: 100px; /* fall­back */
    padding: calc(
        100px * ((1 - var(--foo)) * (2 - var(--foo)) / 2) +
         20px * (var(--foo) * (2 - var(--foo))) +
          3px * (var(--foo) * (1 - var(--foo)) / -2)
    );
}
</code></pre>
<p>Но вот ко­гда дело до­хо­дит до цве­тов, то по­яв­ля­ет­ся про­бле­ма: как толь­ко по­яв­ля­ют­ся пе­ре­мен­ные, то по фак­ту (и это оче­ред­ное очень стран­ное ме­сто в спе­ци­фи­ка­ци­ях), <em>тупо лю­бая</em> де­кла­ра­ция, в ко­то­рой есть <abbr>CSS</abbr>-пе­ре­мен­ные, ока­зы­ва­ет­ся ва­лид­ной. А это зна­чит, что не по­лу­чит­ся ис­поль­зо­вать фол­бек для чего-либо, где есть <abbr>CSS</abbr>-пе­ре­менные:</p>
<pre><code class="language-css">back­ground: blue;
back­ground: I 💩 CSS VAR(--I)ABLES;
</code></pre>
<p>Вот это вот<span class="nobr"> —</span><span class="thinsp"> </span>ва­лид­но со­глас­но спе­ци­фи­ка­ци­ям, фон бу­дет при­ни­мать своё <code>ini­tial</code> зна­че­ние, а фол­бек при­ме­нять­ся не бу­дет (даже если ну со­вер­шен­но оче­вид­но, что осталь­ные ча­сти зна­че­ния ну уж точ­но некор­рект­ны).</p>
<p>Так что, для того, что­бы предо­став­лять фол­бе­ки в по­доб­ных слу­ча­ях, нам надо бу­дет вос­поль­зо­вать­ся обёрт­кой с <code>@sup­ports</code>, в ко­то­рой мы бу­дем про­ве­рять под­держ­ку все­го <strong>кро­ме</strong> пе­ре­менных.</p>
<p>В на­шем слу­чае нам надо до­ба­вить та­кую обёрт­ку для Firefox:</p>
<pre><code class="language-css">.block {
    color: #f00;
}
@sup­ports (color: rgb(0, calc(0), 0)) {
    .block {
        color: rgba(calc(255 * (1 - var(--foo))), calc(255 * var(--foo)), 0, 1);
  }
}
</code></pre>
<p>Тут мы те­сти­ру­ем под­держ­ку вы­чис­ле­ний внут­ри цве­то­вых функ­ций, по­сле чего при­ме­ня­ем услов­ное вы­чис­ле­ние для цве­та внут­ри этой про­верки.</p>
<p>В прин­ци­пе, вполне воз­мож­но со­зда­вать та­кие фол­бе­ки ав­то­ма­ти­че­ски, но я бы не ре­ко­мен­до­вал ис­поль­зо­вать для это­го пре­про­цес­со­ры<span class="nobr"> —</span><span class="thinsp"> </span>слож­ность того, что для это­го нуж­но бу­дет де­лать уже пре­вы­ша­ет воз­мож­но­сти пре­про­цес­соров.</p>
<h2 class="Heading" id="сценарии-использования"><a class="Anchor" aria-hidden="true" href="#сценарии-использования"></a><span class="ss02 hang-xs">С</span>це­на­рии ис­поль­зо­вания</h2>
<p>Я, прав­да, не люб­лю рас­пи­сы­вать сце­на­рии ис­поль­зо­ва­ния для ве­щей, необ­хо­ди­мость в ко­то­рых оче­вид­на. Так что я буду кра­ток. И да, я опи­шу сце­на­рии ис­поль­зо­ва­ния усло­вий не толь­ко для пе­ре­мен­ных, но и для вы­чис­ле­ний с по­мо­щью <code>calc()</code>.</p>
<ul>
<li><p>Усло­вия для <abbr>CSS</abbr>-пе­ре­мен­ных мо­гут быть иде­аль­ны для те­ма­ти­за­ции бло­ков. С их по­мо­щью мож­но иметь на­бор про­ну­ме­ро­ван­ных тем и по­том при­ме­нять их к бло­кам (и даже ко вло­жен­ным!) ис­поль­зуя толь­ко одну <abbr>CSS</abbr>-пе­ре­мен­ную типа <code>--block-vari­ant: 1</code>. Это то, что невоз­мож­но сде­лать <span class="nobr">чем-то</span> кро­ме как пе­ре­мен­ны­ми, а если по­явит­ся необ­хо­ди­мость за­да­вать для темы раз­ные зна­че­ния для раз­ных свойств, то без усло­вий при­ш­лось бы за­да­вать це­лый на­бор раз­ных пе­ре­мен­ных каж­дый раз ко­гда хо­чет­ся при­ме­нить тему.</p>
</li>
<li><p>Ти­по­гра­фи­ка. Если бы была воз­мож­ность ис­поль­зо­вать срав­не­ния с <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> и <code>&gt;=</code>, то мож­но было бы со­здать на­бор «пра­вил» для раз­ных раз­ме­ров шриф­та, что­бы ав­то­ма­ти­че­ски под­би­рать вы­со­ту стро­ки, жир­ность и дру­гие свой­ства шриф­та в за­ви­си­мо­сти от ис­ход­но­го раз­ме­ра. Это и сей­час воз­мож­но, ко­неч­но, но не то­гда, ко­гда нуж­но иметь «шаги» для раз­ме­ров, а не про­сто зна­че­ния вы­чис­лен­ные из <code>em</code>-ов.</p>
</li>
<li><p>Адап­тив­ный ди­зайн. Ну, если бы были пол­но­цен­ные усло­вия для вы­чис­ле­ний, то это было бы по­чти что теми са­мы­ми «el­e­ment queries»<span class="nobr"> —</span><span class="thinsp"> </span>мож­но было бы смот­реть на <code>vw</code> или ши­ри­ну ро­ди­те­лей и ре­шать ка­кие зна­че­ния при­ме­нять в ка­ком случае.</p>
</li>
</ul>
<p>На­вер­ня­ка есть и дру­гие сце­на­рии ис­поль­зо­ва­ния для усло­вий, рас­ска­жи­те если при­ду­ма­е­те! Я сам, уве­рен, на­ты­кал­ся на мно­же­ство из них, но, так как у меня очень пло­хая па­мять, то я не за­по­ми­наю всё-всё, что я хочу де­лать с <abbr>CSS</abbr>. По­то­му что я хочу де­лать <em>всё</em>.</p>
<h2 class="Heading" id="будущее"><a class="Anchor" aria-hidden="true" href="#будущее"></a><span class="ss01 hang-m">Б</span>удущее</h2>
<p>Я бы очень хо­тел уви­деть усло­вия для <abbr>CSS</abbr>-пе­ре­мен­ных в спе­ци­фи­ки­ци­ях <abbr>CSS</abbr>, так что­бы нам не при­хо­ди­лось при­бе­гать к ха­кам и мы мог­ли бы ис­поль­зо­вать усло­вия и для невы­чис­ля­е­мых зна­че­ний. Ну и даже с ха­ка­ми пока невоз­мож­но ис­поль­зо­вать усло­вия кро­ме как стро­го­го ра­вен­ства, так что ни­ка­ких нам «если пе­ре­мен­ная боль­ше, чем X» и по­доб­ных ве­щей. Я не вижу при­чин по­че­му в <abbr>CSS</abbr> нель­зя до­ба­вить пол­но­цен­ные усло­вия, так что если вы зна­ко­мы с <span class="nobr">кем-то</span>, кто раз­ра­ба­ты­ва­ет спе­ци­фи­ка­ции <abbr>CSS</abbr><span class="nobr"> —</span><span class="thinsp"> </span>вы им на­мек­ни­те там. Я толь­ко на­де­юсь, что нам не от­ве­тят <span class="nobr">что-то</span> вро­де «про­сто ис­поль­зуй­те JS» и не ста­нут де­лать пред­по­ло­же­ния о том, по­че­му это в прин­ци­пе невоз­мож­но. Да вот же, оно уже воз­мож­но, пус­кай и с ха­ка­ми. Не мо­жет быть ни­ка­ких оправ­даний.</p>

          <p class="Metadata Published">Опубликовано 
            <time datetime="2016-10-21">21 октября 2016 г.</time> в <a href="../" class="Link">Экспериментах</a>.
          </p>
          <aside class="Feedback">
            <p>Если вы заметили ошибку или хотите чем-то дополнить статью, вы всегда можете <a href="https://github.com/kizu/kizu.github.com/issues/new?title=%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BD%D0%B0%20%C2%AB%D0%A3%D1%81%D0%BB%D0%BE%D0%B2%D0%B8%D1%8F%20%D0%B4%D0%BB%D1%8F%20CSS-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85%C2%BB" class="Link">написать мне об этом</a>, или <a href="https://github.com/kizu/kizu.github.com/blob/source/src/documents/posts/2016-10-21-(fun)-conditions-for-css-variables/index.ru.md" class="Link">поправить статью прямо на Гитхабе</a>.
            </p>
          </aside>
        </div>
      </div>
    </article>
    <footer class="Page-Footer">
      <div class="LiquidLayout">
        <div class="LiquidLayout-Content">
          <nav class="PrevNext"><a href="/blog/styling-inline-code/" class="Link Link_wrapper Link_prev"><span class="Link-Inner">Оформление строчных блоков кода</span></a><a href="/blog/just-en/" class="Link Link_wrapper Link_next"><span class="Link-Inner">Только по-английски</span></a>
          </nav>
          <p role="contentinfo" class="Page-Copy"><a href="/" class="Link Link_wrapper">© 2017 <span class="Link-Inner">Роман Комаров</span>. </a><a href="https://twitter.com/ki_zu" class="Link Link_wrapper"><span class="Link-Inner">Читайте меня в твиттере</span>!</a>
          </p>
        </div>
      </div>
    </footer>
    <script>var supportsWoff2=function(A){if(!("FontFace"in A)||"function"!=typeof A.FontFace)return!1;var t=new FontFace("t",'url( "data:application/font-woff2;base64,d09GMgABAAAAAADcAAoAAAAAAggAAACWAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAABk4ALAoUNAE2AiQDCAsGAAQgBSAHIBtvAcieB3aD8wURQ+TZazbRE9HvF5vde4KCYGhiCgq/NKPF0i6UIsZynbP+Xi9Ng+XLbNlmNz/xIBBqq61FIQRJhC/+QA/08PJQJ3sK5TZFMlWzC/iK5GUN40psgqvxwBjBOg6JUSJ7ewyKE2AAaXZrfUB4v+hze37ugJ9d+DeYqiDwVgCawviwVFGnuttkLqIMGivmDg" ) format( "woff2" )',{});return t.load()["catch"](function(){}),"loading"==t.status||"loaded"==t.status}(this),h=document.getElementsByTagName("head")[0],link=document.createElement("link");link.href="/s/extras"+(supportsWoff2?"2":"")+".css",link.type="text/css",link.rel="stylesheet",h.appendChild(link);
    </script>
    <script src="/j/prism.js"></script>
    <script src="//mc.yandex.ru/metrika/watch.js"></script>
    <script type="text/javascript">
      //<![CDATA[
      (function (d, w, c) { (w[c] = w[c] || []).push(function() { try { w.yaCounter632758 = new Ya.Metrika({id:632758, clickmap:true, trackLinks:true, trackHash:true, webvisor:true}); } catch(e) {} }); var n = d.getElementsByTagName("script")[0], s = d.createElement("script"), f = function () { n.parentNode.insertBefore(s, n); }; s.type = "text/javascript"; s.async = true; s.src = (d.location.protocol == "https:" ? "https:" : "http:") + "//mc.yandex.ru/metrika/watch.js"; if (w.opera == "[object Opera]") { d.addEventListener("DOMContentLoaded", f); } else { f(); } })(document, window, "yandex_metrika_callbacks");
      //]]>
    </script>
    <noscript><img src="//mc.yandex.ru/watch/632758" style="position:absolute; left:-9990px;" alt=""></noscript>
  </body>
</html>